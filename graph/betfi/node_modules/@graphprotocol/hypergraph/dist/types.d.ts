import type { Id as Grc20Id } from '@graphprotocol/grc-20';
import * as Schema from 'effect/Schema';
export declare const SignatureWithRecovery: Schema.Struct<{
    hex: typeof Schema.String;
    recovery: typeof Schema.Number;
}>;
export type SignatureWithRecovery = Schema.Schema.Type<typeof SignatureWithRecovery>;
export declare const ConnectAuthPayload: Schema.Struct<{
    expiry: typeof Schema.Number;
    encryptionPublicKey: typeof Schema.String;
    appId: typeof Schema.String;
}>;
export type ConnectAuthPayload = Schema.Schema.Type<typeof ConnectAuthPayload>;
export declare const ConnectCallbackResult: Schema.Struct<{
    appIdentityAddress: typeof Schema.String;
    appIdentityAddressPrivateKey: typeof Schema.String;
    accountAddress: typeof Schema.String;
    permissionId: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    signaturePrivateKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    encryptionPrivateKey: typeof Schema.String;
    sessionToken: typeof Schema.String;
    sessionTokenExpires: typeof Schema.Date;
    privateSpaces: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
    }>>;
    publicSpaces: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
    }>>;
}>;
export type ConnectCallbackResult = Schema.Schema.Type<typeof ConnectCallbackResult>;
export declare const ConnectCallbackDecryptedData: Schema.Struct<{
    sessionTokenExpires: typeof Schema.Number;
    expiry: typeof Schema.Number;
    appIdentityAddress: typeof Schema.String;
    appIdentityAddressPrivateKey: typeof Schema.String;
    accountAddress: typeof Schema.String;
    permissionId: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    signaturePrivateKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    encryptionPrivateKey: typeof Schema.String;
    sessionToken: typeof Schema.String;
    privateSpaces: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
    }>>;
    publicSpaces: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
    }>>;
}>;
export type ConnectCallbackDecryptedData = Schema.Schema.Type<typeof ConnectCallbackDecryptedData>;
declare const FailedToParseConnectAuthUrl_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "FailedToParseConnectAuthUrl";
} & Readonly<A>;
export declare class FailedToParseConnectAuthUrl extends FailedToParseConnectAuthUrl_base<{
    message: string;
}> {
}
declare const FailedToParseAuthCallbackUrl_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "FailedToParseAuthCallbackUrl";
} & Readonly<A>;
export declare class FailedToParseAuthCallbackUrl extends FailedToParseAuthCallbackUrl_base<{
    message: string;
}> {
}
export type MappingEntry = {
    typeIds: Grc20Id.Id[];
    properties?: {
        [key: string]: Grc20Id.Id;
    };
    relations?: {
        [key: string]: Grc20Id.Id;
    };
};
export type Mapping = {
    [key: string]: MappingEntry;
};
export {};
//# sourceMappingURL=types.d.ts.map