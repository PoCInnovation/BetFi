import type { ParseError } from 'effect/ParseResult';
import * as Schema from 'effect/Schema';
import type { InvalidIdentityError } from '../identity/types.js';
export declare const EventAuthor: Schema.Struct<{
    accountAddress: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>;
export type EventAuthor = Schema.Schema.Type<typeof Author>;
export declare const SpaceMember: Schema.Struct<{
    accountAddress: typeof Schema.String;
    role: Schema.Union<[Schema.Literal<["admin"]>, Schema.Literal<["member"]>]>;
}>;
export type SpaceMember = Schema.Schema.Type<typeof SpaceMember>;
export declare const SpaceInvitation: Schema.Struct<{
    inviteeAccountAddress: typeof Schema.String;
}>;
export type SpaceInvitation = Schema.Schema.Type<typeof SpaceInvitation>;
export declare const SpaceInbox: Schema.Struct<{
    inboxId: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    secretKey: typeof Schema.String;
}>;
export type SpaceInbox = Schema.Schema.Type<typeof SpaceInbox>;
export declare const SpaceState: Schema.Struct<{
    id: typeof Schema.String;
    invitations: Schema.Record$<typeof Schema.String, Schema.Struct<{
        inviteeAccountAddress: typeof Schema.String;
    }>>;
    members: Schema.Record$<typeof Schema.String, Schema.Struct<{
        accountAddress: typeof Schema.String;
        role: Schema.Union<[Schema.Literal<["admin"]>, Schema.Literal<["member"]>]>;
    }>>;
    removedMembers: Schema.Record$<typeof Schema.String, Schema.Struct<{
        accountAddress: typeof Schema.String;
        role: Schema.Union<[Schema.Literal<["admin"]>, Schema.Literal<["member"]>]>;
    }>>;
    inboxes: Schema.Record$<typeof Schema.String, Schema.Struct<{
        inboxId: typeof Schema.String;
        encryptionPublicKey: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        secretKey: typeof Schema.String;
    }>>;
    lastEventHash: typeof Schema.String;
}>;
export type SpaceState = Schema.Schema.Type<typeof SpaceState>;
export declare const CreateSpaceEvent: Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["create-space"]>;
        id: typeof Schema.String;
        creatorAccountAddress: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type CreateSpaceEvent = Schema.Schema.Type<typeof CreateSpaceEvent>;
export declare const DeleteSpaceEvent: Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["delete-space"]>;
        id: typeof Schema.String;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type DeleteSpaceEvent = Schema.Schema.Type<typeof DeleteSpaceEvent>;
export declare const CreateInvitationEvent: Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["create-invitation"]>;
        id: typeof Schema.String;
        inviteeAccountAddress: typeof Schema.String;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type CreateInvitationEvent = Schema.Schema.Type<typeof CreateInvitationEvent>;
export declare const CreateSpaceInboxEvent: Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["create-space-inbox"]>;
        id: typeof Schema.String;
        spaceId: typeof Schema.String;
        inboxId: typeof Schema.String;
        encryptionPublicKey: typeof Schema.String;
        secretKey: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type CreateSpaceInboxEvent = Schema.Schema.Type<typeof CreateSpaceInboxEvent>;
export declare const AcceptInvitationEvent: Schema.Struct<{
    transaction: Schema.Struct<{
        id: typeof Schema.String;
        type: Schema.Literal<["accept-invitation"]>;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type AcceptInvitationEvent = Schema.Schema.Type<typeof AcceptInvitationEvent>;
export declare const SpaceEvent: Schema.Union<[Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["create-space"]>;
        id: typeof Schema.String;
        creatorAccountAddress: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>, Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["delete-space"]>;
        id: typeof Schema.String;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>, Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["create-invitation"]>;
        id: typeof Schema.String;
        inviteeAccountAddress: typeof Schema.String;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>, Schema.Struct<{
    transaction: Schema.Struct<{
        id: typeof Schema.String;
        type: Schema.Literal<["accept-invitation"]>;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>, Schema.Struct<{
    transaction: Schema.Struct<{
        type: Schema.Literal<["create-space-inbox"]>;
        id: typeof Schema.String;
        spaceId: typeof Schema.String;
        inboxId: typeof Schema.String;
        encryptionPublicKey: typeof Schema.String;
        secretKey: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        previousEventHash: typeof Schema.String;
    }>;
    author: Schema.Struct<{
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>]>;
export type SpaceEvent = Schema.Schema.Type<typeof SpaceEvent>;
export declare const Author: Schema.Struct<{
    accountAddress: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    signaturePrivateKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
}>;
export type Author = Schema.Schema.Type<typeof Author>;
export declare class VerifySignatureError {
    readonly _tag = "VerifySignatureError";
}
export declare class InvalidEventError {
    readonly _tag = "InvalidEventError";
}
export type ApplyError = ParseError | VerifySignatureError | InvalidEventError | InvalidIdentityError;
//# sourceMappingURL=types.d.ts.map