import { isRelationField } from '../utils/isRelationField.js';
import { hasValidTypesProperty } from './hasValidTypesProperty.js';
export const getEntityRelations = (entityId, type, doc, include) => {
  const relations = {};
  for (const [fieldName, field] of Object.entries(type.fields)) {
    // skip non-relation fields or relations that are not defined in the include object
    if (!isRelationField(field)) continue;
    // Currently we still add an empty array for relations that are not included.
    // This is to ensure that the relation is not undefined in the decoded entity.
    // In the future we might want to derive a schema based on the include object.
    if (!include?.[fieldName]) {
      relations[fieldName] = [];
      continue;
    }
    const relationEntities = [];
    for (const [relationId, relation] of Object.entries(doc.relations ?? {})) {
      // @ts-expect-error name is defined
      const typeName = type.name;
      if (relation.fromTypeName !== typeName || relation.fromPropertyName !== fieldName || relation.from !== entityId) continue;
      if (relation.__deleted) continue;
      const relationEntity = doc.entities?.[relation.to];
      if (!hasValidTypesProperty(relationEntity)) continue;
      relationEntities.push({
        ...relationEntity,
        id: relation.to,
        _relation: {
          id: relationId
        }
      });
    }
    relations[fieldName] = relationEntities;
  }
  return relations;
};
//# sourceMappingURL=getEntityRelations.js.map