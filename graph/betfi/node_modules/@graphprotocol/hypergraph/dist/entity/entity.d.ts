import type { AnyNoContext } from './types.js';
import * as VariantSchema from './variant-schema.js';
declare const Class: <Self = never>(identifier: string) => <const Fields extends VariantSchema.Struct.Fields>(fields: Fields & VariantSchema.Struct.Validate<Fields, "update" | "insert" | "select">, annotations?: import("effect/Schema").Annotations.Schema<Self, readonly []> | undefined) => [Self] extends [never] ? "Missing `Self` generic - use `class Self extends Class<Self>()({ ... })`" : VariantSchema.Class<Self, Fields, VariantSchema.ExtractFields<"select", Fields, true> extends infer T ? { [K in keyof T]: VariantSchema.ExtractFields<"select", Fields, true>[K]; } : never, import("effect/Schema").Struct.Type<VariantSchema.ExtractFields<"select", Fields, true> extends infer T_1 ? { [K in keyof T_1]: VariantSchema.ExtractFields<"select", Fields, true>[K]; } : never>, import("effect/Schema").Struct.Encoded<VariantSchema.ExtractFields<"select", Fields, true> extends infer T_2 ? { [K in keyof T_2]: VariantSchema.ExtractFields<"select", Fields, true>[K]; } : never>, import("effect/Schema").Schema.Context<(VariantSchema.ExtractFields<"select", Fields, true> extends infer T_3 ? { [K in keyof T_3]: VariantSchema.ExtractFields<"select", Fields, true>[K]; } : never)[keyof VariantSchema.ExtractFields<"select", Fields, true>]>, import("effect/Schema").Struct.Constructor<VariantSchema.ExtractFields<"select", Fields, true> extends infer T_4 ? { [K in keyof T_4]: VariantSchema.ExtractFields<"select", Fields, true>[K]; } : never>> & {
    readonly update: import("effect/Schema").Struct<VariantSchema.ExtractFields<"update", Fields, false> extends infer T_5 ? { [K_1 in keyof T_5]: VariantSchema.ExtractFields<"update", Fields, false>[K_1]; } : never>;
    readonly insert: import("effect/Schema").Struct<VariantSchema.ExtractFields<"insert", Fields, false> extends infer T_6 ? { [K_2 in keyof T_6]: VariantSchema.ExtractFields<"insert", Fields, false>[K_2]; } : never>;
    readonly select: import("effect/Schema").Struct<VariantSchema.ExtractFields<"select", Fields, false> extends infer T_7 ? { [K_3 in keyof T_7]: VariantSchema.ExtractFields<"select", Fields, false>[K_3]; } : never>;
}, Field: <const A extends VariantSchema.Field.ConfigWithKeys<"update" | "insert" | "select">>(config: A & { readonly [K in Exclude<keyof A, "update" | "insert" | "select">]: never; }) => VariantSchema.Field<A>;
export { Class, Field };
declare const EntityNotFoundError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "EntityNotFoundError";
} & Readonly<A>;
export declare class EntityNotFoundError extends EntityNotFoundError_base<{
    id: string;
    type: AnyNoContext;
    cause?: unknown;
}> {
}
//# sourceMappingURL=entity.d.ts.map