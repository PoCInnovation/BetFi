import { secp256k1 } from '@noble/curves/secp256k1';
import { canonicalize, hexToBytes, stringToUint8Array } from '../utils/index.js';
import { encryptInboxMessage } from './message-encryption.js';
export async function prepareSpaceInboxMessage({
  message,
  spaceId,
  inboxId,
  encryptionPublicKey,
  signaturePrivateKey,
  authorAccountAddress
}) {
  const {
    ciphertext
  } = encryptInboxMessage({
    message,
    encryptionPublicKey
  });
  let signature;
  if (signaturePrivateKey && authorAccountAddress) {
    const messageToSign = stringToUint8Array(canonicalize({
      spaceId,
      inboxId,
      ciphertext,
      authorAccountAddress
    }));
    const signatureInstance = secp256k1.sign(messageToSign, hexToBytes(signaturePrivateKey), {
      prehash: true
    });
    signature = {
      hex: signatureInstance.toCompactHex(),
      recovery: signatureInstance.recovery
    };
  }
  const messageToSend = {
    ciphertext,
    signature,
    authorAccountAddress: authorAccountAddress ?? undefined
  };
  return messageToSend;
}
export async function prepareAccountInboxMessage({
  message,
  accountAddress,
  inboxId,
  encryptionPublicKey,
  signaturePrivateKey,
  authorAccountAddress
}) {
  const {
    ciphertext
  } = encryptInboxMessage({
    message,
    encryptionPublicKey
  });
  let signature;
  if (signaturePrivateKey && authorAccountAddress) {
    const messageToSign = stringToUint8Array(canonicalize({
      accountAddress,
      inboxId,
      ciphertext,
      authorAccountAddress
    }));
    const signatureInstance = secp256k1.sign(messageToSign, hexToBytes(signaturePrivateKey), {
      prehash: true
    });
    signature = {
      hex: signatureInstance.toCompactHex(),
      recovery: signatureInstance.recovery
    };
  }
  const messageToSend = {
    ciphertext,
    signature,
    authorAccountAddress: authorAccountAddress ?? undefined
  };
  return messageToSend;
}
//# sourceMappingURL=prepare-message.js.map