export declare class NaNNotAllowedError extends Error {
    constructor();
}
export declare class InfinityNotAllowedError extends Error {
    constructor();
}
/**
 * JSON canonicalize function.
 * Creates crypto safe predictable canocalization of JSON as defined by RFC8785.
 *
 * @see https://tools.ietf.org/html/rfc8785
 * @see https://www.rfc-editor.org/rfc/rfc8785
 *
 * @example <caption>Primitive values</caption>
 * ```ts
 * import { canonicalize } from '@graph-framework/utils'
 *
 * console.log(canonicalize(null)) // 'null'
 * console.log(canonicalize(1)) // '1'
 * console.log(canonicalize("test")) // "string"
 * console.log(canonicalize(true)) // 'true'
 * ```
 *
 * @example <caption>Objects</caption>
 * ```
 * import { canonicalize } from '@graph-framework/utils'
 *
 * const json = {
 *    from_account: '543 232 625-3',
 *    to_account: '321 567 636-4',
 *    amount: 500,
 *    currency: 'USD',
 * };
 * console.log(canonicalize(json)) // '{"amount":500,"currency":"USD","from_account":"543 232 625-3","to_account":"321 567 636-4"}'
 * ```
 *
 * @example <caption>Arrays</caption>
 * ```ts
 * import { canonicalize } from '@graph-framework/utils'
 *
 * console.log(canonicalize([1, 'text', null, true, false])) // '[1,"text",null,true,false]'
 * ```
 *
 * @param object object to JSC canonicalize
 * @throws NaNNotAllowedError if given object is of type number, but is not a valid number
 * @throws InfinityNotAllowedError if given object is of type number, but is the infinite number
 */
export declare function canonicalize<T = unknown>(object: T): string;
//# sourceMappingURL=jsc.d.ts.map