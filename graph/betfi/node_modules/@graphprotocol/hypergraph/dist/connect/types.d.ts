import { Schema } from 'effect';
export type Storage = {
    getItem: (key: string) => string | null;
    setItem: (key: string, value: string) => void;
    removeItem: (key: string) => void;
};
export type SignMessage = (message: string) => Promise<string> | string;
export type GetAddress = () => Promise<string> | string;
export type Signer = {
    getAddress: GetAddress;
    signMessage: SignMessage;
};
export type IdentityKeys = {
    encryptionPublicKey: string;
    encryptionPrivateKey: string;
    signaturePublicKey: string;
    signaturePrivateKey: string;
};
export declare const KeysSchema: Schema.Struct<{
    encryptionPublicKey: typeof Schema.String;
    encryptionPrivateKey: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    signaturePrivateKey: typeof Schema.String;
}>;
export type KeysSchema = Schema.Schema.Type<typeof KeysSchema>;
export declare const AppIdentityResponse: Schema.Struct<{
    accountAddress: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    accountProof: typeof Schema.String;
    keyProof: typeof Schema.String;
    ciphertext: typeof Schema.String;
    nonce: typeof Schema.String;
    sessionToken: typeof Schema.String;
    address: typeof Schema.String;
    appId: typeof Schema.String;
    sessionTokenExpires: typeof Schema.String;
}>;
export type AppIdentityResponse = Schema.Schema.Type<typeof AppIdentityResponse>;
export type Identity = IdentityKeys & {
    accountAddress: string;
};
export type PublicAppIdentity = {
    address: string;
    encryptionPublicKey: string;
    signaturePublicKey: string;
};
export type PrivateAppIdentity = IdentityKeys & {
    address: string;
    addressPrivateKey: string;
    permissionId: string;
    sessionToken: string;
    sessionTokenExpires: Date;
    accountAddress: string;
};
export declare class InvalidIdentityError {
    readonly _tag = "InvalidIdentityError";
}
//# sourceMappingURL=types.d.ts.map