import * as Schema from 'effect/Schema';
export declare const SignedUpdate: Schema.Struct<{
    update: typeof Schema.Uint8Array;
    accountAddress: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
    updateId: typeof Schema.String;
}>;
export declare const Updates: Schema.Struct<{
    updates: Schema.Array$<Schema.Struct<{
        update: typeof Schema.Uint8Array;
        accountAddress: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
        updateId: typeof Schema.String;
    }>>;
    firstUpdateClock: typeof Schema.Number;
    lastUpdateClock: typeof Schema.Number;
}>;
export type Updates = Schema.Schema.Type<typeof Updates>;
export declare const KeyBox: Schema.Struct<{
    accountAddress: typeof Schema.String;
    ciphertext: typeof Schema.String;
    nonce: typeof Schema.String;
    authorPublicKey: typeof Schema.String;
}>;
export type KeyBox = Schema.Schema.Type<typeof KeyBox>;
export declare const KeyBoxWithKeyId: Schema.Struct<{
    id: typeof Schema.String;
    accountAddress: typeof Schema.String;
    ciphertext: typeof Schema.String;
    nonce: typeof Schema.String;
    authorPublicKey: typeof Schema.String;
}>;
export type KeyBoxWithKeyId = Schema.Schema.Type<typeof KeyBoxWithKeyId>;
export declare const IdentityKeyBox: Schema.Struct<{
    signer: typeof Schema.String;
    accountAddress: typeof Schema.String;
    ciphertext: typeof Schema.String;
    nonce: typeof Schema.String;
}>;
export type IdentityKeyBox = Schema.Schema.Type<typeof IdentityKeyBox>;
export declare const RequestCreateSpaceEvent: Schema.Struct<{
    type: Schema.Literal<["create-space-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
    keyBox: Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>;
    name: typeof Schema.String;
}>;
export type RequestCreateSpaceEvent = Schema.Schema.Type<typeof RequestCreateSpaceEvent>;
export declare const RequestConnectCreateSpaceEvent: Schema.Struct<{
    type: Schema.Literal<["connect-create-space-event"]>;
    accountAddress: typeof Schema.String;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
    keyBox: Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>;
    infoContent: typeof Schema.String;
    infoSignature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
    name: typeof Schema.String;
}>;
export type RequestConnectCreateSpaceEvent = Schema.Schema.Type<typeof RequestConnectCreateSpaceEvent>;
export declare const RequestCreateInvitationEvent: Schema.Struct<{
    type: Schema.Literal<["create-invitation-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-invitation"]>;
            id: typeof Schema.String;
            inviteeAccountAddress: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
    keyBoxes: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>>;
}>;
export declare const RequestConnectAddAppIdentityToSpaces: Schema.Struct<{
    type: Schema.Literal<["connect-add-app-identity-to-spaces"]>;
    appIdentityAddress: typeof Schema.String;
    accountAddress: typeof Schema.String;
    spacesInput: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        keyBoxes: Schema.Array$<Schema.Struct<{
            id: typeof Schema.String;
            accountAddress: typeof Schema.String;
            ciphertext: typeof Schema.String;
            nonce: typeof Schema.String;
            authorPublicKey: typeof Schema.String;
        }>>;
    }>>;
}>;
export type RequestConnectAddAppIdentityToSpaces = Schema.Schema.Type<typeof RequestConnectAddAppIdentityToSpaces>;
export type RequestCreateInvitationEvent = Schema.Schema.Type<typeof RequestCreateInvitationEvent>;
export declare const RequestAcceptInvitationEvent: Schema.Struct<{
    type: Schema.Literal<["accept-invitation-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            id: typeof Schema.String;
            type: Schema.Literal<["accept-invitation"]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
}>;
export type RequestAcceptInvitationEvent = Schema.Schema.Type<typeof RequestAcceptInvitationEvent>;
export declare const RequestSubscribeToSpace: Schema.Struct<{
    type: Schema.Literal<["subscribe-space"]>;
    id: typeof Schema.String;
    lastKnownUpdateClock: Schema.optional<typeof Schema.Number>;
}>;
export type RequestSubscribeToSpace = Schema.Schema.Type<typeof RequestSubscribeToSpace>;
export declare const RequestListSpaces: Schema.Struct<{
    type: Schema.Literal<["list-spaces"]>;
}>;
export type RequestListSpaces = Schema.Schema.Type<typeof RequestListSpaces>;
export declare const RequestListInvitations: Schema.Struct<{
    type: Schema.Literal<["list-invitations"]>;
}>;
export type RequestListInvitations = Schema.Schema.Type<typeof RequestListInvitations>;
export declare const RequestCreateUpdate: Schema.Struct<{
    type: Schema.Literal<["create-update"]>;
    accountAddress: typeof Schema.String;
    update: typeof Schema.Uint8Array;
    spaceId: typeof Schema.String;
    updateId: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>;
export declare const RequestCreateAccountInbox: Schema.Struct<{
    type: Schema.Literal<["create-account-inbox"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    encryptionPublicKey: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>;
export type RequestCreateAccountInbox = Schema.Schema.Type<typeof RequestCreateAccountInbox>;
export declare const RequestCreateSpaceInboxEvent: Schema.Struct<{
    type: Schema.Literal<["create-space-inbox-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
}>;
export type RequestCreateSpaceInboxEvent = Schema.Schema.Type<typeof RequestCreateSpaceInboxEvent>;
export declare const RequestGetLatestSpaceInboxMessages: Schema.Struct<{
    type: Schema.Literal<["get-latest-space-inbox-messages"]>;
    spaceId: typeof Schema.String;
    inboxId: typeof Schema.String;
    since: typeof Schema.Date;
}>;
export type RequestGetLatestSpaceInboxMessages = Schema.Schema.Type<typeof RequestGetLatestSpaceInboxMessages>;
export declare const RequestGetLatestAccountInboxMessages: Schema.Struct<{
    type: Schema.Literal<["get-latest-account-inbox-messages"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    since: typeof Schema.Date;
}>;
export type RequestGetLatestAccountInboxMessages = Schema.Schema.Type<typeof RequestGetLatestAccountInboxMessages>;
export declare const RequestGetAccountInboxes: Schema.Struct<{
    type: Schema.Literal<["get-account-inboxes"]>;
}>;
export type RequestGetAccountInboxes = Schema.Schema.Type<typeof RequestGetAccountInboxes>;
export declare const RequestMessage: Schema.Union<[Schema.Struct<{
    type: Schema.Literal<["create-space-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
    keyBox: Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>;
    name: typeof Schema.String;
}>, Schema.Struct<{
    type: Schema.Literal<["create-invitation-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-invitation"]>;
            id: typeof Schema.String;
            inviteeAccountAddress: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
    keyBoxes: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>>;
}>, Schema.Struct<{
    type: Schema.Literal<["accept-invitation-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            id: typeof Schema.String;
            type: Schema.Literal<["accept-invitation"]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["subscribe-space"]>;
    id: typeof Schema.String;
    lastKnownUpdateClock: Schema.optional<typeof Schema.Number>;
}>, Schema.Struct<{
    type: Schema.Literal<["list-spaces"]>;
}>, Schema.Struct<{
    type: Schema.Literal<["list-invitations"]>;
}>, Schema.Struct<{
    type: Schema.Literal<["create-update"]>;
    accountAddress: typeof Schema.String;
    update: typeof Schema.Uint8Array;
    spaceId: typeof Schema.String;
    updateId: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["create-account-inbox"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    encryptionPublicKey: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["create-space-inbox-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["get-latest-space-inbox-messages"]>;
    spaceId: typeof Schema.String;
    inboxId: typeof Schema.String;
    since: typeof Schema.Date;
}>, Schema.Struct<{
    type: Schema.Literal<["get-latest-account-inbox-messages"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    since: typeof Schema.Date;
}>, Schema.Struct<{
    type: Schema.Literal<["get-account-inboxes"]>;
}>]>;
export type RequestMessage = Schema.Schema.Type<typeof RequestMessage>;
export type RequestCreateUpdate = Schema.Schema.Type<typeof RequestCreateUpdate>;
export declare const RequestLoginNonce: Schema.Struct<{
    accountAddress: typeof Schema.String;
}>;
export type RequestLoginNonce = Schema.Schema.Type<typeof RequestLoginNonce>;
export declare const RequestLogin: Schema.Struct<{
    accountAddress: typeof Schema.String;
    message: typeof Schema.String;
    signature: typeof Schema.String;
}>;
export type RequestLogin = Schema.Schema.Type<typeof RequestLogin>;
export declare const RequestLoginWithSigningKey: Schema.Struct<{
    accountAddress: typeof Schema.String;
    message: typeof Schema.String;
    publicKey: typeof Schema.String;
    signature: typeof Schema.String;
}>;
export type RequestLoginWithSigningKey = Schema.Schema.Type<typeof RequestLoginWithSigningKey>;
export declare const RequestCreateIdentity: Schema.Struct<{
    keyBox: Schema.Struct<{
        signer: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
    }>;
    accountProof: typeof Schema.String;
    keyProof: typeof Schema.String;
    message: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    signature: typeof Schema.String;
}>;
export type RequestCreateIdentity = Schema.Schema.Type<typeof RequestCreateIdentity>;
export declare const RequestConnectCreateIdentity: Schema.Struct<{
    keyBox: Schema.Struct<{
        signer: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
    }>;
    accountProof: typeof Schema.String;
    keyProof: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
}>;
export type RequestConnectCreateIdentity = Schema.Schema.Type<typeof RequestConnectCreateIdentity>;
export declare const RequestConnectCreateAppIdentity: Schema.Struct<{
    appId: typeof Schema.String;
    address: typeof Schema.String;
    accountAddress: typeof Schema.String;
    ciphertext: typeof Schema.String;
    nonce: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    accountProof: typeof Schema.String;
    keyProof: typeof Schema.String;
}>;
export type RequestConnectCreateAppIdentity = Schema.Schema.Type<typeof RequestConnectCreateAppIdentity>;
export declare const ResponseConnectCreateIdentity: Schema.Struct<{
    success: typeof Schema.Boolean;
}>;
export type ResponseConnectCreateIdentity = Schema.Schema.Type<typeof ResponseConnectCreateIdentity>;
export declare const RequestCreateSpaceInboxMessage: Schema.Struct<{
    ciphertext: typeof Schema.String;
    signature: Schema.optional<Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>>;
    authorAccountAddress: Schema.optional<typeof Schema.String>;
}>;
export type RequestCreateSpaceInboxMessage = Schema.Schema.Type<typeof RequestCreateSpaceInboxMessage>;
export declare const RequestCreateAccountInboxMessage: Schema.Struct<{
    ciphertext: typeof Schema.String;
    signature: Schema.optional<Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>>;
    authorAccountAddress: Schema.optional<typeof Schema.String>;
}>;
export type RequestCreateAccountInboxMessage = Schema.Schema.Type<typeof RequestCreateAccountInboxMessage>;
export declare const ResponseListSpaces: Schema.Struct<{
    type: Schema.Literal<["list-spaces"]>;
    spaces: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        name: typeof Schema.String;
    }>>;
}>;
export type ResponseListSpaces = Schema.Schema.Type<typeof ResponseListSpaces>;
export declare const Invitation: Schema.Struct<{
    id: typeof Schema.String;
    previousEventHash: typeof Schema.String;
    spaceId: typeof Schema.String;
}>;
export type Invitation = Schema.Schema.Type<typeof Invitation>;
export declare const ResponseListInvitations: Schema.Struct<{
    type: Schema.Literal<["list-invitations"]>;
    invitations: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        previousEventHash: typeof Schema.String;
        spaceId: typeof Schema.String;
    }>>;
}>;
export type ResponseListInvitations = Schema.Schema.Type<typeof ResponseListInvitations>;
export declare const ResponseSpaceEvent: Schema.Struct<{
    type: Schema.Literal<["space-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Union<[Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["delete-space"]>;
            id: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-invitation"]>;
            id: typeof Schema.String;
            inviteeAccountAddress: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            id: typeof Schema.String;
            type: Schema.Literal<["accept-invitation"]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>]>;
}>;
export type ResponseSpaceEvent = Schema.Schema.Type<typeof ResponseSpaceEvent>;
export declare const InboxMessage: Schema.Struct<{
    id: typeof Schema.String;
    ciphertext: typeof Schema.String;
    signature: Schema.optional<Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>>;
    authorAccountAddress: Schema.optional<typeof Schema.String>;
    createdAt: typeof Schema.Date;
}>;
export type InboxMessage = Schema.Schema.Type<typeof InboxMessage>;
export declare const SpaceInbox: Schema.Struct<{
    inboxId: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    encryptionPublicKey: typeof Schema.String;
    secretKey: typeof Schema.String;
}>;
export type SpaceInbox = Schema.Schema.Type<typeof SpaceInbox>;
export declare const AccountInbox: Schema.Struct<{
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    encryptionPublicKey: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>;
export type AccountInbox = Schema.Schema.Type<typeof AccountInbox>;
export declare const ResponseAccountInbox: Schema.Struct<{
    type: Schema.Literal<["account-inbox"]>;
    inbox: Schema.Struct<{
        accountAddress: typeof Schema.String;
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type ResponseAccountInbox = Schema.Schema.Type<typeof ResponseAccountInbox>;
export declare const ResponseSpace: Schema.Struct<{
    type: Schema.Literal<["space"]>;
    id: typeof Schema.String;
    name: typeof Schema.String;
    events: Schema.Array$<Schema.Union<[Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["delete-space"]>;
            id: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-invitation"]>;
            id: typeof Schema.String;
            inviteeAccountAddress: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            id: typeof Schema.String;
            type: Schema.Literal<["accept-invitation"]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>]>>;
    keyBoxes: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>>;
    updates: Schema.optional<Schema.Struct<{
        updates: Schema.Array$<Schema.Struct<{
            update: typeof Schema.Uint8Array;
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
            updateId: typeof Schema.String;
        }>>;
        firstUpdateClock: typeof Schema.Number;
        lastUpdateClock: typeof Schema.Number;
    }>>;
    inboxes: Schema.Array$<Schema.Struct<{
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        secretKey: typeof Schema.String;
    }>>;
}>;
export type ResponseSpace = Schema.Schema.Type<typeof ResponseSpace>;
export declare const ResponseUpdateConfirmed: Schema.Struct<{
    type: Schema.Literal<["update-confirmed"]>;
    updateId: typeof Schema.String;
    clock: typeof Schema.Number;
    spaceId: typeof Schema.String;
}>;
export type ResponseUpdateConfirmed = Schema.Schema.Type<typeof ResponseUpdateConfirmed>;
export declare const ResponseUpdatesNotification: Schema.Struct<{
    type: Schema.Literal<["updates-notification"]>;
    updates: Schema.Struct<{
        updates: Schema.Array$<Schema.Struct<{
            update: typeof Schema.Uint8Array;
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
            updateId: typeof Schema.String;
        }>>;
        firstUpdateClock: typeof Schema.Number;
        lastUpdateClock: typeof Schema.Number;
    }>;
    spaceId: typeof Schema.String;
}>;
export type ResponseUpdatesNotification = Schema.Schema.Type<typeof ResponseUpdatesNotification>;
export declare const ResponseSpaceInboxMessage: Schema.Struct<{
    type: Schema.Literal<["space-inbox-message"]>;
    spaceId: typeof Schema.String;
    inboxId: typeof Schema.String;
    message: Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>;
}>;
export type ResponseSpaceInboxMessage = Schema.Schema.Type<typeof ResponseSpaceInboxMessage>;
export declare const ResponseSpaceInboxMessages: Schema.Struct<{
    type: Schema.Literal<["space-inbox-messages"]>;
    spaceId: typeof Schema.String;
    inboxId: typeof Schema.String;
    messages: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>>;
}>;
export type ResponseSpaceInboxMessages = Schema.Schema.Type<typeof ResponseSpaceInboxMessages>;
export declare const ResponseAccountInboxMessage: Schema.Struct<{
    type: Schema.Literal<["account-inbox-message"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    message: Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>;
}>;
export type ResponseAccountInboxMessage = Schema.Schema.Type<typeof ResponseAccountInboxMessage>;
export declare const ResponseAccountInboxMessages: Schema.Struct<{
    type: Schema.Literal<["account-inbox-messages"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    messages: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>>;
}>;
export type ResponseAccountInboxMessages = Schema.Schema.Type<typeof ResponseAccountInboxMessages>;
export declare const ResponseAccountInboxes: Schema.Struct<{
    type: Schema.Literal<["account-inboxes"]>;
    inboxes: Schema.Array$<Schema.Struct<{
        accountAddress: typeof Schema.String;
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>>;
}>;
export type ResponseAccountInboxes = Schema.Schema.Type<typeof ResponseAccountInboxes>;
export declare const ResponseMessage: Schema.Union<[Schema.Struct<{
    type: Schema.Literal<["list-spaces"]>;
    spaces: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        name: typeof Schema.String;
    }>>;
}>, Schema.Struct<{
    type: Schema.Literal<["list-invitations"]>;
    invitations: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        previousEventHash: typeof Schema.String;
        spaceId: typeof Schema.String;
    }>>;
}>, Schema.Struct<{
    type: Schema.Literal<["space"]>;
    id: typeof Schema.String;
    name: typeof Schema.String;
    events: Schema.Array$<Schema.Union<[Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["delete-space"]>;
            id: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-invitation"]>;
            id: typeof Schema.String;
            inviteeAccountAddress: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            id: typeof Schema.String;
            type: Schema.Literal<["accept-invitation"]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>]>>;
    keyBoxes: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
        authorPublicKey: typeof Schema.String;
    }>>;
    updates: Schema.optional<Schema.Struct<{
        updates: Schema.Array$<Schema.Struct<{
            update: typeof Schema.Uint8Array;
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
            updateId: typeof Schema.String;
        }>>;
        firstUpdateClock: typeof Schema.Number;
        lastUpdateClock: typeof Schema.Number;
    }>>;
    inboxes: Schema.Array$<Schema.Struct<{
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        secretKey: typeof Schema.String;
    }>>;
}>, Schema.Struct<{
    type: Schema.Literal<["space-event"]>;
    spaceId: typeof Schema.String;
    event: Schema.Union<[Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space"]>;
            id: typeof Schema.String;
            creatorAccountAddress: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["delete-space"]>;
            id: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-invitation"]>;
            id: typeof Schema.String;
            inviteeAccountAddress: typeof Schema.String;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            id: typeof Schema.String;
            type: Schema.Literal<["accept-invitation"]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>, Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>]>;
}>, Schema.Struct<{
    type: Schema.Literal<["update-confirmed"]>;
    updateId: typeof Schema.String;
    clock: typeof Schema.Number;
    spaceId: typeof Schema.String;
}>, Schema.Struct<{
    type: Schema.Literal<["updates-notification"]>;
    updates: Schema.Struct<{
        updates: Schema.Array$<Schema.Struct<{
            update: typeof Schema.Uint8Array;
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
            updateId: typeof Schema.String;
        }>>;
        firstUpdateClock: typeof Schema.Number;
        lastUpdateClock: typeof Schema.Number;
    }>;
    spaceId: typeof Schema.String;
}>, Schema.Struct<{
    type: Schema.Literal<["account-inbox"]>;
    inbox: Schema.Struct<{
        accountAddress: typeof Schema.String;
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["space-inbox-message"]>;
    spaceId: typeof Schema.String;
    inboxId: typeof Schema.String;
    message: Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["space-inbox-messages"]>;
    spaceId: typeof Schema.String;
    inboxId: typeof Schema.String;
    messages: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>>;
}>, Schema.Struct<{
    type: Schema.Literal<["account-inbox-message"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    message: Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>;
}>, Schema.Struct<{
    type: Schema.Literal<["account-inbox-messages"]>;
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    messages: Schema.Array$<Schema.Struct<{
        id: typeof Schema.String;
        ciphertext: typeof Schema.String;
        signature: Schema.optional<Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>>;
        authorAccountAddress: Schema.optional<typeof Schema.String>;
        createdAt: typeof Schema.Date;
    }>>;
}>, Schema.Struct<{
    type: Schema.Literal<["account-inboxes"]>;
    inboxes: Schema.Array$<Schema.Struct<{
        accountAddress: typeof Schema.String;
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>>;
}>]>;
export type ResponseMessage = Schema.Schema.Type<typeof ResponseMessage>;
export declare const ResponseIdentityEncrypted: Schema.Struct<{
    keyBox: Schema.Struct<{
        signer: typeof Schema.String;
        accountAddress: typeof Schema.String;
        ciphertext: typeof Schema.String;
        nonce: typeof Schema.String;
    }>;
}>;
export type ResponseIdentityEncrypted = Schema.Schema.Type<typeof ResponseIdentityEncrypted>;
export declare const ResponseIdentity: Schema.Struct<{
    accountAddress: typeof Schema.String;
    signaturePublicKey: typeof Schema.String;
    encryptionPublicKey: typeof Schema.String;
    accountProof: typeof Schema.String;
    keyProof: typeof Schema.String;
}>;
export type ResponseIdentity = Schema.Schema.Type<typeof ResponseIdentity>;
export declare const SpaceInboxPublic: Schema.Struct<{
    inboxId: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    encryptionPublicKey: typeof Schema.String;
    creationEvent: Schema.Struct<{
        transaction: Schema.Struct<{
            type: Schema.Literal<["create-space-inbox"]>;
            id: typeof Schema.String;
            spaceId: typeof Schema.String;
            inboxId: typeof Schema.String;
            encryptionPublicKey: typeof Schema.String;
            secretKey: typeof Schema.String;
            isPublic: typeof Schema.Boolean;
            authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
            previousEventHash: typeof Schema.String;
        }>;
        author: Schema.Struct<{
            accountAddress: typeof Schema.String;
            signature: Schema.Struct<{
                hex: typeof Schema.String;
                recovery: typeof Schema.Number;
            }>;
        }>;
    }>;
}>;
export type SpaceInboxPublic = Schema.Schema.Type<typeof SpaceInboxPublic>;
export declare const ResponseSpaceInboxPublic: Schema.Struct<{
    inbox: Schema.Struct<{
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        creationEvent: Schema.Struct<{
            transaction: Schema.Struct<{
                type: Schema.Literal<["create-space-inbox"]>;
                id: typeof Schema.String;
                spaceId: typeof Schema.String;
                inboxId: typeof Schema.String;
                encryptionPublicKey: typeof Schema.String;
                secretKey: typeof Schema.String;
                isPublic: typeof Schema.Boolean;
                authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
                previousEventHash: typeof Schema.String;
            }>;
            author: Schema.Struct<{
                accountAddress: typeof Schema.String;
                signature: Schema.Struct<{
                    hex: typeof Schema.String;
                    recovery: typeof Schema.Number;
                }>;
            }>;
        }>;
    }>;
}>;
export type ResponseSpaceInboxPublic = Schema.Schema.Type<typeof ResponseSpaceInboxPublic>;
export declare const ResponseListSpaceInboxesPublic: Schema.Struct<{
    inboxes: Schema.Array$<Schema.Struct<{
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        creationEvent: Schema.Struct<{
            transaction: Schema.Struct<{
                type: Schema.Literal<["create-space-inbox"]>;
                id: typeof Schema.String;
                spaceId: typeof Schema.String;
                inboxId: typeof Schema.String;
                encryptionPublicKey: typeof Schema.String;
                secretKey: typeof Schema.String;
                isPublic: typeof Schema.Boolean;
                authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
                previousEventHash: typeof Schema.String;
            }>;
            author: Schema.Struct<{
                accountAddress: typeof Schema.String;
                signature: Schema.Struct<{
                    hex: typeof Schema.String;
                    recovery: typeof Schema.Number;
                }>;
            }>;
        }>;
    }>>;
}>;
export type ResponseListSpaceInboxesPublic = Schema.Schema.Type<typeof ResponseListSpaceInboxesPublic>;
export declare const AccountInboxPublic: Schema.Struct<{
    accountAddress: typeof Schema.String;
    inboxId: typeof Schema.String;
    isPublic: typeof Schema.Boolean;
    authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
    encryptionPublicKey: typeof Schema.String;
    signature: Schema.Struct<{
        hex: typeof Schema.String;
        recovery: typeof Schema.Number;
    }>;
}>;
export type AccountInboxPublic = Schema.Schema.Type<typeof AccountInboxPublic>;
export declare const ResponseAccountInboxPublic: Schema.Struct<{
    inbox: Schema.Struct<{
        accountAddress: typeof Schema.String;
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>;
}>;
export type ResponseAccountInboxPublic = Schema.Schema.Type<typeof ResponseAccountInboxPublic>;
export declare const ResponseListAccountInboxesPublic: Schema.Struct<{
    inboxes: Schema.Array$<Schema.Struct<{
        accountAddress: typeof Schema.String;
        inboxId: typeof Schema.String;
        isPublic: typeof Schema.Boolean;
        authPolicy: Schema.Union<[Schema.Literal<["anonymous"]>, Schema.Literal<["optional_auth"]>, Schema.Literal<["requires_auth"]>]>;
        encryptionPublicKey: typeof Schema.String;
        signature: Schema.Struct<{
            hex: typeof Schema.String;
            recovery: typeof Schema.Number;
        }>;
    }>>;
}>;
export type ResponseListAccountInboxesPublic = Schema.Schema.Type<typeof ResponseListAccountInboxesPublic>;
export declare const ResponseIdentityNotFoundError: Schema.Struct<{
    accountAddress: typeof Schema.String;
}>;
export type ResponseIdentityNotFoundError = Schema.Schema.Type<typeof ResponseIdentityNotFoundError>;
export declare const ResponseIdentityExistsError: Schema.Struct<{
    accountAddress: typeof Schema.String;
}>;
export type ResponseIdentityExistsError = Schema.Schema.Type<typeof ResponseIdentityExistsError>;
//# sourceMappingURL=types.d.ts.map