'use client';

import { jsx as _jsx } from "react/jsx-runtime";
import { Entity, store } from '@graphprotocol/hypergraph';
import { useSelector } from '@xstate/store/react';
import * as Schema from 'effect/Schema';
import { createContext, useContext, useEffect, useLayoutEffect, useMemo, useRef, useSyncExternalStore } from 'react';
import { useHypergraphApp } from './HypergraphAppContext.js';
import { usePublicSpace } from './internal/use-public-space.js';
export const HypergraphReactContext = /*#__PURE__*/createContext(undefined);
export function useHypergraphSpaceInternal() {
  const context = useContext(HypergraphReactContext);
  return context || {
    space: ''
  };
}
export function HypergraphSpaceProvider({
  space,
  children
}) {
  return _jsx(HypergraphReactContext.Provider, {
    value: {
      space
    },
    children: children
  });
}
const subscribeToSpaceCache = /*#__PURE__*/new Map();
function useSubscribeToSpaceAndGetHandle({
  spaceId,
  enabled
}) {
  const handle = useSelector(store, state => {
    const space = state.context.spaces.find(space => space.id === spaceId);
    if (!space) {
      return undefined;
    }
    return space.automergeDocHandle;
  });
  const {
    subscribeToSpace,
    isConnecting
  } = useHypergraphApp();
  useEffect(() => {
    if (!isConnecting && enabled) {
      if (subscribeToSpaceCache.has(spaceId)) {
        return;
      }
      subscribeToSpaceCache.set(spaceId, true);
      subscribeToSpace({
        spaceId
      });
    }
    return () => {
      // TODO: unsubscribe from space in case the space ID changes
      subscribeToSpaceCache.delete(spaceId);
    };
  }, [isConnecting, subscribeToSpace, spaceId, enabled]);
  return handle;
}
export function useSpace(options) {
  const {
    space: spaceIdFromContext
  } = useHypergraphSpaceInternal();
  const {
    space: spaceIdFromParams
  } = options ?? {};
  const spaceId = spaceIdFromParams ?? spaceIdFromContext;
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId,
    enabled: options.mode === 'private'
  });
  const ready = options.mode === 'public' ? true : handle ? handle.isReady() : false;
  const privateSpace = useSelector(store, state => state.context.spaces.find(space => space.id === spaceId));
  const publicSpace = usePublicSpace({
    spaceId,
    enabled: options.mode === 'public'
  });
  return {
    ready,
    name: options.mode === 'private' ? privateSpace?.name : publicSpace?.name,
    id: spaceId
  };
}
export function useCreateEntity(type, options) {
  const {
    space: spaceIdFromParams
  } = options ?? {};
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const spaceId = spaceIdFromParams ?? spaceFromContext;
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId,
    enabled: true
  });
  if (!handle) {
    return () => {
      throw new Error('Space not found or not ready');
    };
  }
  return Entity.create(handle, type);
}
export function useUpdateEntity(type, options) {
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const {
    space
  } = options ?? {};
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId: space ?? spaceFromContext,
    enabled: true
  });
  if (!handle) {
    return () => {
      throw new Error('Space not found or not ready');
    };
  }
  return Entity.update(handle, type);
}
export function useDeleteEntity(options) {
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const {
    space
  } = options ?? {};
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId: space ?? spaceFromContext,
    enabled: true
  });
  if (!handle) {
    return () => {
      throw new Error('Space not found or not ready');
    };
  }
  return Entity.markAsDeleted(handle);
}
export function useRemoveRelation(options) {
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const {
    space
  } = options ?? {};
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId: space ?? spaceFromContext,
    enabled: true
  });
  if (!handle) {
    return () => {
      throw new Error('Space not found or not ready');
    };
  }
  return Entity.removeRelation(handle);
}
export function useHardDeleteEntity(options) {
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const {
    space
  } = options ?? {};
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId: space ?? spaceFromContext,
    enabled: true
  });
  if (!handle) {
    return () => {
      throw new Error('Space not found or not ready');
    };
  }
  return Entity.delete(handle);
}
export function useQueryLocal(type, params) {
  const {
    enabled = true,
    filter,
    include,
    space: spaceFromParams
  } = params ?? {};
  const entitiesRef = useRef([]);
  const subscriptionRef = useRef({
    subscribe: () => () => undefined,
    getEntities: () => entitiesRef.current
  });
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId: spaceFromParams ?? spaceFromContext,
    enabled
  });
  const handleIsReady = handle ? handle.isReady() : false;
  // biome-ignore lint/correctness/useExhaustiveDependencies: allow to change filter and include
  useLayoutEffect(() => {
    if (enabled && handle && handleIsReady) {
      const subscription = Entity.subscribeToFindMany(handle, type, filter, include);
      subscriptionRef.current.subscribe = subscription.subscribe;
      subscriptionRef.current.getEntities = subscription.getEntities;
    }
  }, [enabled, handleIsReady, handle, type]);
  // TODO: allow to change the enabled state
  const allEntities = useSyncExternalStore(subscriptionRef.current.subscribe, subscriptionRef.current.getEntities, () => entitiesRef.current);
  const {
    entities,
    deletedEntities
  } = useMemo(() => {
    const entities = [];
    const deletedEntities = [];
    for (const entity of allEntities) {
      if (entity.__deleted === true) {
        deletedEntities.push(entity);
      } else {
        entities.push(entity);
      }
    }
    return {
      entities,
      deletedEntities
    };
  }, [allEntities]);
  return {
    entities,
    deletedEntities
  };
}
export function useQueryEntity(type, id, params) {
  const {
    space: spaceFromContext
  } = useHypergraphSpaceInternal();
  const {
    space: spaceFromParams,
    include
  } = params ?? {};
  const handle = useSubscribeToSpaceAndGetHandle({
    spaceId: spaceFromParams ?? spaceFromContext,
    enabled: true
  });
  const prevEntityRef = useRef(undefined);
  const equals = Schema.equivalence(type);
  const subscribe = callback => {
    if (!handle) {
      return () => {};
    }
    const handleChange = () => {
      callback();
    };
    const handleDelete = () => {
      callback();
    };
    handle.on('change', handleChange);
    handle.on('delete', handleDelete);
    return () => {
      handle.off('change', handleChange);
      handle.off('delete', handleDelete);
    };
  };
  return useSyncExternalStore(subscribe, () => {
    if (!handle) {
      return prevEntityRef.current;
    }
    const doc = handle.doc();
    if (doc === undefined) {
      return prevEntityRef.current;
    }
    const found = Entity.findOne(handle, type, include)(id);
    if (found === undefined && prevEntityRef.current !== undefined) {
      // entity was maybe deleted, delete from the ref
      prevEntityRef.current = undefined;
    } else if (found !== undefined && prevEntityRef.current === undefined) {
      prevEntityRef.current = found;
    } else if (found !== undefined && prevEntityRef.current !== undefined && !equals(found, prevEntityRef.current)) {
      // found and ref have a value, compare for equality, if they are not equal, update the ref and return
      prevEntityRef.current = found;
    }
    return prevEntityRef.current;
  });
}
//# sourceMappingURL=HypergraphSpaceContext.js.map