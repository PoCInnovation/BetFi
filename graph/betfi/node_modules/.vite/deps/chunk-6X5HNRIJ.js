import {
  Brand_exports,
  Micro_exports,
  createPimlicoClient,
  createPublicClient,
  createSmartAccountClient,
  createWalletClient,
  entryPoint07Address,
  http,
  parse_default,
  privateKeyToAccount,
  stringify_default,
  toSafeSmartAccount,
  v4_default,
  validate_default
} from "./chunk-UMZOSOLW.js";
import {
  encodeFunctionData,
  getAddress,
  stringToHex
} from "./chunk-6CZFMNNW.js";
import {
  __export,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/@graphprotocol/grc-20/dist/src/types.js
var VoteOption;
(function(VoteOption2) {
  VoteOption2[VoteOption2["None"] = 0] = "None";
  VoteOption2[VoteOption2["Abstain"] = 1] = "Abstain";
  VoteOption2[VoteOption2["Yes"] = 2] = "Yes";
  VoteOption2[VoteOption2["No"] = 3] = "No";
})(VoteOption || (VoteOption = {}));

// node_modules/@graphprotocol/grc-20/dist/src/id.js
var id_exports = {};
__export(id_exports, {
  Id: () => Id,
  IdBase64: () => IdBase64,
  assertValid: () => assertValid,
  fromBase64: () => fromBase64,
  fromBytes: () => fromBytes,
  generate: () => generate,
  isValid: () => isValid,
  isValidBase64: () => isValidBase64,
  toBase64: () => toBase64,
  toBytes: () => toBytes
});
var Id = Brand_exports.refined((id) => isValid(id), (id) => Brand_exports.error(`Expected ${id} to be a valid Id`));
var IdBase64 = Brand_exports.refined((id) => isValidBase64(id), (id) => Brand_exports.error(`Expected ${id} to be a valid IdBase64`));
function generate() {
  const uuid = v4_default();
  return Id(uuid);
}
function isValid(id) {
  return validate_default(id);
}
function isValidBase64(id) {
  try {
    const uuid = fromBase64(id);
    return isValid(uuid);
  } catch (error) {
    return false;
  }
}
function assertValid(id, sourceHint) {
  if (!isValid(id)) {
    throw new Error(`Invalid id: "${id}"${sourceHint ? ` for ${sourceHint}` : ""}`);
  }
}
function toBytes(id) {
  return parse_default(id);
}
function fromBytes(bytes) {
  return Id(stringify_default(bytes));
}
var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function toBase64(id) {
  const bytes = toBytes(id);
  let result = "";
  let i;
  for (i = 0; i < bytes.length; i += 3) {
    const a = bytes[i];
    const b = bytes[i + 1] ?? 0;
    const c = bytes[i + 2] ?? 0;
    const triple = a << 16 | b << 8 | c;
    result += base64Chars[triple >> 18 & 63];
    result += base64Chars[triple >> 12 & 63];
    result += i + 1 < bytes.length ? base64Chars[triple >> 6 & 63] : "=";
    result += i + 2 < bytes.length ? base64Chars[triple & 63] : "=";
  }
  return IdBase64(result);
}
function fromBase64(id) {
  const bytes = [];
  for (let i = 0; i < id.length; i += 4) {
    const c1 = base64Chars.indexOf(id[i]);
    const c2 = base64Chars.indexOf(id[i + 1]);
    const c3 = base64Chars.indexOf(id[i + 2]);
    const c4 = base64Chars.indexOf(id[i + 3]);
    const triple = c1 << 18 | c2 << 12 | (c3 & 63) << 6 | c4 & 63;
    bytes.push(triple >> 16 & 255);
    if (c3 !== -1 && c3 !== 64)
      bytes.push(triple >> 8 & 255);
    if (c4 !== -1 && c4 !== 64)
      bytes.push(triple & 255);
  }
  return fromBytes(new Uint8Array(bytes));
}

// node_modules/@graphprotocol/grc-20/dist/src/abis/space.js
var abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "AdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beacon",
        type: "address"
      }
    ],
    name: "BeaconUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "contentUri",
        type: "string"
      }
    ],
    name: "EditsPublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "subspaceDao",
        type: "address"
      }
    ],
    name: "SubspaceAccepted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "subspaceDao",
        type: "address"
      }
    ],
    name: "SubspaceRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "predecessorSpace",
        type: "address"
      }
    ],
    name: "SuccessorSpaceCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "UPGRADE_PLUGIN_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_subspaceDao",
        type: "address"
      }
    ],
    name: "acceptSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        internalType: "string",
        name: "_firstContentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_predecessorSpace",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_contentUri",
        type: "string"
      }
    ],
    name: "publishEdits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_subspaceDao",
        type: "address"
      }
    ],
    name: "removeSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "upgradeTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@graphprotocol/grc-20/dist/src/abis/main-voting.js
var abi2 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "AlreadyAMember",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "AlreadyAnEditor",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "AlreadyNotAMember",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "AlreadyNotAnEditor",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "limit",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "actual",
        type: "uint64"
      }
    ],
    name: "DateOutOfBounds",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "limit",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "actual",
        type: "uint64"
      }
    ],
    name: "DurationOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "EmptyContent",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "InvalidAddresslistUpdate",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "InvalidInterface",
    type: "error"
  },
  {
    inputs: [],
    name: "NoEditorsLeft",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "NotAMember",
    type: "error"
  },
  {
    inputs: [],
    name: "NotAnEditor",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyCreatorCanCancel",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "OnlyOneEditorPerCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ProposalCreationForbidden",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecutionForbidden",
    type: "error"
  },
  {
    inputs: [],
    name: "ProposalIsNotOpen",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "limit",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "actual",
        type: "uint256"
      }
    ],
    name: "RatioOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "voteOption",
        type: "uint8"
      }
    ],
    name: "VoteCastForbidden",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "subspace",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "AcceptSubspaceProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "editor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "AddEditorProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "AdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beacon",
        type: "address"
      }
    ],
    name: "BeaconUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "editors",
        type: "address[]"
      }
    ],
    name: "EditorsAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "string",
        name: "contentUri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "PublishEditsProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "editor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveEditorProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "member",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveMemberProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "subspace",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveSubspaceProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "voter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum IMajorityVoting.VoteOption",
        name: "voteOption",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "votingPower",
        type: "uint256"
      }
    ],
    name: "VoteCast",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "enum MajorityVotingBase.VotingMode",
        name: "votingMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "supportThreshold",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "duration",
        type: "uint64"
      }
    ],
    name: "VotingSettingsUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "UPDATE_ADDRESSES_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPDATE_VOTING_SETTINGS_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_PLUGIN_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "addEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "addMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "addresslistLength",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "addresslistLengthAtBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "canExecute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      }
    ],
    name: "canVote",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "cancelProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "_actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "_allowFailureMap",
        type: "uint256"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "_tryEarlyExecution",
        type: "bool"
      }
    ],
    name: "createProposal",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "duration",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "getProposal",
    outputs: [
      {
        internalType: "bool",
        name: "open",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "executed",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "startDate",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endDate",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "snapshotBlock",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.ProposalParameters",
        name: "parameters",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "abstain",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "yes",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "no",
            type: "uint256"
          }
        ],
        internalType: "struct MajorityVotingBase.Tally",
        name: "tally",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      }
    ],
    name: "getVoteOption",
    outputs: [
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "duration",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.VotingSettings",
        name: "_votingSettings",
        type: "tuple"
      },
      {
        internalType: "address[]",
        name: "_initialEditors",
        type: "address[]"
      },
      {
        internalType: "contract MemberAccessPlugin",
        name: "_memberAccessPlugin",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isEditor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isListed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "isListedAtBlock",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isMinParticipationReached",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isSupportThresholdReached",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isSupportThresholdReachedEarly",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpaceAsEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "memberAccessPlugin",
    outputs: [
      {
        internalType: "contract MemberAccessPlugin",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeAcceptSubspace",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_proposedEditor",
        type: "address"
      }
    ],
    name: "proposeAddEditor",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_proposedMember",
        type: "address"
      }
    ],
    name: "proposeAddMember",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "string",
        name: "_editsContentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeEdits",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "proposeRemoveEditor",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "proposeRemoveMember",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeRemoveSubspace",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "removeEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "removeMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "supportThreshold",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "totalVotingPower",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "duration",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.VotingSettings",
        name: "_votingSettings",
        type: "tuple"
      }
    ],
    name: "updateVotingSettings",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "upgradeTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "_tryEarlyExecution",
        type: "bool"
      }
    ],
    name: "vote",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "votingMode",
    outputs: [
      {
        internalType: "enum MajorityVotingBase.VotingMode",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@graphprotocol/grc-20/dist/src/abis/personal-space-admin.js
var abi3 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "NotAMember",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address[]",
        name: "editors",
        type: "address[]"
      }
    ],
    name: "EditorsAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "_actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "_allowFailureMap",
        type: "uint256"
      }
    ],
    name: "executeProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialEditor",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isEditor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitAcceptSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_contentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitEdits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newEditor",
        type: "address"
      }
    ],
    name: "submitNewEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newMember",
        type: "address"
      }
    ],
    name: "submitNewMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "submitRemoveEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "submitRemoveMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitRemoveSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-process-geo-proposal-arguments.js
function getProcessGeoProposalArguments(spacePluginAddress, ipfsUri) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: spacePluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi,
          functionName: "publishEdits",
          args: [ipfsUri]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-accept-subspace-arguments.js
function getAcceptSubspaceArguments({ spacePluginAddress, ipfsUri, subspaceToAccept }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: spacePluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi,
          functionName: "acceptSubspace",
          args: [subspaceToAccept]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-remove-subspace-arguments.js
function getRemoveSubspaceArguments({ spacePluginAddress, ipfsUri, subspaceToAccept }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: spacePluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi,
          functionName: "removeSubspace",
          args: [subspaceToAccept]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-accept-editor-arguments.js
function getAcceptEditorArguments({ votingPluginAddress, ipfsUri, editorAddress }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: votingPluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi2,
          functionName: "addEditor",
          args: [editorAddress]
        })
      }
    ],
    BigInt(0),
    VoteOption.None,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-remove-editor-arguments.js
function getRemoveEditorArguments({ votingPluginAddress, ipfsUri, editorAddress }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: votingPluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi2,
          functionName: "removeMember",
          args: [editorAddress]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-calldata-for-space-governance-type.js
function getCalldataForSpaceGovernanceType(args) {
  switch (args.type) {
    case "PUBLIC":
      return encodeFunctionData({
        functionName: "proposeEdits",
        abi: abi2,
        args: [stringToHex(args.cid), args.cid, args.spacePluginAddress]
      });
    case "PERSONAL":
      return encodeFunctionData({
        functionName: "submitEdits",
        abi: abi3,
        args: [args.cid, args.spacePluginAddress]
      });
  }
}

// node_modules/@graphprotocol/grc-20/dist/src/core/account.js
var account_exports = {};
__export(account_exports, {
  make: () => make
});

// node_modules/@graphprotocol/grc-20/dist/src/core/ids/system.js
var system_exports = {};
__export(system_exports, {
  ABOUT_PAGE: () => ABOUT_PAGE,
  ABOUT_PAGE_TEMPLATE: () => ABOUT_PAGE_TEMPLATE,
  ACADEMIC_FIELD_TEMPLATE: () => ACADEMIC_FIELD_TEMPLATE,
  ACADEMIC_FIELD_TYPE: () => ACADEMIC_FIELD_TYPE,
  ACCOUNTS_PROPERTY: () => ACCOUNTS_PROPERTY,
  ACCOUNT_TYPE: () => ACCOUNT_TYPE,
  ACTIVITIES_PAGE: () => ACTIVITIES_PAGE,
  ADDRESS_PROPERTY: () => ADDRESS_PROPERTY,
  ALL_OF_GEO_DATA_SOURCE: () => ALL_OF_GEO_DATA_SOURCE,
  BLOCKS: () => BLOCKS,
  BROADER_CLAIMS_PROPERTY: () => BROADER_CLAIMS_PROPERTY,
  BULLETED_LIST_VIEW: () => BULLETED_LIST_VIEW,
  CLAIMS_FROM_PROPERTY: () => CLAIMS_FROM_PROPERTY,
  COLLECTION_DATA_SOURCE: () => COLLECTION_DATA_SOURCE,
  COLLECTION_ITEM_RELATION_TYPE: () => COLLECTION_ITEM_RELATION_TYPE,
  COMPANY_TEMPLATE: () => COMPANY_TEMPLATE,
  COMPANY_TYPE: () => COMPANY_TYPE,
  COVER_PROPERTY: () => COVER_PROPERTY,
  CULTURE_PAGE: () => CULTURE_PAGE,
  CURRENCY_EUR_PROPERTY: () => CURRENCY_EUR_PROPERTY,
  CURRENCY_GBP_PROPERTY: () => CURRENCY_GBP_PROPERTY,
  CURRENCY_PROPERTY: () => CURRENCY_PROPERTY,
  CURRENCY_SIGN_PROPERTY: () => CURRENCY_SIGN_PROPERTY,
  CURRENCY_SYMBOL_PROPERTY: () => CURRENCY_SYMBOL_PROPERTY,
  CURRENCY_USD_PROPERTY: () => CURRENCY_USD_PROPERTY,
  DAO_TEMPLATE: () => DAO_TEMPLATE,
  DAO_TYPE: () => DAO_TYPE,
  DATA_BLOCK: () => DATA_BLOCK,
  DATA_SOURCE_PROPERTY: () => DATA_SOURCE_PROPERTY,
  DATA_SOURCE_TYPE_RELATION_TYPE: () => DATA_SOURCE_TYPE_RELATION_TYPE,
  DEFAULT_TYPE: () => DEFAULT_TYPE,
  DEFINITIONS_PROPERTY: () => DEFINITIONS_PROPERTY,
  DESCRIPTION_PROPERTY: () => DESCRIPTION_PROPERTY,
  EDUCATION_PAGE: () => EDUCATION_PAGE,
  EDUCATION_PAGE_TEMPLATE: () => EDUCATION_PAGE_TEMPLATE,
  EMAIL_PROPERTY: () => EMAIL_PROPERTY,
  ENTITY_FILTER: () => ENTITY_FILTER,
  ENTITY_ID_PROPERTY: () => ENTITY_ID_PROPERTY,
  EVENTS_PAGE: () => EVENTS_PAGE,
  FILTER: () => FILTER,
  FINANCES_PAGE: () => FINANCES_PAGE,
  FINANCE_OVERVIEW_TYPE: () => FINANCE_OVERVIEW_TYPE,
  FINANCE_SUMMMARY_TYPE: () => FINANCE_SUMMMARY_TYPE,
  FOREIGN_TYPES: () => FOREIGN_TYPES,
  GALLERY_VIEW: () => GALLERY_VIEW,
  GEO_LOCATION_PROPERTY: () => GEO_LOCATION_PROPERTY,
  GOALS_PROPERTY: () => GOALS_PROPERTY,
  GOAL_TYPE: () => GOAL_TYPE,
  GOVERNMENT_ORG_TYPE: () => GOVERNMENT_ORG_TYPE,
  GOVERNMENT_PAGE: () => GOVERNMENT_PAGE,
  IMAGE: () => IMAGE,
  IMAGE_BLOCK: () => IMAGE_BLOCK,
  IMAGE_FILE_TYPE_PROPERTY: () => IMAGE_FILE_TYPE_PROPERTY,
  IMAGE_HEIGHT_PROPERTY: () => IMAGE_HEIGHT_PROPERTY,
  IMAGE_TYPE: () => IMAGE_TYPE,
  IMAGE_URL_PROPERTY: () => IMAGE_URL_PROPERTY,
  IMAGE_WIDTH_PROPERTY: () => IMAGE_WIDTH_PROPERTY,
  INDUSTRY_TEMPLATE: () => INDUSTRY_TEMPLATE,
  INDUSTRY_TYPE: () => INDUSTRY_TYPE,
  INTEREST_TEMPLATE: () => INTEREST_TEMPLATE,
  INTEREST_TYPE: () => INTEREST_TYPE,
  JOBS_PAGE: () => JOBS_PAGE,
  LIST_VIEW: () => LIST_VIEW,
  MARKDOWN_CONTENT: () => MARKDOWN_CONTENT,
  MEMBERSHIP_CONTRACT_ADDRESS: () => MEMBERSHIP_CONTRACT_ADDRESS,
  MISSION_PROPERTY: () => MISSION_PROPERTY,
  NAME_PROPERTY: () => NAME_PROPERTY,
  NETWORK_PROPERTY: () => NETWORK_PROPERTY,
  NETWORK_TYPE: () => NETWORK_TYPE,
  NEWS_PAGE: () => NEWS_PAGE,
  NONPROFIT_CATEGORIES_PROPERTY: () => NONPROFIT_CATEGORIES_PROPERTY,
  NONPROFIT_TEMPLATE: () => NONPROFIT_TEMPLATE,
  NONPROFIT_TYPE: () => NONPROFIT_TYPE,
  ONTOLOGY_PAGE: () => ONTOLOGY_PAGE,
  ONTOLOGY_PAGE_TEMPLATE: () => ONTOLOGY_PAGE_TEMPLATE,
  PAGE_TYPE: () => PAGE_TYPE,
  PAGE_TYPE_PROPERTY: () => PAGE_TYPE_PROPERTY,
  PEOPLE_PAGE: () => PEOPLE_PAGE,
  PERSONAL_PAGE: () => PERSONAL_PAGE,
  PERSON_TEMPLATE: () => PERSON_TEMPLATE,
  PERSON_TYPE: () => PERSON_TYPE,
  PHONE_NUMBER_PROPERTY: () => PHONE_NUMBER_PROPERTY,
  PLACEHOLDER_IMAGE: () => PLACEHOLDER_IMAGE,
  PLACEHOLDER_TEXT: () => PLACEHOLDER_TEXT,
  PLACES_PAGE: () => PLACES_PAGE,
  POSTS_PAGE: () => POSTS_PAGE,
  POST_TYPE: () => POST_TYPE,
  PRODUCTS_PAGE: () => PRODUCTS_PAGE,
  PROFESSIONAL_PAGE: () => PROFESSIONAL_PAGE,
  PROJECTS_PAGE: () => PROJECTS_PAGE,
  PROJECT_TYPE: () => PROJECT_TYPE,
  PROPERTIES: () => PROPERTIES,
  PROPERTY: () => PROPERTY,
  PROTOCOL_TEMPLATE: () => PROTOCOL_TEMPLATE,
  PROTOCOL_TYPE: () => PROTOCOL_TYPE,
  QUERY_DATA_SOURCE: () => QUERY_DATA_SOURCE,
  QUOTES_PROPERTY: () => QUOTES_PROPERTY,
  REGION_PROPERTY: () => REGION_PROPERTY,
  REGION_TEMPLATE: () => REGION_TEMPLATE,
  REGION_TYPE: () => REGION_TYPE,
  RELATED_TOPICS_PROPERTY: () => RELATED_TOPICS_PROPERTY,
  RELATION: () => RELATION,
  RELATION_FROM_PROPERTY: () => RELATION_FROM_PROPERTY,
  RELATION_INDEX: () => RELATION_INDEX,
  RELATION_TO_PROPERTY: () => RELATION_TO_PROPERTY,
  RELATION_TYPE: () => RELATION_TYPE,
  RELATION_TYPE_PROPERTY: () => RELATION_TYPE_PROPERTY,
  RELATION_VALUE_RELATIONSHIP_TYPE: () => RELATION_VALUE_RELATIONSHIP_TYPE,
  RELEVANT_QUESTIONS_PROPERTY: () => RELEVANT_QUESTIONS_PROPERTY,
  ROLE_PROPERTY: () => ROLE_PROPERTY,
  ROOT_SPACE_ID: () => ROOT_SPACE_ID,
  ROOT_SPACE_TYPE: () => ROOT_SPACE_TYPE,
  SCHEMA_TYPE: () => SCHEMA_TYPE,
  SELECTOR_PROPERTY: () => SELECTOR_PROPERTY,
  SERVICES_PAGE: () => SERVICES_PAGE,
  SHOWN_COLUMNS: () => SHOWN_COLUMNS,
  SOURCE_SPACE_PROPERTY: () => SOURCE_SPACE_PROPERTY,
  SPACES_PAGE: () => SPACES_PAGE,
  SPACE_FILTER: () => SPACE_FILTER,
  SPACE_TYPE: () => SPACE_TYPE,
  SPEAKERS_PROPERTY: () => SPEAKERS_PROPERTY,
  STREET_ADDRESS_PROPERTY: () => STREET_ADDRESS_PROPERTY,
  SUBCLAIMS_PROPERTY: () => SUBCLAIMS_PROPERTY,
  TABLE_VIEW: () => TABLE_VIEW,
  TABS_PROPERTY: () => TABS_PROPERTY,
  TAB_TYPE: () => TAB_TYPE,
  TEAM_PAGE: () => TEAM_PAGE,
  TEMPLATE_PROPERTY: () => TEMPLATE_PROPERTY,
  TEXT_BLOCK: () => TEXT_BLOCK,
  TYPES_PROPERTY: () => TYPES_PROPERTY,
  URL: () => URL2,
  VALUES_PROPERTY: () => VALUES_PROPERTY,
  VERIFIED_SOURCE_PROPERTY: () => VERIFIED_SOURCE_PROPERTY,
  VIEW_PROPERTY: () => VIEW_PROPERTY,
  VIEW_TYPE: () => VIEW_TYPE,
  VISION_PROPERTY: () => VISION_PROPERTY
});
var ENTITY_ID_PROPERTY = Id("1a1fff33-5782-4c33-93c7-c3a5f3592b60");
var PROPERTY = Id("808a04ce-b21c-4d88-8ad1-2e240613e5ca");
var SCHEMA_TYPE = Id("e7d737c5-3676-4c60-9fa1-6aa64a8c90ad");
var PROPERTIES = Id("01412f83-8189-4ab1-8365-65c7fd358cc1");
var NAME_PROPERTY = Id("a126ca53-0c8e-48d5-b888-82c734c38935");
var DESCRIPTION_PROPERTY = Id("9b1f76ff-9711-404c-861e-59dc3fa7d037");
var COVER_PROPERTY = Id("34f53507-2e6b-42c5-a844-43981a77cfa2");
var TYPES_PROPERTY = Id("8f151ba4-de20-4e3c-9cb4-99ddf96f48f1");
var TABS_PROPERTY = Id("4d9cba1c-4766-4698-81cd-3273891a018b");
var BLOCKS = Id("beaba5cb-a677-41a8-b353-77030613fc70");
var URL2 = Id("283127c9-6142-4684-92ed-90b0ebc7f29a");
var IMAGE = Id("f3f790c4-c74e-4d23-a0a9-1e8ef84e30d9");
var RELATION = Id("4b6d9fc1-fbfe-474c-861c-83398e1b50d9");
var SPACE_TYPE = Id("362c1dbd-dc64-44bb-a3c4-652f38a642d7");
var RELATION_VALUE_RELATIONSHIP_TYPE = Id("9eea393f-17dd-4971-a62e-a603e8bfec20");
var IMAGE_TYPE = Id("ba4e4146-0010-499d-a0a3-caaa7f579d0e");
var IMAGE_FILE_TYPE_PROPERTY = Id("515f346f-e0fb-40c7-8ea9-5339787eecc1");
var IMAGE_HEIGHT_PROPERTY = Id("7f6ad043-3e21-4257-a6d4-8bdad36b1d84");
var IMAGE_URL_PROPERTY = Id("8a743832-c094-4a62-b665-0c3cc2f9c7bc");
var IMAGE_WIDTH_PROPERTY = Id("f7b33e08-b76d-4190-aada-cadaa9f561e1");
var DATA_BLOCK = Id("b8803a86-65de-412b-bb35-7e0c84adf473");
var DATA_SOURCE_PROPERTY = Id("8ac1c4bf-453b-44b7-9eda-5d1b527e5ea3");
var ALL_OF_GEO_DATA_SOURCE = Id("f9adb874-52b9-4982-8f55-aa40792751e3");
var COLLECTION_DATA_SOURCE = Id("1295037a-5d9c-4d09-b27c-5502654b9177");
var QUERY_DATA_SOURCE = Id("3b069b04-adbe-4728-917d-1283fd4ac27e");
var SELECTOR_PROPERTY = Id("38ad3edb-8eda-4330-941b-e9abd0dbc9e1");
var FILTER = Id("14a46854-bfd1-4b18-8215-2785c2dab9f3");
var SPACE_FILTER = Id("8f6df521-24fa-4576-887e-0442973e2f33");
var ENTITY_FILTER = Id("d6b8aa86-2c73-41ca-bddb-63aa0732174c");
var COLLECTION_ITEM_RELATION_TYPE = Id("a99f9ce1-2ffa-4dac-8c61-f6310d46064a");
var VIEW_PROPERTY = Id("1907fd1c-8111-4a3c-a378-b1f353425b65");
var VIEW_TYPE = Id("20a21dc2-7371-482f-a120-7b147f1dc319");
var TABLE_VIEW = Id("cba271ce-f7c1-4033-9047-614d174c69f1");
var LIST_VIEW = Id("7d497dba-09c2-49b8-968f-716bcf520473");
var BULLETED_LIST_VIEW = Id("0aaac6f7-c916-403e-af6d-2e086dc92ada");
var GALLERY_VIEW = Id("ccb70fc9-17f0-4a54-b86e-3b4d20cc7130");
var SHOWN_COLUMNS = Id("4221fb36-dcab-4c68-b150-701aaba6c8e0");
var DATA_SOURCE_TYPE_RELATION_TYPE = Id("1f69cc98-80d4-44ab-ad49-3df6a7b15ee4");
var IMAGE_BLOCK = Id("e3817941-7409-4df1-b519-1f3f1a0721e8");
var TEXT_BLOCK = Id("76474f2f-0089-4e77-a041-0b39fb17d0bf");
var MARKDOWN_CONTENT = Id("e3e363d1-dd29-4ccb-8e6f-f3b76d99bc33");
var RELATION_TYPE = Id("c167ef23-fb2a-4044-9ed9-45123ce7d2a9");
var RELATION_FROM_PROPERTY = Id("c43b537b-cff7-4271-8822-717fdf2c9c01");
var RELATION_TO_PROPERTY = Id("c1f4cb6f-ece4-4c3c-a447-ab005b756972");
var RELATION_TYPE_PROPERTY = Id("14611456-b466-4cab-920d-2245f59ce828");
var RELATION_INDEX = Id("ede47e69-30b0-4499-8ea4-aafbda449609");
var VERIFIED_SOURCE_PROPERTY = Id("265e869b-3a27-40bd-b652-a7a77b0df24f");
var SOURCE_SPACE_PROPERTY = Id("81891dec-cb6c-427e-aa1f-b917292ec2dc");
var ACADEMIC_FIELD_TYPE = Id("9959eb50-b029-4a15-8557-b39318cbb91b");
var COMPANY_TYPE = Id("e059a29e-6f6b-437b-bc15-c7983d078c0d");
var DAO_TYPE = Id("872cb6f6-926d-4bb3-9d63-ccede27232b8");
var GOVERNMENT_ORG_TYPE = Id("a87e0291-ec36-4572-8af2-1301b3099e97");
var INDUSTRY_TYPE = Id("fc512a40-8b55-44dc-85b8-5aae88b51fae");
var INTEREST_TYPE = Id("2c765cae-c1b6-4cc3-a65d-693d0a67eaeb");
var NONPROFIT_TYPE = Id("c7a192a3-3909-4572-a848-a56b64dc4636");
var POST_TYPE = Id("f3d44614-86b7-4d25-83d8-9709c9d84f65");
var PROJECT_TYPE = Id("484a18c5-030a-499c-b0f2-ef588ff16d50");
var PROTOCOL_TYPE = Id("c38c4198-10c2-4cf2-9dd5-8f194033fc31");
var REGION_TYPE = Id("c188844a-7224-42ab-b476-2991c9c913f1");
var ROOT_SPACE_TYPE = Id("06053fcf-6443-4dc6-80ca-8a3b173a6016");
var TEMPLATE_PROPERTY = Id("cf37cd59-840c-4dac-a22b-9d9dde536ea7");
var PAGE_TYPE = Id("480e3fc2-67f3-4993-85fb-acdf4ddeaa6b");
var PAGE_TYPE_PROPERTY = Id("62dfabe5-282d-44a7-ba93-f2e80d20743d");
var ACADEMIC_FIELD_TEMPLATE = Id("06beeb0f-418d-46ad-84c3-82d4b1e58a81");
var COMPANY_TEMPLATE = Id("bedb6493-dc5b-47b4-b1a5-c68bfbbb2b43");
var DAO_TEMPLATE = Id("7ee14d70-99f0-4d0a-b371-95f08b0295be");
var INDUSTRY_TEMPLATE = Id("d81abf98-18d9-4259-b968-e538c60c841b");
var INTEREST_TEMPLATE = Id("59fdefec-6815-4866-9065-6d0bc162f2ee");
var NONPROFIT_TEMPLATE = Id("838361ab-f358-4044-9f13-1586a3266a2b");
var PERSON_TEMPLATE = Id("6bc6a6b0-b9eb-441d-b898-14f7a726877c");
var PROTOCOL_TEMPLATE = Id("dd35d506-1787-402c-8e79-f696ab839135");
var REGION_TEMPLATE = Id("c50754d3-bcb4-4013-a403-83f1eb9a442e");
var ONTOLOGY_PAGE_TEMPLATE = Id("8f90bd6d-8147-4eb8-b67f-d34fa2af1397");
var EDUCATION_PAGE_TEMPLATE = Id("c4b7e33f-939a-4871-b9e2-2711b6d3f49f");
var ABOUT_PAGE_TEMPLATE = Id("31af0a8a-6bc1-4981-b2ac-c45f2ba4d27c");
var ABOUT_PAGE = Id("f93d044e-61f6-42a8-92eb-ef37a377a535");
var ACTIVITIES_PAGE = Id("080d3c03-a770-48f2-a306-5103214aaf45");
var CULTURE_PAGE = Id("01dbb38e-270b-4004-9615-fefb10d19f33");
var EDUCATION_PAGE = Id("bfdc5a8f-4f6a-4955-bfbd-7bea921d8a42");
var EVENTS_PAGE = Id("92e64c6e-36ad-453b-9533-9e4be1033cdf");
var FINANCES_PAGE = Id("c316cec6-ddaa-436c-9c52-43b4179db529");
var GOVERNMENT_PAGE = Id("50c29327-1dd2-425e-bd9c-c8257938c891");
var JOBS_PAGE = Id("b4ac6985-5e8e-46d8-8f73-3ed8a918d33a");
var NEWS_PAGE = Id("d172f6f6-93a8-4c28-9577-e9d43259863b");
var ONTOLOGY_PAGE = Id("6e7215ec-10ca-4904-8895-2d89070a9c69");
var PEOPLE_PAGE = Id("238bce0f-1420-4df7-85a3-088aded159fd");
var PERSONAL_PAGE = Id("02fc9e37-25a8-487e-b219-3df738004c62");
var PLACES_PAGE = Id("e4220e2f-6554-4321-9144-344c3be22c00");
var POSTS_PAGE = Id("69a88b15-9a8f-4d56-930e-d7fc84accb14");
var PRODUCTS_PAGE = Id("5f7474c7-115e-44e4-9608-af93edcaf491");
var PROFESSIONAL_PAGE = Id("c613778e-fc19-4342-aed5-43296a72880c");
var PROJECTS_PAGE = Id("1743389c-dafb-49a6-b667-9d8bc46f3f52");
var SERVICES_PAGE = Id("0c06c8a0-563e-420b-b8e5-3b9c911ffa37");
var SPACES_PAGE = Id("8afae81d-33b5-40f7-b89c-ea7d49b10f9f");
var TEAM_PAGE = Id("55147448-8894-4ff7-a163-2f96f7afa7df");
var FINANCE_OVERVIEW_TYPE = Id("2315fe0c-6a4d-4f99-bb19-b59c8e7c563a");
var FINANCE_SUMMMARY_TYPE = Id("40c3c7e1-e066-43df-8eea-9900514e96ed");
var ACCOUNT_TYPE = Id("cb69723f-7456-471a-a8ad-3e93ddc3edfe");
var ACCOUNTS_PROPERTY = Id("e4047a77-0043-4ed4-a410-72139bff7f7e");
var ADDRESS_PROPERTY = Id("85cebdf1-d84f-4afd-993b-35f182096b59");
var NETWORK_PROPERTY = Id("a945fa95-d15e-42bc-b70a-43d3933048dd");
var PERSON_TYPE = Id("7ed45f2b-c48b-419e-8e46-64d5ff680b0d");
var NETWORK_TYPE = Id("fca08431-1aa1-40f2-8a4d-0743c2a59df7");
var GEO_LOCATION_PROPERTY = Id("7cfc4990-e068-4b77-98aa-834137d02953");
var GOALS_PROPERTY = Id("eddd99d6-2033-4651-b046-2cecd1bd6ca5");
var GOAL_TYPE = Id("0fecaded-7c58-4a71-9a02-e1cb49800e27");
var MEMBERSHIP_CONTRACT_ADDRESS = Id("62f5aa2f-34ca-47c0-bcfc-a937396676dd");
var MISSION_PROPERTY = Id("e4ed96e6-92cf-42c4-967b-ab2cef56f889");
var PLACEHOLDER_IMAGE = Id("6c49012e-21fd-4b35-b976-60210ea0ae0f");
var PLACEHOLDER_TEXT = Id("503e9e78-8669-4243-9777-af8fb75cdc56");
var TAB_TYPE = Id("306a88ec-1960-4328-8cdb-77c23de2785a");
var ROLE_PROPERTY = Id("e4e366e9-d555-4b68-92bf-7358e824afd2");
var DEFAULT_TYPE = Id("36ea5723-0851-4012-945e-90d05f0e54e9");
var BROADER_CLAIMS_PROPERTY = Id("c682b9a5-82b3-4345-abc9-1c31cd09a253");
var CLAIMS_FROM_PROPERTY = Id("8ebf2fe7-270b-4a7e-806d-e481c8c058d0");
var DEFINITIONS_PROPERTY = Id("08abac45-2e19-4cb6-afaa-5e11a31eea99");
var EMAIL_PROPERTY = Id("0b63fdea-d04d-4985-8f18-f97995926e6e");
var FOREIGN_TYPES = Id("c2a3dd99-bd57-4593-a801-882e8280b94c");
var NONPROFIT_CATEGORIES_PROPERTY = Id("29094591-c312-43c4-9c4a-0c2eb5063e2c");
var PHONE_NUMBER_PROPERTY = Id("1840e2d2-487f-42a0-9265-f7e7a4752a75");
var QUOTES_PROPERTY = Id("f7286c68-3412-4673-bd58-c25450ab53f9");
var REGION_PROPERTY = Id("5b33846f-4742-49f9-86e5-7009978019a7");
var RELATED_TOPICS_PROPERTY = Id("cc42b16e-956e-4451-a304-5f27e1c3ed11");
var RELEVANT_QUESTIONS_PROPERTY = Id("b897ab9e-6409-473c-9071-0a34f3da537b");
var SPEAKERS_PROPERTY = Id("4725dae3-1163-4c87-8e87-dcf159e385a6");
var STREET_ADDRESS_PROPERTY = Id("3ed2eb81-20b1-488c-90f5-c84f58535083");
var SUBCLAIMS_PROPERTY = Id("09cf4adf-d8e8-4b2e-8cd1-48a3d9a24ac2");
var VALUES_PROPERTY = Id("15183b43-6f73-46b2-812d-edbe1de78343");
var VISION_PROPERTY = Id("4a306614-0c75-416c-a347-d36b3cc9c031");
var CURRENCY_PROPERTY = Id("9291e563-afbe-4709-8780-a52cbb0f4aa9");
var CURRENCY_SIGN_PROPERTY = Id("d9ada086-52e3-4b66-8893-0ccf2f9fd9ea");
var CURRENCY_SYMBOL_PROPERTY = Id("ace1e96c-9b83-47b4-bd33-1d302ec0a0f5");
var CURRENCY_USD_PROPERTY = Id("0d4d1b02-a9e8-4982-92c4-99b1d22cd430");
var CURRENCY_GBP_PROPERTY = Id("95593310-1e7c-43da-a02c-a6f4b630d48a");
var CURRENCY_EUR_PROPERTY = Id("6d5a3fed-379c-4889-b60e-d6265a482c93");
var ROOT_SPACE_ID = Id("08c4f093-7858-4b7c-9b94-b82e448abcff");

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-relation.js
var createRelation = ({ id: providedId, fromEntity, toEntity, position, toSpace, type, entityId: providedEntityId, entityName, entityDescription, entityCover, entityValues, entityRelations, entityTypes }) => {
  if (providedId)
    assertValid(providedId, "`id` in `createRelation`");
  if (fromEntity)
    assertValid(fromEntity, "`fromEntity` in `createRelation`");
  if (toEntity)
    assertValid(toEntity, "`toEntity` in `createRelation`");
  if (toSpace)
    assertValid(toSpace, "`toSpace` in `createRelation`");
  if (type)
    assertValid(type, "`type` in `createRelation`");
  if (providedEntityId)
    assertValid(providedEntityId, "`entityId` in `createRelation`");
  if (entityCover)
    assertValid(entityCover, "`entityCover` in `createRelation`");
  for (const [key] of Object.entries(entityValues ?? {})) {
    assertValid(key, "`entityValues` in `createRelation`");
  }
  for (const [key] of Object.entries(entityRelations ?? {})) {
    assertValid(key, "`entityRelations` in `createRelation`");
  }
  for (const type2 of entityTypes ?? []) {
    assertValid(type2, "`entityTypes` in `createRelation`");
  }
  const id = providedId ?? generate();
  const entityId = providedEntityId ?? generate();
  const ops = [];
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: Id(id),
      entity: Id(entityId),
      fromEntity: Id(fromEntity),
      position,
      toEntity: Id(toEntity),
      toSpace: toSpace ? Id(toSpace) : void 0,
      type: Id(type)
    }
  });
  if (entityName || entityDescription || entityCover || entityValues || entityRelations || entityTypes) {
    const { ops: entityOps } = createEntity({
      id: entityId,
      name: entityName,
      description: entityDescription,
      cover: entityCover,
      values: entityValues,
      relations: entityRelations,
      types: entityTypes
    });
    ops.push(...entityOps);
  }
  return { id: Id(id), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-entity.js
var createEntity = ({ id: providedId, name, description, cover, values, relations, types: types2 }) => {
  if (providedId)
    assertValid(providedId, "`id` in `createEntity`");
  if (cover)
    assertValid(cover, "`cover` in `createEntity`");
  for (const valueEntry of values ?? []) {
    assertValid(valueEntry.property, "`values` in `createEntity`");
    if (valueEntry.options) {
      const optionsParam = valueEntry.options;
      switch (optionsParam.type) {
        case "text":
          if (optionsParam.language) {
            assertValid(optionsParam.language, "`language` in `options` in `values` in `createEntity`");
          }
          break;
        case "number":
          if (optionsParam.unit) {
            assertValid(optionsParam.unit, "`unit` in `options` in `values` in `createEntity`");
          }
          break;
        default:
          throw new Error(`Invalid option type: ${optionsParam.type}`);
      }
    }
    for (const [key, relationEntry] of Object.entries(relations ?? {})) {
      assertValid(key, "`relations` in `createEntity`");
      if (Array.isArray(relationEntry)) {
        for (const relation of relationEntry) {
          assertValid(relation.toEntity, "`toEntity` in `relations` in `createEntity`");
          if (relation.toSpace)
            assertValid(relation.toSpace, "`toSpace` in `relations` in `createEntity`");
          if (relation.fromSpace)
            assertValid(relation.fromSpace, "`fromSpace` in `relations` in `createEntity`");
          if (relation.fromVersion)
            assertValid(relation.fromVersion, "`fromVersion` in `relations` in `createEntity`");
          if (relation.toVersion)
            assertValid(relation.toVersion, "`toVersion` in `relations` in `createEntity`");
          if (relation.entityId)
            assertValid(relation.entityId, "`entityId` in `relations` in `createEntity`");
          if (relation.entityCover)
            assertValid(relation.entityCover, "`entityCover` in `relations` in `createEntity`");
        }
      } else {
        assertValid(relationEntry.toEntity, "`toEntity` in `relations` in `createEntity`");
        if (relationEntry.toSpace)
          assertValid(relationEntry.toSpace, "`toSpace` in `relations` in `createEntity`");
        if (relationEntry.fromSpace)
          assertValid(relationEntry.fromSpace, "`fromSpace` in `relations` in `createEntity`");
        if (relationEntry.fromVersion)
          assertValid(relationEntry.fromVersion, "`fromVersion` in `relations` in `createEntity`");
        if (relationEntry.toVersion)
          assertValid(relationEntry.toVersion, "`toVersion` in `relations` in `createEntity`");
        if (relationEntry.entityId)
          assertValid(relationEntry.entityId, "`entityId` in `relations` in `createEntity`");
        if (relationEntry.entityCover)
          assertValid(relationEntry.entityCover, "`entityCover` in `relations` in `createEntity`");
      }
    }
  }
  for (const typeId of types2 ?? []) {
    assertValid(typeId, "`types` in `createEntity`");
  }
  const id = providedId ?? generate();
  let ops = [];
  const newValues = [];
  if (name) {
    newValues.push({
      property: NAME_PROPERTY,
      value: name
    });
  }
  if (description) {
    newValues.push({
      property: DESCRIPTION_PROPERTY,
      value: description
    });
  }
  for (const valueEntry of values ?? []) {
    let options = void 0;
    if (valueEntry.options) {
      const optionsParam = valueEntry.options;
      switch (optionsParam.type) {
        case "text":
          options = {
            text: {
              language: optionsParam.language
            }
          };
          break;
        case "number":
          options = {
            number: {
              unit: optionsParam.unit
            }
          };
          break;
      }
    }
    newValues.push({
      property: Id(valueEntry.property),
      value: valueEntry.value,
      options
    });
  }
  const op = {
    type: "UPDATE_ENTITY",
    entity: {
      id: Id(id),
      values: newValues
    }
  };
  ops.push(op);
  if (cover) {
    ops.push({
      type: "CREATE_RELATION",
      relation: {
        id: generate(),
        entity: generate(),
        fromEntity: Id(id),
        toEntity: Id(cover),
        type: COVER_PROPERTY
      }
    });
  }
  if (types2) {
    for (const typeId of types2) {
      ops.push({
        type: "CREATE_RELATION",
        relation: {
          id: generate(),
          entity: generate(),
          fromEntity: Id(id),
          toEntity: Id(typeId),
          type: TYPES_PROPERTY
        }
      });
    }
  }
  for (const [typeId, value] of Object.entries(relations ?? {})) {
    const relationsEntries = Array.isArray(value) ? value : [value];
    for (const relation of relationsEntries) {
      const relationId = relation.id ?? generate();
      const relationEntityId = relation.entityId ?? generate();
      const { ops: relationOps } = createRelation({
        id: relationId,
        fromEntity: id,
        toEntity: relation.toEntity,
        type: Id(typeId),
        position: relation.position,
        toSpace: relation.toSpace,
        entityId: relationEntityId,
        entityName: relation.entityName,
        entityDescription: relation.entityDescription,
        entityCover: relation.entityCover,
        entityValues: relation.entityValues,
        entityRelations: relation.entityRelations,
        entityTypes: relation.entityTypes
      });
      ops = ops.concat(relationOps);
    }
  }
  return { id: Id(id), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/core/get-checksum-address.js
function getChecksumAddress(address) {
  return getAddress(address);
}

// node_modules/@graphprotocol/grc-20/dist/src/core/ids/network.js
var network_exports = {};
__export(network_exports, {
  ETHEREUM: () => ETHEREUM,
  GEO: () => GEO,
  POLYGON: () => POLYGON
});
var POLYGON = Id("0370cdbd-57a9-46e9-a511-9c0c1ffc69d7");
var ETHEREUM = Id("90061c99-7659-42c3-b9d9-edbf6b834487");
var GEO = Id("943e38b9-e304-4300-866c-06af4e3c298a");

// node_modules/@graphprotocol/grc-20/dist/src/core/account.js
function make(address) {
  const accountId = generate();
  const checkedAddress = getChecksumAddress(address);
  const ops = [];
  const { ops: entityOps } = createEntity({
    id: accountId,
    values: [
      {
        property: ADDRESS_PROPERTY,
        value: checkedAddress
      },
      {
        property: NAME_PROPERTY,
        value: checkedAddress
      }
    ]
  });
  ops.push(...entityOps);
  const { ops: accountOps } = createRelation({
    fromEntity: accountId,
    type: TYPES_PROPERTY,
    toEntity: ACCOUNT_TYPE
  });
  ops.push(...accountOps);
  const { ops: networkOps } = createRelation({
    fromEntity: accountId,
    type: NETWORK_PROPERTY,
    toEntity: ETHEREUM
  });
  ops.push(...networkOps);
  return {
    accountId,
    ops
  };
}

// node_modules/@graphprotocol/grc-20/dist/src/core/blocks/data.js
var data_exports = {};
__export(data_exports, {
  make: () => make2
});

// node_modules/@graphprotocol/grc-20/dist/src/graph/update-entity.js
var updateEntity = ({ id, name, description, cover, values }) => {
  assertValid(id, "`id` in `updateEntity`");
  if (cover)
    assertValid(cover, "`cover` in `updateEntity`");
  for (const { property, options } of values ?? []) {
    assertValid(property, "`values` in `updateEntity`");
    if (options) {
      switch (options.type) {
        case "text":
          if (options.language) {
            assertValid(options.language, "`language` in `options` in `values` in `createEntity`");
          }
          break;
        case "number":
          if (options.unit) {
            assertValid(options.unit, "`unit` in `options` in `values` in `createEntity`");
          }
          break;
        default:
          throw new Error(`Invalid option type: ${options.type}`);
      }
    }
  }
  const ops = [];
  const newValues = [];
  if (name) {
    newValues.push({
      property: NAME_PROPERTY,
      value: name
    });
  }
  if (description) {
    newValues.push({
      property: DESCRIPTION_PROPERTY,
      value: description
    });
  }
  for (const valueEntry of values ?? []) {
    let options = void 0;
    if (valueEntry.options) {
      const optionsParam = valueEntry.options;
      switch (optionsParam.type) {
        case "text":
          options = {
            text: {
              language: optionsParam.language
            }
          };
          break;
        case "number":
          options = {
            number: {
              unit: optionsParam.unit
            }
          };
          break;
      }
    }
    newValues.push({
      property: Id(valueEntry.property),
      value: valueEntry.value,
      options
    });
  }
  const op = {
    type: "UPDATE_ENTITY",
    entity: {
      id: Id(id),
      values: newValues
    }
  };
  ops.push(op);
  if (cover) {
    ops.push({
      type: "CREATE_RELATION",
      relation: {
        id: generate(),
        entity: generate(),
        fromEntity: Id(id),
        toEntity: Id(cover),
        type: COVER_PROPERTY
      }
    });
  }
  return { id: Id(id), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/core/ids/content.js
var content_exports = {};
__export(content_exports, {
  ARTICLE_TYPE: () => ARTICLE_TYPE,
  AUTHORS_PROPERTY: () => AUTHORS_PROPERTY,
  AVATAR_PROPERTY: () => AVATAR_PROPERTY,
  BROADER_GOALS_PROPERTY: () => BROADER_GOALS_PROPERTY,
  BROADER_PROJECTS_PROPERTY: () => BROADER_PROJECTS_PROPERTY,
  BROADER_TOPICS_PROPERTY: () => BROADER_TOPICS_PROPERTY,
  CITIES_PROPERTY: () => CITIES_PROPERTY,
  CITY_TYPE: () => CITY_TYPE,
  CLAIM_TYPE: () => CLAIM_TYPE,
  CONTINENTS_PROPERTY: () => CONTINENTS_PROPERTY,
  CONTINENT_TYPE: () => CONTINENT_TYPE,
  COUNTRIES_PROPERTY: () => COUNTRIES_PROPERTY,
  COUNTRY_TYPE: () => COUNTRY_TYPE,
  DISCLAIMER_PROPERTY: () => DISCLAIMER_PROPERTY,
  EVENT_DATE_PROPERTY: () => EVENT_DATE_PROPERTY,
  GOAL_TYPE: () => GOAL_TYPE2,
  HIGHLIGHTED_RELATED_ENTIRIES_PROPERTY: () => HIGHLIGHTED_RELATED_ENTIRIES_PROPERTY,
  JOB_TYPE: () => JOB_TYPE,
  LOCATION_PROPERTY: () => LOCATION_PROPERTY,
  NEWS_EVENT_TYPE: () => NEWS_EVENT_TYPE,
  NEWS_STORY_TYPE: () => NEWS_STORY_TYPE,
  OPPOSING_ARGUMENTS_PROPERTY: () => OPPOSING_ARGUMENTS_PROPERTY,
  OWNERS_PROPERTY: () => OWNERS_PROPERTY,
  PERSON_PROPERTY: () => PERSON_PROPERTY,
  POLICY_TYPE: () => POLICY_TYPE,
  PRINCIPLE_TYPE: () => PRINCIPLE_TYPE,
  PROJECT_PROPERTY: () => PROJECT_PROPERTY,
  PUBLISHER_PROPERTY: () => PUBLISHER_PROPERTY,
  PUBLISHER_TYPE: () => PUBLISHER_TYPE,
  PUBLISH_DATE_PROPERTY: () => PUBLISH_DATE_PROPERTY,
  QUOTES_THAT_SUPPORT_CLAIMS_PROPERTY: () => QUOTES_THAT_SUPPORT_CLAIMS_PROPERTY,
  QUOTE_TYPE: () => QUOTE_TYPE,
  REGION_TYPE: () => REGION_TYPE2,
  RELATED_ENTITIES_PROPERTY: () => RELATED_ENTITIES_PROPERTY,
  RELATED_PEOPLE_PROPERTY: () => RELATED_PEOPLE_PROPERTY,
  RELATED_PROJECTS_PROPERTY: () => RELATED_PROJECTS_PROPERTY,
  RELATED_SPACES_PROPERTY: () => RELATED_SPACES_PROPERTY,
  RELATED_TOPICS_PROPERTY: () => RELATED_TOPICS_PROPERTY2,
  ROLES_PROPERTY: () => ROLES_PROPERTY,
  SKILLS_PROPERTY: () => SKILLS_PROPERTY,
  SKILL_TYPE: () => SKILL_TYPE,
  SOURCES_PROPERTY: () => SOURCES_PROPERTY,
  SUBGOALS_PROPERTY: () => SUBGOALS_PROPERTY,
  SUBPROJECTS_PROPERTY: () => SUBPROJECTS_PROPERTY,
  SUBTOPICS_PROPERTY: () => SUBTOPICS_PROPERTY,
  SUPPORTING_ARGUMENTS_PROPERTY: () => SUPPORTING_ARGUMENTS_PROPERTY,
  TAG_TYPE: () => TAG_TYPE,
  TOPICS_PROPERTY: () => TOPICS_PROPERTY,
  TOPIC_TYPE: () => TOPIC_TYPE,
  VALUE_TYPE: () => VALUE_TYPE,
  WEBSITE_PROPERTY: () => WEBSITE_PROPERTY,
  WEB_ARCHIVE_URL_PROPERTY: () => WEB_ARCHIVE_URL_PROPERTY,
  WEB_URL_PROPERTY: () => WEB_URL_PROPERTY,
  X_PROPERTY: () => X_PROPERTY
});
var ARTICLE_TYPE = Id("a2a5ed0c-acef-46b1-835d-e457956ce915");
var CITY_TYPE = Id("01b05333-941a-4b00-bc78-fac5a15b467d");
var CLAIM_TYPE = Id("96f859ef-a1ca-4b22-9372-c86ad58b694b");
var CONTINENT_TYPE = Id("3317d044-a700-4a9d-bbaf-4c16ade42f76");
var COUNTRY_TYPE = Id("42a0a761-8c82-459f-ad08-34bfeb437cde");
var GOAL_TYPE2 = Id("1845ee99-80c6-48a3-abc3-809de1753c63");
var JOB_TYPE = Id("5ab7946f-82bc-4289-9d02-a5f13bd40935");
var NEWS_EVENT_TYPE = Id("bb9a85bd-6dc6-4efd-8232-e2782cb4b5f8");
var NEWS_STORY_TYPE = Id("e550fe51-7e90-4b2c-8fff-df13408f5634");
var POLICY_TYPE = Id("7f237bdd-d95f-4d3f-8686-f52a5dd29386");
var PUBLISHER_TYPE = Id("531ac4c5-e409-46ad-9dd3-abcd2db955a0");
var QUOTE_TYPE = Id("043a171c-6918-4dc3-a7db-b8471ca6fcc2");
var REGION_TYPE2 = Id("c188844a-7224-42ab-b476-2991c9c913f1");
var SKILL_TYPE = Id("9ca6ab1f-3a11-4e49-bbaf-72e0c9a985cf");
var TAG_TYPE = Id("e0fcc66c-9e86-43f4-8080-2469d8a1a93a");
var TOPIC_TYPE = Id("5ef5a586-0f27-4d8e-8f6c-59ae5b3e89e2");
var AVATAR_PROPERTY = Id("1155beff-fad5-49b7-a2e0-da4777b8792c");
var BROADER_GOALS_PROPERTY = Id("7072d8d0-3136-4993-9ae5-dacae05e25f9");
var SUBGOALS_PROPERTY = Id("ef0edbba-6987-4057-b616-836483df2344");
var DISCLAIMER_PROPERTY = Id("2877c1c3-d2ad-493f-abe7-6e1bb16e1c37");
var EVENT_DATE_PROPERTY = Id("52665f3e-fb7d-48d5-8b6b-abb21b0d36db");
var RELATED_PEOPLE_PROPERTY = Id("5df8e432-9cc5-4f03-8f85-4ac82e157ada");
var SKILLS_PROPERTY = Id("a38732e3-3a3d-47f9-a459-fb369c287709");
var ROLES_PROPERTY = Id("8fcfe5ef-3d91-47bd-8322-3830a998d26b");
var HIGHLIGHTED_RELATED_ENTIRIES_PROPERTY = Id("0a62474e-3a3f-4c86-b507-6ea582439dd1");
var PUBLISHER_PROPERTY = Id("9ec2b47e-4819-47c0-a99e-8ddb27a3ed8e");
var AUTHORS_PROPERTY = Id("91a9e2f6-e51a-48f7-9976-61de8561b690");
var WEB_ARCHIVE_URL_PROPERTY = Id("54aa3b25-c45d-4974-a937-6bb895aeaefe");
var PUBLISH_DATE_PROPERTY = Id("94e43fe8-faf2-4100-9eb8-87ab4f999723");
var OWNERS_PROPERTY = Id("c9ed4b4b-7294-4eda-9a03-a7975cd1651e");
var SOURCES_PROPERTY = Id("49c5d5e1-679a-4dbd-bfd3-3f618f227c94");
var QUOTES_THAT_SUPPORT_CLAIMS_PROPERTY = Id("f1576465-b8d1-479f-913c-9149fe0bd15e");
var OPPOSING_ARGUMENTS_PROPERTY = Id("4e6ec5d1-4292-498a-84e5-f607ca1a08ce");
var SUPPORTING_ARGUMENTS_PROPERTY = Id("1dc6a843-4588-4819-8e7a-6e672268f811");
var WEBSITE_PROPERTY = Id("eed38e74-e679-46bf-8a42-ea3e4f8fb5fb");
var BROADER_PROJECTS_PROPERTY = Id("28b3ee04-c2b9-46c3-bb9d-4c450e0f26fd");
var SUBPROJECTS_PROPERTY = Id("83240c7c-1a9b-4332-bbb5-67a76e02c003");
var TOPICS_PROPERTY = Id("458fbc07-0dbf-4c92-8f57-16f3fdde7c32");
var RELATED_ENTITIES_PROPERTY = Id("dfa6aebe-1ca9-4bf2-9fac-cc4cc7afb24c");
var X_PROPERTY = Id("0d625978-4b3c-4b57-a86f-de45c997c73c");
var CITIES_PROPERTY = Id("2282fece-7494-40d6-bcdc-aad2355c40fb");
var LOCATION_PROPERTY = Id("95d77002-1faf-4f7c-b7de-b21a7d48cda0");
var WEB_URL_PROPERTY = Id("412ff593-e915-4012-a43d-4c27ec5c68b6");
var SUBTOPICS_PROPERTY = Id("39e40cad-b23d-4f63-ab2f-aea1596436c7");
var RELATED_TOPICS_PROPERTY2 = Id("806d52bc-27e9-4c91-93c0-57978b093351");
var COUNTRIES_PROPERTY = Id("c4c88260-ea3a-4498-a2f9-be340a19758e");
var BROADER_TOPICS_PROPERTY = Id("b35bd6d3-9fb6-4f3a-8aea-f5a9b91b5ef6");
var RELATED_PROJECTS_PROPERTY = Id("6e3503fa-b974-460e-a3db-ab8af9a41427");
var CONTINENTS_PROPERTY = Id("1c5b7c0a-d187-425e-885c-2980d9db6b4b");
var PERSON_PROPERTY = Id("eb1141ae-ba35-43df-acdd-3329cccd8121");
var PROJECT_PROPERTY = Id("e3a96728-2b09-4af7-9af7-86ef1aa7837e");
var RELATED_SPACES_PROPERTY = Id("5b722cd3-61d6-494e-8887-1310566437ba");
var VALUE_TYPE = Id("fb1551b2-1816-46eb-8919-c73253c32022");
var PRINCIPLE_TYPE = Id("0f526048-26cf-40d6-8bab-967e5fb1a08a");

// node_modules/@graphprotocol/grc-20/dist/src/core/blocks/data.js
function getSourceTypeId(sourceType) {
  switch (sourceType) {
    case "COLLECTION":
      return system_exports.COLLECTION_DATA_SOURCE;
    case "GEO":
      return system_exports.ALL_OF_GEO_DATA_SOURCE;
    case "QUERY":
      return system_exports.QUERY_DATA_SOURCE;
  }
}
function make2({ fromId, sourceType, position, name }) {
  const newBlockId = generate();
  const ops = [];
  const { ops: dataBlockTypeOps } = createRelation({
    fromEntity: newBlockId,
    type: TYPES_PROPERTY,
    toEntity: DATA_BLOCK
  });
  ops.push(...dataBlockTypeOps);
  const { ops: dataBlockSourceTypeOps } = createRelation({
    fromEntity: newBlockId,
    type: DATA_SOURCE_TYPE_RELATION_TYPE,
    toEntity: getSourceTypeId(sourceType)
  });
  ops.push(...dataBlockSourceTypeOps);
  const { ops: dataBlockRelationOps } = createRelation({
    fromEntity: Id(fromId),
    type: BLOCKS,
    toEntity: Id(newBlockId),
    position
  });
  ops.push(...dataBlockRelationOps);
  if (name) {
    const { ops: nameOps } = updateEntity({
      id: newBlockId,
      values: [
        {
          property: NAME_PROPERTY,
          value: name
        }
      ]
    });
    ops.push(...nameOps);
  }
  return ops;
}

// node_modules/@graphprotocol/grc-20/dist/src/core/blocks/text.js
var text_exports = {};
__export(text_exports, {
  make: () => make3
});
function make3({ fromId, text, position }) {
  const newBlockId = generate();
  const ops = [];
  const { ops: textBlockTypeOps } = createRelation({
    fromEntity: newBlockId,
    type: TYPES_PROPERTY,
    toEntity: TEXT_BLOCK
  });
  ops.push(...textBlockTypeOps);
  const { ops: textBlockMarkdownTextOps } = updateEntity({
    id: newBlockId,
    values: [
      {
        property: MARKDOWN_CONTENT,
        value: text
      }
    ]
  });
  ops.push(...textBlockMarkdownTextOps);
  const { ops: textBlockRelationOps } = createRelation({
    fromEntity: Id(fromId),
    type: BLOCKS,
    toEntity: newBlockId,
    position
  });
  ops.push(...textBlockRelationOps);
  return ops;
}

// node_modules/@graphprotocol/grc-20/dist/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  getEditCalldata: () => getEditCalldata
});

// node_modules/@graphprotocol/grc-20/dist/src/graph/constants.js
var MAINNET_API_ORIGIN = "https://hypergraph-v2.up.railway.app";
var TESTNET_API_ORIGIN = "https://hypergraph-v2-testnet.up.railway.app";

// node_modules/@graphprotocol/grc-20/dist/src/encoding.js
var GetEditCalldataError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "_tag", "GetEditCalldataError");
  }
};
async function getEditCalldata(params) {
  const getCalldata = Micro_exports.gen(function* () {
    const result = yield* Micro_exports.tryPromise({
      try: () => fetch(`${params.network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN}/space/${params.spaceId}/edit/calldata`, {
        method: "POST",
        body: JSON.stringify({ cid: params.cid })
      }),
      catch: (error) => new GetEditCalldataError(`Could not get edit calldata from space ${params.spaceId}: ${error}`)
    });
    const calldata = yield* Micro_exports.tryPromise({
      try: async () => {
        const { to, data } = await result.json();
        return {
          to,
          data
        };
      },
      catch: (error) => new GetEditCalldataError(`Could not parse response from API when getting calldata for space ${params.spaceId}: ${error}`)
    });
    return calldata;
  });
  return await Micro_exports.runPromise(getCalldata);
}

// node_modules/@graphprotocol/grc-20/dist/src/graph/index.js
var graph_exports = {};
__export(graph_exports, {
  createEntity: () => createEntity,
  createImage: () => createImage,
  createProperty: () => createProperty,
  createRelation: () => createRelation,
  createSpace: () => createSpace,
  createType: () => createType,
  deleteRelation: () => deleteRelation,
  serializeCheckbox: () => serializeCheckbox,
  serializeDate: () => serializeDate,
  serializeNumber: () => serializeNumber,
  serializePoint: () => serializePoint,
  unsetEntityValues: () => unsetEntityValues,
  unsetRelationFields: () => unsetRelationFields,
  updateEntity: () => updateEntity
});

// node_modules/@graphprotocol/grc-20/dist/src/ipfs.js
var ipfs_exports = {};
__export(ipfs_exports, {
  publishEdit: () => publishEdit,
  uploadCSV: () => uploadCSV,
  uploadImage: () => uploadImage
});

// node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c, id, msg, transfer, cb) {
  var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
    c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w.onmessage = function(e) {
    var d = e.data, ed = d.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t.push({ s: i, f: d[i] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym)
      maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i)
    ++lcfreq[lcdt[i] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s = st.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i + 2 < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i, st.w = wi;
    }
  } else {
    for (var i = st.w || 0; i < s + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i] = c;
  }
  return t;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n = a, m = b;
      var l = d.length | 0;
      for (var i = 0; i != l; ) {
        var e = Math.min(i + 2655, l);
        for (; i < e; ++i)
          m += n += d[i];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i], k = ks[i];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t in v.prototype)
            fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k].buffer) {
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init, id, cb) {
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i = 0; i < m; ++i)
      fnStr = wcln(fns[i], fnStr, td_1);
    ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id].e);
  return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o) {
  return o && {
    out: o.size && new u8(o.size),
    dictionary: o.dictionary
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    if (ev.data.length) {
      strm.push(ev.data[0], ev.data[1]);
      postMessage([ev.data[0].length]);
    } else
      strm.flush();
  };
};
var astrmify = function(fns, strm, opts, init, id, flush, ext) {
  var t;
  var w = wrkr(fns, init, id, function(err2, dat) {
    if (err2)
      w.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else if (dat.length == 1) {
      strm.queuedSize -= dat[0];
      if (strm.ondrain)
        strm.ondrain(dat[0]);
    } else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.queuedSize = 0;
  strm.push = function(d, f) {
    if (!strm.ondata)
      err(5);
    if (t)
      strm.ondata(err(4, 0, 1), null, !!f);
    strm.queuedSize += d.length;
    w.postMessage([d, t = f], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
  if (flush) {
    strm.flush = function() {
      w.postMessage([]);
    };
  }
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v) {
  for (; v; ++b)
    d[b] = v, v >>>= 8;
};
var gzh = function(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i = 0; i <= fn.length; ++i)
      c[i + 10] = fn.charCodeAt(i);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename ? o.filename.length + 1 : 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
  c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
  if (o.dictionary) {
    var h = adler();
    h.p(o.dictionary);
    wbytes(c, 2, h.d());
  }
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u8(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c, f) {
    this.ondata(dopt(c, this.o, 0, 0, this.s), f);
  };
  Deflate2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u8(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split = this.b.length - this.s.z;
      this.b.set(chunk.subarray(0, split), this.s.z);
      this.s.z = this.b.length;
      this.p(this.b, false);
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk.subarray(split), 32768);
      this.s.z = chunk.length - split + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk, this.s.z);
      this.s.z += chunk.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  Deflate2.prototype.flush = function() {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    this.p(this.b, false);
    this.s.w = this.s.i, this.s.i -= 2;
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6, 1);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u8(32768);
    this.p = new u8(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u8(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk, final) {
    this.e(chunk), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7, 0);
  }
  return AsyncInflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    this.l += chunk.length;
    Deflate.prototype.push.call(this, chunk, final);
  };
  Gzip2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };
  Gzip2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Gzip2;
}();
function gzipSync(data, opts) {
  if (!opts)
    opts = {};
  var c = crc(), l = data.length;
  c.p(data);
  var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
var Gunzip = function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    this.r += chunk.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u8(0);
      this.push(new u8(0), final);
    }
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(opts, cb) {
    var _this = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, 0, function(offset) {
      return _this.onmember && _this.onmember(offset);
    });
  }
  return AsyncGunzip2;
}();
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk, final) {
    this.c.p(chunk);
    Deflate.prototype.push.call(this, chunk, final);
  };
  Zlib2.prototype.p = function(c, f) {
    var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };
  Zlib2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk, final) {
    Inflate.prototype.e.call(this, chunk);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11, 0);
  }
  return AsyncUnzlib2;
}();
var Decompress = function() {
  function Decompress2(opts, cb) {
    this.o = StrmOpt.call(this, opts, cb) || {};
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
  }
  Decompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(dat, final) {
      _this.ondata(dat, final);
    };
  };
  Decompress2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else
        this.p = chunk;
      if (this.p.length > 2) {
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
        this.i();
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(opts, cb) {
    Decompress.call(this, opts, cb);
    this.queuedSize = 0;
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
  }
  AsyncDecompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    };
    this.s.ondrain = function(size) {
      _this.queuedSize -= size;
      if (_this.ondrain)
        _this.ondrain(size);
    };
  };
  AsyncDecompress2.prototype.push = function(chunk, final) {
    this.queuedSize += chunk.length;
    Decompress.prototype.push.call(this, chunk, final);
  };
  return AsyncDecompress2;
}();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (final) {
      if (r.length)
        err(8);
      this.p = null;
    } else
      this.p = r;
    this.ondata(s, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (r.length)
      err(8);
    return s;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk, final) {
    this.ondata(null, chunk, final);
  };
  ZipPassThrough2.prototype.push = function(chunk, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk);
    this.size += chunk.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk, final) {
    this.d.push(chunk, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };
  return AsyncZipDeflate2;
}();
var Zip = function() {
  function Zip2(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip2.prototype.add = function(file) {
    var _this = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f = strToU8(file.filename), fl_1 = f.length;
      var com = file.comment, o = com && strToU8(com);
      var u = fl_1 != file.filename.length || o && com.length != o.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u8(hl_1);
      wzh(header, 0, file, f, u, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f,
        u,
        o,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this.ondata(err2, dat, final);
          _this.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u8(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip2.prototype.end = function() {
    var _this = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this.d & 1))
            return;
          _this.u.splice(-1, 1);
          _this.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip2.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }
    var out = new u8(tl + 22);
    for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
      var f = _c[_b2];
      wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip2.prototype.terminate = function() {
    for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
      var f = _a2[_i];
      f.t();
    }
    this.d = 2;
  };
  return Zip2;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this = this;
    this.i = new Inflate(function(dat, final) {
      _this.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk, final) {
    var _this = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length)
        return this.push(chunk, final);
    } else {
      var f = 0, i = 0, is = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk;
      else if (!chunk.length)
        buf = this.p;
      else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length, oc = this.c, add = oc && this.d;
      var _loop_2 = function() {
        var _a2;
        var sig = b4(buf, i);
        if (sig == 67324752) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
          if (l > i + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f = 2;
            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a2 = dd ? [-2] : z64e(buf, i), sc_1 = _a2[0], su_1 = _a2[1];
            } else if (dd)
              sc_1 = -1;
            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr = _this.o[cmp_1];
                  if (!ctr)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this.k[0] == chks_3 && _this.c)
                    _this.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
        if (add)
          add.push(dat, !!f);
        else
          this.k[+(f == 2)].push(dat);
      }
      if (f & 2)
        return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder2) {
    this.o[decoder2.compression] = decoder2;
  };
  return Unzip2;
}();

// node_modules/image-size/dist/index.mjs
var decoder = new TextDecoder();
var toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
var toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + `0${i.toString(16)}`.slice(-2), "");
var getView = (input, offset) => new DataView(input.buffer, input.byteOffset + offset);
var readInt16LE = (input, offset = 0) => getView(input, offset).getInt16(0, true);
var readUInt16BE = (input, offset = 0) => getView(input, offset).getUint16(0, false);
var readUInt16LE = (input, offset = 0) => getView(input, offset).getUint16(0, true);
var readUInt24LE = (input, offset = 0) => {
  const view = getView(input, offset);
  return view.getUint16(0, true) + (view.getUint8(2) << 16);
};
var readInt32LE = (input, offset = 0) => getView(input, offset).getInt32(0, true);
var readUInt32BE = (input, offset = 0) => getView(input, offset).getUint32(0, false);
var readUInt32LE = (input, offset = 0) => getView(input, offset).getUint32(0, true);
var readUInt64 = (input, offset, isBigEndian) => getView(input, offset).getBigUint64(0, !isBigEndian);
var methods = {
  readUInt16BE,
  readUInt16LE,
  readUInt32BE,
  readUInt32LE
};
function readUInt(input, bits2, offset = 0, isBigEndian = false) {
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = `readUInt${bits2}${endian}`;
  return methods[methodName](input, offset);
}
function readBox(input, offset) {
  if (input.length - offset < 4) return;
  const boxSize = readUInt32BE(input, offset);
  if (input.length - offset < boxSize) return;
  return {
    name: toUTF8String(input, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(input, boxName, currentOffset) {
  while (currentOffset < input.length) {
    const box = readBox(input, currentOffset);
    if (!box) break;
    if (box.name === boxName) return box;
    currentOffset += box.size > 0 ? box.size : 8;
  }
}
var BMP = {
  validate: (input) => toUTF8String(input, 0, 2) === "BM",
  calculate: (input) => ({
    height: Math.abs(readInt32LE(input, 22)),
    width: readUInt32LE(input, 18)
  })
};
var TYPE_ICON = 1;
var SIZE_HEADER = 2 + 2 + 2;
var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
  const value = input[offset];
  return value === 0 ? 256 : value;
}
function getImageSize(input, imageIndex) {
  const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
var ICO = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_ICON;
  },
  calculate(input) {
    const nbImages = readUInt16LE(input, 4);
    const imageSize2 = getImageSize(input, 0);
    if (nbImages === 1) return imageSize2;
    const images = [];
    for (let imageIndex = 0; imageIndex < nbImages; imageIndex += 1) {
      images.push(getImageSize(input, imageIndex));
    }
    return {
      width: imageSize2.width,
      height: imageSize2.height,
      images
    };
  }
};
var TYPE_CURSOR = 2;
var CUR = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_CURSOR;
  },
  calculate: (input) => ICO.calculate(input)
};
var DDS = {
  validate: (input) => readUInt32LE(input, 0) === 542327876,
  calculate: (input) => ({
    height: readUInt32LE(input, 12),
    width: readUInt32LE(input, 16)
  })
};
var gifRegexp = /^GIF8[79]a/;
var GIF = {
  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
  calculate: (input) => ({
    height: readUInt16LE(input, 8),
    width: readUInt16LE(input, 6)
  })
};
var brandMap = {
  avif: "avif",
  mif1: "heif",
  msf1: "heif",
  // heif-sequence
  heic: "heic",
  heix: "heic",
  hevc: "heic",
  // heic-sequence
  hevx: "heic"
  // heic-sequence
};
var HEIF = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "ftyp") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand in brandMap;
  },
  calculate(input) {
    const metaBox = findBox(input, "meta", 0);
    const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
    const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
    if (!ipcoBox) {
      throw new TypeError("Invalid HEIF, no ipco box found");
    }
    const type = toUTF8String(input, 8, 12);
    const images = [];
    let currentOffset = ipcoBox.offset + 8;
    while (currentOffset < ipcoBox.offset + ipcoBox.size) {
      const ispeBox = findBox(input, "ispe", currentOffset);
      if (!ispeBox) break;
      const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
      const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
      const clapBox = findBox(input, "clap", currentOffset);
      let width = rawWidth;
      let height = rawHeight;
      if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
        const cropRight = readUInt32BE(input, clapBox.offset + 12);
        width = rawWidth - cropRight;
      }
      images.push({ height, width });
      currentOffset = ispeBox.offset + ispeBox.size;
    }
    if (images.length === 0) {
      throw new TypeError("Invalid HEIF, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      type,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var SIZE_HEADER2 = 4 + 4;
var FILE_LENGTH_OFFSET = 4;
var ENTRY_LENGTH_OFFSET = 4;
var ICON_TYPE_SIZE = {
  ICON: 32,
  "ICN#": 32,
  // m => 16 x 16
  "icm#": 16,
  icm4: 16,
  icm8: 16,
  // s => 16 x 16
  "ics#": 16,
  ics4: 16,
  ics8: 16,
  is32: 16,
  s8mk: 16,
  icp4: 16,
  // l => 32 x 32
  icl4: 32,
  icl8: 32,
  il32: 32,
  l8mk: 32,
  icp5: 32,
  ic11: 32,
  // h => 48 x 48
  ich4: 48,
  ich8: 48,
  ih32: 48,
  h8mk: 48,
  // . => 64 x 64
  icp6: 64,
  ic12: 32,
  // t => 128 x 128
  it32: 128,
  t8mk: 128,
  ic07: 128,
  // . => 256 x 256
  ic08: 256,
  ic13: 256,
  // . => 512 x 512
  ic09: 512,
  ic14: 512,
  // . => 1024 x 1024
  ic10: 1024
};
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize2(type) {
  const size = ICON_TYPE_SIZE[type];
  return { width: size, height: size, type };
}
var ICNS = {
  validate: (input) => toUTF8String(input, 0, 4) === "icns",
  calculate(input) {
    const inputLength = input.length;
    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
    let imageOffset = SIZE_HEADER2;
    const images = [];
    while (imageOffset < fileLength && imageOffset < inputLength) {
      const imageHeader = readImageHeader(input, imageOffset);
      const imageSize2 = getImageSize2(imageHeader[0]);
      images.push(imageSize2);
      imageOffset += imageHeader[1];
    }
    if (images.length === 0) {
      throw new TypeError("Invalid ICNS, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var J2C = {
  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
  validate: (input) => readUInt32BE(input, 0) === 4283432785,
  calculate: (input) => ({
    height: readUInt32BE(input, 12),
    width: readUInt32BE(input, 8)
  })
};
var JP2 = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "jP  ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jp2 ";
  },
  calculate(input) {
    const jp2hBox = findBox(input, "jp2h", 0);
    const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
    if (ihdrBox) {
      return {
        height: readUInt32BE(input, ihdrBox.offset + 8),
        width: readUInt32BE(input, ihdrBox.offset + 12)
      };
    }
    throw new TypeError("Unsupported JPEG 2000 format");
  }
};
var EXIF_MARKER = "45786966";
var APP1_DATA_SIZE_BYTES = 2;
var EXIF_HEADER_BYTES = 6;
var TIFF_BYTE_ALIGN_BYTES = 2;
var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
var IDF_ENTRY_BYTES = 12;
var NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
  return {
    height: readUInt16BE(input, index),
    width: readUInt16BE(input, index + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index) {
  if (index > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
var JPG = {
  validate: (input) => toHexString(input, 0, 2) === "ffd8",
  calculate(_input) {
    let input = _input.slice(4);
    let orientation;
    let next;
    while (input.length) {
      const i = readUInt16BE(input, 0);
      validateInput(input, i);
      if (input[i] !== 255) {
        input = input.slice(1);
        continue;
      }
      if (isEXIF(input)) {
        orientation = validateExifBlock(input, i);
      }
      next = input[i + 1];
      if (next === 192 || next === 193 || next === 194) {
        const size = extractSize(input, i + 5);
        if (!orientation) {
          return size;
        }
        return {
          height: size.height,
          orientation,
          width: size.width
        };
      }
      input = input.slice(i + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
};
var BitReader = class {
  constructor(input, endianness) {
    this.input = input;
    this.endianness = endianness;
    this.byteOffset = 2;
    this.bitOffset = 0;
  }
  /** Reads a specified number of bits, and move the offset */
  getBits(length = 1) {
    let result = 0;
    let bitsRead = 0;
    while (bitsRead < length) {
      if (this.byteOffset >= this.input.length) {
        throw new Error("Reached end of input");
      }
      const currentByte = this.input[this.byteOffset];
      const bitsLeft = 8 - this.bitOffset;
      const bitsToRead = Math.min(length - bitsRead, bitsLeft);
      if (this.endianness === "little-endian") {
        const mask = (1 << bitsToRead) - 1;
        const bits2 = currentByte >> this.bitOffset & mask;
        result |= bits2 << bitsRead;
      } else {
        const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
        const bits2 = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
        result = result << bitsToRead | bits2;
      }
      bitsRead += bitsToRead;
      this.bitOffset += bitsToRead;
      if (this.bitOffset === 8) {
        this.byteOffset++;
        this.bitOffset = 0;
      }
    }
    return result;
  }
};
function calculateImageDimension(reader, isSmallImage) {
  if (isSmallImage) {
    return 8 * (1 + reader.getBits(5));
  }
  const sizeClass = reader.getBits(2);
  const extraBits = [9, 13, 18, 30][sizeClass];
  return 1 + reader.getBits(extraBits);
}
function calculateImageWidth(reader, isSmallImage, widthMode, height) {
  if (isSmallImage && widthMode === 0) {
    return 8 * (1 + reader.getBits(5));
  }
  if (widthMode === 0) {
    return calculateImageDimension(reader, false);
  }
  const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];
  return Math.floor(height * aspectRatios[widthMode - 1]);
}
var JXLStream = {
  validate: (input) => {
    return toHexString(input, 0, 2) === "ff0a";
  },
  calculate(input) {
    const reader = new BitReader(input, "little-endian");
    const isSmallImage = reader.getBits(1) === 1;
    const height = calculateImageDimension(reader, isSmallImage);
    const widthMode = reader.getBits(3);
    const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
    return { width, height };
  }
};
function extractCodestream(input) {
  const jxlcBox = findBox(input, "jxlc", 0);
  if (jxlcBox) {
    return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
  }
  const partialStreams = extractPartialStreams(input);
  if (partialStreams.length > 0) {
    return concatenateCodestreams(partialStreams);
  }
  return void 0;
}
function extractPartialStreams(input) {
  const partialStreams = [];
  let offset = 0;
  while (offset < input.length) {
    const jxlpBox = findBox(input, "jxlp", offset);
    if (!jxlpBox) break;
    partialStreams.push(
      input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size)
    );
    offset = jxlpBox.offset + jxlpBox.size;
  }
  return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
  const totalLength = partialCodestreams.reduce(
    (acc, curr) => acc + curr.length,
    0
  );
  const codestream = new Uint8Array(totalLength);
  let position = 0;
  for (const partial of partialCodestreams) {
    codestream.set(partial, position);
    position += partial.length;
  }
  return codestream;
}
var JXL = {
  validate: (input) => {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "JXL ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jxl ";
  },
  calculate(input) {
    const codestream = extractCodestream(input);
    if (codestream) return JXLStream.calculate(codestream);
    throw new Error("No codestream found in JXL container");
  }
};
var KTX = {
  validate: (input) => {
    const signature = toUTF8String(input, 1, 7);
    return ["KTX 11", "KTX 20"].includes(signature);
  },
  calculate: (input) => {
    const type = input[5] === 49 ? "ktx" : "ktx2";
    const offset = type === "ktx" ? 36 : 20;
    return {
      height: readUInt32LE(input, offset + 4),
      width: readUInt32LE(input, offset),
      type
    };
  }
};
var pngSignature = "PNG\r\n\n";
var pngImageHeaderChunkName = "IHDR";
var pngFriedChunkName = "CgBI";
var PNG = {
  validate(input) {
    if (pngSignature === toUTF8String(input, 1, 8)) {
      let chunkName = toUTF8String(input, 12, 16);
      if (chunkName === pngFriedChunkName) {
        chunkName = toUTF8String(input, 28, 32);
      }
      if (chunkName !== pngImageHeaderChunkName) {
        throw new TypeError("Invalid PNG");
      }
      return true;
    }
    return false;
  },
  calculate(input) {
    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
      return {
        height: readUInt32BE(input, 36),
        width: readUInt32BE(input, 32)
      };
    }
    return {
      height: readUInt32BE(input, 20),
      width: readUInt32BE(input, 16)
    };
  }
};
var PNMTypes = {
  P1: "pbm/ascii",
  P2: "pgm/ascii",
  P3: "ppm/ascii",
  P4: "pbm",
  P5: "pgm",
  P6: "ppm",
  P7: "pam",
  PF: "pfm"
};
var handlers = {
  default: (lines) => {
    let dimensions = [];
    while (lines.length > 0) {
      const line = lines.shift();
      if (line[0] === "#") {
        continue;
      }
      dimensions = line.split(" ");
      break;
    }
    if (dimensions.length === 2) {
      return {
        height: Number.parseInt(dimensions[1], 10),
        width: Number.parseInt(dimensions[0], 10)
      };
    }
    throw new TypeError("Invalid PNM");
  },
  pam: (lines) => {
    const size = {};
    while (lines.length > 0) {
      const line = lines.shift();
      if (line.length > 16 || line.charCodeAt(0) > 128) {
        continue;
      }
      const [key, value] = line.split(" ");
      if (key && value) {
        size[key.toLowerCase()] = Number.parseInt(value, 10);
      }
      if (size.height && size.width) {
        break;
      }
    }
    if (size.height && size.width) {
      return {
        height: size.height,
        width: size.width
      };
    }
    throw new TypeError("Invalid PAM");
  }
};
var PNM = {
  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,
  calculate(input) {
    const signature = toUTF8String(input, 0, 2);
    const type = PNMTypes[signature];
    const lines = toUTF8String(input, 3).split(/[\r\n]+/);
    const handler = handlers[type] || handlers.default;
    return handler(lines);
  }
};
var PSD = {
  validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
  calculate: (input) => ({
    height: readUInt32BE(input, 14),
    width: readUInt32BE(input, 18)
  })
};
var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
var extractorRegExps = {
  height: /\sheight=(['"])([^%]+?)\1/,
  root: svgReg,
  viewbox: /\sviewBox=(['"])(.+?)\1/i,
  width: /\swidth=(['"])([^%]+?)\1/
};
var INCH_CM = 2.54;
var units = {
  in: 96,
  cm: 96 / INCH_CM,
  em: 16,
  ex: 8,
  m: 96 / INCH_CM * 100,
  mm: 96 / INCH_CM / 10,
  pc: 96 / 72 / 12,
  pt: 96 / 72,
  px: 1
};
var unitsReg = new RegExp(
  `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
);
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return void 0;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root) {
  const width = root.match(extractorRegExps.width);
  const height = root.match(extractorRegExps.height);
  const viewbox = root.match(extractorRegExps.viewbox);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
var SVG = {
  // Scan only the first kilo-byte to speed up the check on larger files
  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),
  calculate(input) {
    const root = toUTF8String(input).match(extractorRegExps.root);
    if (root) {
      const attrs = parseAttributes(root[0]);
      if (attrs.width && attrs.height) {
        return calculateByDimensions(attrs);
      }
      if (attrs.viewbox) {
        return calculateByViewbox(attrs, attrs.viewbox);
      }
    }
    throw new TypeError("Invalid SVG");
  }
};
var TGA = {
  validate(input) {
    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
  },
  calculate(input) {
    return {
      height: readUInt16LE(input, 14),
      width: readUInt16LE(input, 12)
    };
  }
};
var CONSTANTS = {
  TAG: {
    WIDTH: 256,
    HEIGHT: 257,
    COMPRESSION: 259
  },
  TYPE: {
    SHORT: 3,
    LONG: 4,
    LONG8: 16
  },
  ENTRY_SIZE: {
    STANDARD: 12,
    BIG: 20
  },
  COUNT_SIZE: {
    STANDARD: 2,
    BIG: 8
  }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
  const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
  const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
  return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type, offset, isBigEndian) {
  switch (type) {
    case CONSTANTS.TYPE.SHORT:
      return readUInt(input, 16, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG:
      return readUInt(input, 32, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG8: {
      const value = Number(readUInt64(input, offset, isBigEndian));
      if (value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Value too large");
      }
      return value;
    }
    default:
      return 0;
  }
}
function nextTag(input, isBigTiff) {
  const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
  if (input.length > entrySize) {
    return input.slice(entrySize);
  }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
  const tags = {};
  let temp = input;
  while (temp == null ? void 0 : temp.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type = readUInt(temp, 16, 2, isBigEndian);
    const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) break;
    if (length === 1 && (type === CONSTANTS.TYPE.SHORT || type === CONSTANTS.TYPE.LONG || isBigTiff && type === CONSTANTS.TYPE.LONG8)) {
      const valueOffset = isBigTiff ? 12 : 8;
      tags[code] = readTagValue(temp, type, valueOffset, isBigEndian);
    }
    temp = nextTag(temp, isBigTiff);
  }
  return tags;
}
function determineFormat(input) {
  const signature = toUTF8String(input, 0, 2);
  const version = readUInt(input, 16, 2, signature === "MM");
  return {
    isBigEndian: signature === "MM",
    isBigTiff: version === 43
  };
}
function validateBigTIFFHeader(input, isBigEndian) {
  const byteSize = readUInt(input, 16, 4, isBigEndian);
  const reserved = readUInt(input, 16, 6, isBigEndian);
  if (byteSize !== 8 || reserved !== 0) {
    throw new TypeError("Invalid BigTIFF header");
  }
}
var signatures = /* @__PURE__ */ new Set([
  "49492a00",
  // Little Endian
  "4d4d002a",
  // Big Endian
  "49492b00",
  // BigTIFF Little Endian
  "4d4d002b"
  // BigTIFF Big Endian
]);
var TIFF = {
  validate: (input) => {
    const signature = toHexString(input, 0, 4);
    return signatures.has(signature);
  },
  calculate(input) {
    const format = determineFormat(input);
    if (format.isBigTiff) {
      validateBigTIFFHeader(input, format.isBigEndian);
    }
    const ifdBuffer = readIFD(input, format);
    const tags = extractTags(ifdBuffer, format);
    const info = {
      height: tags[CONSTANTS.TAG.HEIGHT],
      width: tags[CONSTANTS.TAG.WIDTH],
      type: format.isBigTiff ? "bigtiff" : "tiff"
    };
    if (tags[CONSTANTS.TAG.COMPRESSION]) {
      info.compression = tags[CONSTANTS.TAG.COMPRESSION];
    }
    if (!info.width || !info.height) {
      throw new TypeError("Invalid Tiff. Missing tags");
    }
    return info;
  }
};
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
var WEBP = {
  validate(input) {
    const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
    const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
    const vp8Header = "VP8" === toUTF8String(input, 12, 15);
    return riffHeader && webpHeader && vp8Header;
  },
  calculate(_input) {
    const chunkHeader = toUTF8String(_input, 12, 16);
    const input = _input.slice(20, 30);
    if (chunkHeader === "VP8X") {
      const extendedHeader = input[0];
      const validStart = (extendedHeader & 192) === 0;
      const validEnd = (extendedHeader & 1) === 0;
      if (validStart && validEnd) {
        return calculateExtended(input);
      }
      throw new TypeError("Invalid WebP");
    }
    if (chunkHeader === "VP8 " && input[0] !== 47) {
      return calculateLossy(input);
    }
    const signature = toHexString(input, 3, 6);
    if (chunkHeader === "VP8L" && signature !== "9d012a") {
      return calculateLossless(input);
    }
    throw new TypeError("Invalid WebP");
  }
};
var typeHandlers = /* @__PURE__ */ new Map([
  ["bmp", BMP],
  ["cur", CUR],
  ["dds", DDS],
  ["gif", GIF],
  ["heif", HEIF],
  ["icns", ICNS],
  ["ico", ICO],
  ["j2c", J2C],
  ["jp2", JP2],
  ["jpg", JPG],
  ["jxl", JXL],
  ["jxl-stream", JXLStream],
  ["ktx", KTX],
  ["png", PNG],
  ["pnm", PNM],
  ["psd", PSD],
  ["svg", SVG],
  ["tga", TGA],
  ["tiff", TIFF],
  ["webp", WEBP]
]);
var types = Array.from(typeHandlers.keys());
var firstBytes = /* @__PURE__ */ new Map([
  [0, "heif"],
  [56, "psd"],
  [66, "bmp"],
  [68, "dds"],
  [71, "gif"],
  [73, "tiff"],
  [77, "tiff"],
  [82, "webp"],
  [105, "icns"],
  [137, "png"],
  [255, "jpg"]
]);
function detector(input) {
  const byte = input[0];
  const type = firstBytes.get(byte);
  if (type && typeHandlers.get(type).validate(input)) {
    return type;
  }
  return types.find((type2) => typeHandlers.get(type2).validate(input));
}
var globalOptions = {
  disabledTypes: []
};
function imageSize(input) {
  const type = detector(input);
  if (typeof type !== "undefined") {
    if (globalOptions.disabledTypes.indexOf(type) > -1) {
      throw new TypeError(`disabled file type: ${type}`);
    }
    const size = typeHandlers.get(type).calculate(input);
    if (size !== void 0) {
      size.type = size.type ?? type;
      if (size.images && size.images.length > 1) {
        const largestImage = size.images.reduce((largest, current) => {
          return current.width * current.height > largest.width * largest.height ? current : largest;
        }, size.images[0]);
        size.width = largestImage.width;
        size.height = largestImage.height;
      }
      return size;
    }
  }
  throw new TypeError(`unsupported file type: ${type}`);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  const t = enumObject[enumTypeSymbol];
  assert(t, "missing enum type on enum object");
  return t;
}
function setEnumType(enumObject, typeName, values, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
    no: v.no,
    name: v.name,
    localName: enumObject[v.no]
  })), opt);
}
function makeEnumType(typeName, values, _opt) {
  const names = /* @__PURE__ */ Object.create(null);
  const numbers = /* @__PURE__ */ Object.create(null);
  const normalValues = [];
  for (const value of values) {
    const n = normalizeEnumValue(value);
    normalValues.push(n);
    names[value.name] = n;
    numbers[value.no] = n;
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(name) {
      return names[name];
    },
    findNumber(no) {
      return numbers[no];
    }
  };
}
function makeEnum(typeName, values, opt) {
  const enumObject = {};
  for (const value of values) {
    const n = normalizeEnumValue(value);
    enumObject[n.localName] = n.no;
    enumObject[n.no] = n.localName;
  }
  setEnumType(enumObject, typeName, values, opt);
  return enumObject;
}
function normalizeEnumValue(value) {
  if ("localName" in value) {
    return value;
  }
  return Object.assign(Object.assign({}, value), { localName: value.name });
}

// node_modules/@bufbuild/protobuf/dist/esm/message.js
var Message = class {
  /**
   * Compare with a message of the same type.
   * Note that this function disregards extensions and unknown fields.
   */
  equals(other) {
    return this.getType().runtime.util.equals(this.getType(), this, other);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(bytes, options) {
    const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
    return this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(jsonValue, options) {
    const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
    format.readMessage(type, jsonValue, opt, this);
    return this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(jsonString, options) {
    let json;
    try {
      json = JSON.parse(jsonString);
    } catch (e) {
      throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
    }
    return this.fromJson(json, options);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(options) {
    const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
    bin.writeMessage(this, writer, opt);
    return writer.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(options) {
    const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
    return json.writeMessage(this, opt);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(options) {
    var _a2;
    const value = this.toJson(options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: true
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
function makeMessageType(runtime, typeName, fields, opt) {
  var _a2;
  const localName2 = (_a2 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a2 !== void 0 ? _a2 : typeName.substring(typeName.lastIndexOf(".") + 1);
  const type = {
    [localName2]: function(data) {
      runtime.util.initFields(this);
      runtime.util.initPartial(data, this);
    }
  }[localName2];
  Object.setPrototypeOf(type.prototype, new Message());
  Object.assign(type, {
    runtime,
    typeName,
    fields: runtime.util.newFieldList(fields),
    fromBinary(bytes, options) {
      return new type().fromBinary(bytes, options);
    },
    fromJson(jsonValue, options) {
      return new type().fromJson(jsonValue, options);
    },
    fromJsonString(jsonString, options) {
      return new type().fromJsonString(jsonString, options);
    },
    equals(a, b) {
      return runtime.util.equals(type, a, b);
    }
  });
  return type;
}

// node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits2 = newBits(lo, hi);
  const negative = bits2.hi & 2147483648;
  if (negative) {
    bits2 = negate(bits2.lo, bits2.hi);
  }
  const result = uInt64ToString(bits2.lo, bits2.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`int64 invalid: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`uint64 invalid: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
  const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
var protoInt64 = makeInt64Support();

// node_modules/@bufbuild/protobuf/dist/esm/scalar.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (LongType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
function scalarEquals(type, a, b) {
  if (a === b) {
    return true;
  }
  if (type == ScalarType.BYTES) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  switch (type) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return a == b;
  }
  return false;
}
function scalarZeroValue(type, longType) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return longType == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(type, value) {
  switch (type) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      // eslint-disable-next-line
      // @ts-ignore TS7029: Fallthrough case in switch
      case WireType.Bit64:
        this.pos += 4;
      // eslint-disable-next-line
      // @ts-ignore TS7029: Fallthrough case in switch
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
function makeExtension(runtime, typeName, extendee, field) {
  let fi;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi) {
        const i = typeof field == "function" ? field() : field;
        i.name = typeName.split(".").pop();
        i.jsonName = `[${typeName}]`;
        fi = runtime.util.newFieldList([i]).list()[0];
      }
      return fi;
    },
    runtime
  };
}
function createExtensionContainer(extension) {
  const localName2 = extension.field.localName;
  const container = /* @__PURE__ */ Object.create(null);
  container[localName2] = initExtensionField(extension);
  return [container, () => container[localName2]];
}
function initExtensionField(ext) {
  const field = ext.field;
  if (field.repeated) {
    return [];
  }
  if (field.default !== void 0) {
    return field.default;
  }
  switch (field.kind) {
    case "enum":
      return field.T.values[0].no;
    case "scalar":
      return scalarZeroValue(field.T, field.L);
    case "message":
      const T = field.T, value = new T();
      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field) {
  if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
    for (let i = unknownFields.length - 1; i >= 0; --i) {
      if (unknownFields[i].no == field.no) {
        return [unknownFields[i]];
      }
    }
    return [];
  }
  return unknownFields.filter((uf) => uf.no === field.no);
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
var protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0; i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === void 0) {
        switch (base64Str[i]) {
          // @ts-ignore TS7029: Fallthrough case in switch
          case "=":
            groupPos = 0;
          // reset state when padding found
          // @ts-ignore TS7029: Fallthrough case in switch
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          // skip white-space, and padding
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(bytes) {
    let base64 = "", groupPos = 0, b, p = 0;
    for (let i = 0; i < bytes.length; i++) {
      b = bytes[i];
      switch (groupPos) {
        case 0:
          base64 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6];
          base64 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/extension-accessor.js
function getExtension(message, extension, options) {
  assertExtendee(extension, message);
  const opt = extension.runtime.bin.makeReadOptions(options);
  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
  const [container, get] = createExtensionContainer(extension);
  for (const uf of ufs) {
    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
  }
  return get();
}
function setExtension(message, extension, value, options) {
  assertExtendee(extension, message);
  const readOpt = extension.runtime.bin.makeReadOptions(options);
  const writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message, extension)) {
    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
    message.getType().runtime.bin.discardUnknownFields(message);
    for (const uf of ufs) {
      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
    }
  }
  const writer = writeOpt.writerFactory();
  let f = extension.field;
  if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
    f = Object.assign(Object.assign({}, extension.field), { opt: true });
  }
  extension.runtime.bin.writeField(f, value, writer, writeOpt);
  const reader = readOpt.readerFactory(writer.finish());
  while (reader.pos < reader.len) {
    const [no, wireType] = reader.tag();
    const data = reader.skip(wireType, no);
    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
  }
}
function hasExtension(message, extension) {
  const messageType = message.getType();
  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
}
function assertExtendee(extension, message) {
  assert(extension.extendee.typeName == message.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/reflect.js
function isFieldSet(field, target) {
  const localName2 = field.localName;
  if (field.repeated) {
    return target[localName2].length > 0;
  }
  if (field.oneof) {
    return target[field.oneof.localName].case === localName2;
  }
  switch (field.kind) {
    case "enum":
    case "scalar":
      if (field.opt || field.req) {
        return target[localName2] !== void 0;
      }
      if (field.kind == "enum") {
        return target[localName2] !== field.T.values[0].no;
      }
      return !isScalarZeroValue(field.T, target[localName2]);
    case "message":
      return target[localName2] !== void 0;
    case "map":
      return Object.keys(target[localName2]).length > 0;
  }
}
function clearField(field, target) {
  const localName2 = field.localName;
  const implicitPresence = !field.opt && !field.req;
  if (field.repeated) {
    target[localName2] = [];
  } else if (field.oneof) {
    target[field.oneof.localName] = { case: void 0 };
  } else {
    switch (field.kind) {
      case "map":
        target[localName2] = {};
        break;
      case "enum":
        target[localName2] = implicitPresence ? field.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName2] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
        break;
      case "message":
        target[localName2] = void 0;
        break;
    }
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/is-message.js
function isMessage(arg, type) {
  if (arg === null || typeof arg != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(Message.prototype).every((m) => m in arg && typeof arg[m] == "function")) {
    return false;
  }
  const actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type === void 0 ? true : actualType.typeName == type.typeName;
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
function wrapField(type, value) {
  if (isMessage(value) || !type.fieldWrapper) {
    return value;
  }
  return type.fieldWrapper.wrapField(value);
}
var wktWrapperToScalarType = {
  "google.protobuf.DoubleValue": ScalarType.DOUBLE,
  "google.protobuf.FloatValue": ScalarType.FLOAT,
  "google.protobuf.Int64Value": ScalarType.INT64,
  "google.protobuf.UInt64Value": ScalarType.UINT64,
  "google.protobuf.Int32Value": ScalarType.INT32,
  "google.protobuf.UInt32Value": ScalarType.UINT32,
  "google.protobuf.BoolValue": ScalarType.BOOL,
  "google.protobuf.StringValue": ScalarType.STRING,
  "google.protobuf.BytesValue": ScalarType.BYTES
};

// node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
var jsonReadDefaults = {
  ignoreUnknownFields: false
};
var jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
var tokenNull = Symbol();
var tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(type, json, options, message) {
      if (json == null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
      }
      message = message !== null && message !== void 0 ? message : new type();
      const oneofSeen = /* @__PURE__ */ new Map();
      const registry = options.typeRegistry;
      for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field = type.fields.findJsonName(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen.set(field.oneof, jsonKey);
          }
          readField(message, jsonValue, field, options, type);
        } else {
          let found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type.typeName) {
              found = true;
              const [container, get] = createExtensionContainer(ext);
              readField(container, jsonValue, ext.field, options, ext);
              setExtension(message, ext, get(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
          }
        }
      }
      return message;
    },
    writeMessage(message, options) {
      const type = message.getType();
      const json = {};
      let field;
      try {
        for (field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw `required field not set`;
            }
            if (!options.emitDefaultValues) {
              continue;
            }
            if (!canEmitFieldDefaultValue(field)) {
              continue;
            }
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          const jsonValue = writeField(field, value, options);
          if (jsonValue !== void 0) {
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
          }
        }
        const registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          for (const uf of type.runtime.bin.listUnknownFields(message)) {
            const ext = registry.findExtensionFor(type.typeName, uf.no);
            if (ext && hasExtension(message, ext)) {
              const value = getExtension(message, ext, options);
              const jsonValue = writeField(ext.field, value, options);
              if (jsonValue !== void 0) {
                json[ext.field.jsonName] = jsonValue;
              }
            }
          }
        }
      } catch (e) {
        const m = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
        const r = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
      }
      return json;
    },
    readScalar(type, json, longType) {
      return readScalar(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
    },
    writeScalar(type, value, emitDefaultValues) {
      if (value === void 0) {
        return void 0;
      }
      if (emitDefaultValues || isScalarZeroValue(type, value)) {
        return writeScalar(type, value);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
function debugJsonValue(json) {
  if (json === null) {
    return "null";
  }
  switch (typeof json) {
    case "object":
      return Array.isArray(json) ? "array" : "object";
    case "string":
      return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
    default:
      return String(json);
  }
}
function readField(target, jsonValue, field, options, parentType) {
  let localName2 = field.localName;
  if (field.repeated) {
    assert(field.kind != "map");
    if (jsonValue === null) {
      return;
    }
    if (!Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetArray = target[localName2];
    for (const jsonItem of jsonValue) {
      if (jsonItem === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
      }
      switch (field.kind) {
        case "message":
          targetArray.push(field.T.fromJson(jsonItem, options));
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetArray.push(enumValue);
          }
          break;
        case "scalar":
          try {
            targetArray.push(readScalar(field.T, jsonItem, field.L, true));
          } catch (e) {
            let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else if (field.kind == "map") {
    if (jsonValue === null) {
      return;
    }
    if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetMap = target[localName2];
    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
      if (jsonMapValue === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
      }
      let key;
      try {
        key = readMapKey(field.K, jsonMapKey);
      } catch (e) {
        let m = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
        if (e instanceof Error && e.message.length > 0) {
          m += `: ${e.message}`;
        }
        throw new Error(m);
      }
      switch (field.V.kind) {
        case "message":
          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key] = enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key] = readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
          } catch (e) {
            let m = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else {
    if (field.oneof) {
      target = target[field.oneof.localName] = { case: localName2 };
      localName2 = "value";
    }
    switch (field.kind) {
      case "message":
        const messageType = field.T;
        if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
          return;
        }
        let currentValue = target[localName2];
        if (isMessage(currentValue)) {
          currentValue.fromJson(jsonValue, options);
        } else {
          target[localName2] = currentValue = messageType.fromJson(jsonValue, options);
          if (messageType.fieldWrapper && !field.oneof) {
            target[localName2] = messageType.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
        switch (enumValue) {
          case tokenNull:
            clearField(field, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName2] = enumValue;
            break;
        }
        break;
      case "scalar":
        try {
          const scalarValue = readScalar(field.T, jsonValue, field.L, false);
          switch (scalarValue) {
            case tokenNull:
              clearField(field, target);
              break;
            default:
              target[localName2] = scalarValue;
              break;
          }
        } catch (e) {
          let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m += `: ${e.message}`;
          }
          throw new Error(m);
        }
        break;
    }
  }
}
function readMapKey(type, json) {
  if (type === ScalarType.BOOL) {
    switch (json) {
      case "true":
        json = true;
        break;
      case "false":
        json = false;
        break;
    }
  }
  return readScalar(type, json, LongType.BIGINT, true).toString();
}
function readScalar(type, json, longType, nullAsZeroValue) {
  if (json === null) {
    if (nullAsZeroValue) {
      return scalarZeroValue(type, longType);
    }
    return tokenNull;
  }
  switch (type) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (json === "NaN")
        return Number.NaN;
      if (json === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (json === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (json === "") {
        break;
      }
      if (typeof json == "string" && json.trim().length !== json.length) {
        break;
      }
      if (typeof json != "string" && typeof json != "number") {
        break;
      }
      const float = Number(json);
      if (Number.isNaN(float)) {
        break;
      }
      if (!Number.isFinite(float)) {
        break;
      }
      if (type == ScalarType.FLOAT)
        assertFloat32(float);
      return float;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      let int32;
      if (typeof json == "number")
        int32 = json;
      else if (typeof json == "string" && json.length > 0) {
        if (json.trim().length === json.length)
          int32 = Number(json);
      }
      if (int32 === void 0)
        break;
      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
        assertUInt32(int32);
      else
        assertInt32(int32);
      return int32;
    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const long = protoInt64.parse(json);
      return longType ? long.toString() : long;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const uLong = protoInt64.uParse(json);
      return longType ? uLong.toString() : uLong;
    // bool:
    case ScalarType.BOOL:
      if (typeof json !== "boolean")
        break;
      return json;
    // string:
    case ScalarType.STRING:
      if (typeof json !== "string") {
        break;
      }
      try {
        encodeURIComponent(json);
      } catch (e) {
        throw new Error("invalid UTF8");
      }
      return json;
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case ScalarType.BYTES:
      if (json === "")
        return new Uint8Array(0);
      if (typeof json !== "string")
        break;
      return protoBase64.dec(json);
  }
  throw new Error();
}
function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
  if (json === null) {
    if (type.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type.values[0].no : tokenNull;
  }
  switch (typeof json) {
    case "number":
      if (Number.isInteger(json)) {
        return json;
      }
      break;
    case "string":
      const value = type.findName(json);
      if (value !== void 0) {
        return value.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
}
function canEmitFieldDefaultValue(field) {
  if (field.repeated || field.kind == "map") {
    return true;
  }
  if (field.oneof) {
    return false;
  }
  if (field.kind == "message") {
    return false;
  }
  if (field.opt || field.req) {
    return false;
  }
  return true;
}
function writeField(field, value, options) {
  if (field.kind == "map") {
    assert(typeof value == "object" && value != null);
    const jsonObj = {};
    const entries = Object.entries(value);
    switch (field.V.kind) {
      case "scalar":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeScalar(field.V.T, entryValue);
        }
        break;
      case "message":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = entryValue.toJson(options);
        }
        break;
      case "enum":
        const enumType = field.V.T;
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
        }
        break;
    }
    return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
  }
  if (field.repeated) {
    assert(Array.isArray(value));
    const jsonArr = [];
    switch (field.kind) {
      case "scalar":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeScalar(field.T, value[i]));
        }
        break;
      case "enum":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
        }
        break;
      case "message":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(value[i].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field.kind) {
    case "scalar":
      return writeScalar(field.T, value);
    case "enum":
      return writeEnum(field.T, value, options.enumAsInteger);
    case "message":
      return wrapField(field.T, value).toJson(options);
  }
}
function writeEnum(type, value, enumAsInteger) {
  var _a2;
  assert(typeof value == "number");
  if (type.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value;
  }
  const val = type.findNumber(value);
  return (_a2 = val === null || val === void 0 ? void 0 : val.name) !== null && _a2 !== void 0 ? _a2 : value;
}
function writeScalar(type, value) {
  switch (type) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      assert(typeof value == "number");
      return value;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case ScalarType.FLOAT:
    // assertFloat32(value);
    case ScalarType.DOUBLE:
      assert(typeof value == "number");
      if (Number.isNaN(value))
        return "NaN";
      if (value === Number.POSITIVE_INFINITY)
        return "Infinity";
      if (value === Number.NEGATIVE_INFINITY)
        return "-Infinity";
      return value;
    // string:
    case ScalarType.STRING:
      assert(typeof value == "string");
      return value;
    // bool:
    case ScalarType.BOOL:
      assert(typeof value == "boolean");
      return value;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
      return value.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case ScalarType.BYTES:
      assert(value instanceof Uint8Array);
      return protoBase64.enc(value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/private/binary-format.js
var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
var readDefaults = {
  readUnknownFields: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
var writeDefaults = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions2(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions2(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions: makeReadOptions2,
    makeWriteOptions: makeWriteOptions2,
    listUnknownFields(message) {
      var _a2;
      return (_a2 = message[unknownFieldsSymbol]) !== null && _a2 !== void 0 ? _a2 : [];
    },
    discardUnknownFields(message) {
      delete message[unknownFieldsSymbol];
    },
    writeUnknownFields(message, writer) {
      const m = message;
      const c = m[unknownFieldsSymbol];
      if (c) {
        for (const f of c) {
          writer.tag(f.no, f.wireType).raw(f.data);
        }
      }
    },
    onUnknownField(message, no, wireType, data) {
      const m = message;
      if (!Array.isArray(m[unknownFieldsSymbol])) {
        m[unknownFieldsSymbol] = [];
      }
      m[unknownFieldsSymbol].push({ no, wireType, data });
    },
    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      const type = message.getType();
      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      let fieldNo, wireType;
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
          break;
        }
        const field = type.fields.find(fieldNo);
        if (!field) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            this.onUnknownField(message, fieldNo, wireType, data);
          }
          continue;
        }
        readField2(message, reader, field, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error(`invalid end group tag`);
      }
    },
    readField: readField2,
    writeMessage(message, writer, options) {
      const type = message.getType();
      for (const field of type.fields.byNumber()) {
        if (!isFieldSet(field, message)) {
          if (field.req) {
            throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
          }
          continue;
        }
        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
        writeField2(field, value, writer, options);
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer);
      }
      return writer;
    },
    writeField(field, value, writer, options) {
      if (value === void 0) {
        return void 0;
      }
      writeField2(field, value, writer, options);
    }
  };
}
function readField2(target, reader, field, wireType, options) {
  let { repeated, localName: localName2 } = field;
  if (field.oneof) {
    target = target[field.oneof.localName];
    if (target.case != localName2) {
      delete target.value;
    }
    target.case = localName2;
    localName2 = "value";
  }
  switch (field.kind) {
    case "scalar":
    case "enum":
      const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      let read = readScalar2;
      if (field.kind == "scalar" && field.L > 0) {
        read = readScalarLTString;
      }
      if (repeated) {
        let arr = target[localName2];
        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
        if (isPacked) {
          let e = reader.uint32() + reader.pos;
          while (reader.pos < e) {
            arr.push(read(reader, scalarType));
          }
        } else {
          arr.push(read(reader, scalarType));
        }
      } else {
        target[localName2] = read(reader, scalarType);
      }
      break;
    case "message":
      const messageType = field.T;
      if (repeated) {
        target[localName2].push(readMessageField(reader, new messageType(), options, field));
      } else {
        if (isMessage(target[localName2])) {
          readMessageField(reader, target[localName2], options, field);
        } else {
          target[localName2] = readMessageField(reader, new messageType(), options, field);
          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
            target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
          }
        }
      }
      break;
    case "map":
      let [mapKey, mapVal] = readMapEntry(field, reader, options);
      target[localName2][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message, options, field) {
  const format = message.getType().runtime.bin;
  const delimited = field === null || field === void 0 ? void 0 : field.delimited;
  format.readMessage(
    message,
    reader,
    delimited ? field.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message;
}
function readMapEntry(field, reader, options) {
  const length = reader.uint32(), end = reader.pos + length;
  let key, val;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar2(reader, field.K);
        break;
      case 2:
        switch (field.V.kind) {
          case "scalar":
            val = readScalar2(reader, field.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.K, LongType.BIGINT);
  }
  if (typeof key != "string" && typeof key != "number") {
    key = key.toString();
  }
  if (val === void 0) {
    switch (field.V.kind) {
      case "scalar":
        val = scalarZeroValue(field.V.T, LongType.BIGINT);
        break;
      case "enum":
        val = field.V.T.values[0].no;
        break;
      case "message":
        val = new field.V.T();
        break;
    }
  }
  return [key, val];
}
function readScalarLTString(reader, type) {
  const v = readScalar2(reader, type);
  return typeof v == "bigint" ? v.toString() : v;
}
function readScalar2(reader, type) {
  switch (type) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
function writeField2(field, value, writer, options) {
  assert(value !== void 0);
  const repeated = field.repeated;
  switch (field.kind) {
    case "scalar":
    case "enum":
      let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      if (repeated) {
        assert(Array.isArray(value));
        if (field.packed) {
          writePacked(writer, scalarType, field.no, value);
        } else {
          for (const item of value) {
            writeScalar2(writer, scalarType, field.no, item);
          }
        }
      } else {
        writeScalar2(writer, scalarType, field.no, value);
      }
      break;
    case "message":
      if (repeated) {
        assert(Array.isArray(value));
        for (const item of value) {
          writeMessageField(writer, options, field, item);
        }
      } else {
        writeMessageField(writer, options, field, value);
      }
      break;
    case "map":
      assert(typeof value == "object" && value != null);
      for (const [key, val] of Object.entries(value)) {
        writeMapEntry(writer, options, field, key, val);
      }
      break;
  }
}
function writeMapEntry(writer, options, field, key, value) {
  writer.tag(field.no, WireType.LengthDelimited);
  writer.fork();
  let keyValue = key;
  switch (field.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      keyValue = Number.parseInt(key);
      break;
    case ScalarType.BOOL:
      assert(key == "true" || key == "false");
      keyValue = key == "true";
      break;
  }
  writeScalar2(writer, field.K, 1, keyValue);
  switch (field.V.kind) {
    case "scalar":
      writeScalar2(writer, field.V.T, 2, value);
      break;
    case "enum":
      writeScalar2(writer, ScalarType.INT32, 2, value);
      break;
    case "message":
      assert(value !== void 0);
      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
      break;
  }
  writer.join();
}
function writeMessageField(writer, options, field, value) {
  const message = wrapField(field.T, value);
  if (field.delimited)
    writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
  else
    writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
}
function writeScalar2(writer, type, fieldNo, value) {
  assert(value !== void 0);
  let [wireType, method] = scalarTypeInfo(type);
  writer.tag(fieldNo, wireType)[method](value);
}
function writePacked(writer, type, fieldNo, value) {
  if (!value.length) {
    return;
  }
  writer.tag(fieldNo, WireType.LengthDelimited).fork();
  let [, method] = scalarTypeInfo(type);
  for (let i = 0; i < value.length; i++) {
    writer[method](value[i]);
  }
  writer.join();
}
function scalarTypeInfo(type) {
  let wireType = WireType.Varint;
  switch (type) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      wireType = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      wireType = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      wireType = WireType.Bit32;
      break;
  }
  const method = ScalarType[type].toLowerCase();
  return [wireType, method];
}

// node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      const type = target.getType();
      for (const member of type.fields.byMember()) {
        const localName2 = member.localName, t = target, s = source;
        if (s[localName2] == null) {
          continue;
        }
        switch (member.kind) {
          case "oneof":
            const sk = s[localName2].case;
            if (sk === void 0) {
              continue;
            }
            const sourceField = member.findField(sk);
            let val = s[localName2].value;
            if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
              val = new sourceField.T(val);
            } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
              val = toU8Arr(val);
            }
            t[localName2] = { case: sk, value: val };
            break;
          case "scalar":
          case "enum":
            let copy = s[localName2];
            if (member.T === ScalarType.BYTES) {
              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
            }
            t[localName2] = copy;
            break;
          case "map":
            switch (member.V.kind) {
              case "scalar":
              case "enum":
                if (member.V.T === ScalarType.BYTES) {
                  for (const [k, v] of Object.entries(s[localName2])) {
                    t[localName2][k] = toU8Arr(v);
                  }
                } else {
                  Object.assign(t[localName2], s[localName2]);
                }
                break;
              case "message":
                const messageType = member.V.T;
                for (const k of Object.keys(s[localName2])) {
                  let val2 = s[localName2][k];
                  if (!messageType.fieldWrapper) {
                    val2 = new messageType(val2);
                  }
                  t[localName2][k] = val2;
                }
                break;
            }
            break;
          case "message":
            const mt = member.T;
            if (member.repeated) {
              t[localName2] = s[localName2].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
            } else {
              const val2 = s[localName2];
              if (mt.fieldWrapper) {
                if (
                  // We can't use BytesValue.typeName as that will create a circular import
                  mt.typeName === "google.protobuf.BytesValue"
                ) {
                  t[localName2] = toU8Arr(val2);
                } else {
                  t[localName2] = val2;
                }
              } else {
                t[localName2] = isMessage(val2, mt) ? val2 : new mt(val2);
              }
            }
            break;
        }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return type.fields.byMember().every((m) => {
        const va = a[m.localName];
        const vb = b[m.localName];
        if (m.repeated) {
          if (va.length !== vb.length) {
            return false;
          }
          switch (m.kind) {
            case "message":
              return va.every((a2, i) => m.T.equals(a2, vb[i]));
            case "scalar":
              return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
            case "enum":
              return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
          }
          throw new Error(`repeated cannot contain ${m.kind}`);
        }
        switch (m.kind) {
          case "message":
            let a2 = va;
            let b3 = vb;
            if (m.T.fieldWrapper) {
              if (a2 !== void 0 && !isMessage(a2)) {
                a2 = m.T.fieldWrapper.wrapField(a2);
              }
              if (b3 !== void 0 && !isMessage(b3)) {
                b3 = m.T.fieldWrapper.wrapField(b3);
              }
            }
            return m.T.equals(a2, b3);
          case "enum":
            return scalarEquals(ScalarType.INT32, va, vb);
          case "scalar":
            return scalarEquals(m.T, va, vb);
          case "oneof":
            if (va.case !== vb.case) {
              return false;
            }
            const s = m.findField(va.case);
            if (s === void 0) {
              return true;
            }
            switch (s.kind) {
              case "message":
                return s.T.equals(va.value, vb.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, va.value, vb.value);
              case "scalar":
                return scalarEquals(s.T, va.value, vb.value);
            }
            throw new Error(`oneof cannot contain ${s.kind}`);
          case "map":
            const keys = Object.keys(va).concat(Object.keys(vb));
            switch (m.V.kind) {
              case "message":
                const messageType = m.V.T;
                return keys.every((k) => messageType.equals(va[k], vb[k]));
              case "enum":
                return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
              case "scalar":
                const scalarType = m.V.T;
                return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(message) {
      const type = message.getType(), target = new type(), any = target;
      for (const member of type.fields.byMember()) {
        const source = message[member.localName];
        let copy;
        if (member.repeated) {
          copy = source.map(cloneSingularField);
        } else if (member.kind == "map") {
          copy = any[member.localName];
          for (const [key, v] of Object.entries(source)) {
            copy[key] = cloneSingularField(v);
          }
        } else if (member.kind == "oneof") {
          const f = member.findField(source.case);
          copy = f ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
        } else {
          copy = cloneSingularField(source);
        }
        any[member.localName] = copy;
      }
      for (const uf of type.runtime.bin.listUnknownFields(message)) {
        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
      }
      return target;
    }
  };
}
function cloneSingularField(value) {
  if (value === void 0) {
    return value;
  }
  if (isMessage(value)) {
    return value.clone();
  }
  if (value instanceof Uint8Array) {
    const c = new Uint8Array(value.byteLength);
    c.set(value);
    return c;
  }
  return value;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList,
      initFields
    }),
    makeMessageType(typeName, fields, opt) {
      return makeMessageType(this, typeName, fields, opt);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(typeName, extendee, field) {
      return makeExtension(this, typeName, extendee, field);
    }
  };
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
var InternalFieldList = class {
  constructor(fields, normalizer) {
    this._fields = fields;
    this._normalizer = normalizer;
  }
  findJsonName(jsonName) {
    if (!this.jsonNames) {
      const t = {};
      for (const f of this.list()) {
        t[f.jsonName] = t[f.name] = f;
      }
      this.jsonNames = t;
    }
    return this.jsonNames[jsonName];
  }
  find(fieldNo) {
    if (!this.numbers) {
      const t = {};
      for (const f of this.list()) {
        t[f.no] = f;
      }
      this.numbers = t;
    }
    return this.numbers[fieldNo];
  }
  list() {
    if (!this.all) {
      this.all = this._normalizer(this._fields);
    }
    return this.all;
  }
  byNumber() {
    if (!this.numbersAsc) {
      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
    }
    return this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const a = this.members;
      let o;
      for (const f of this.list()) {
        if (f.oneof) {
          if (f.oneof !== o) {
            o = f.oneof;
            a.push(o);
          }
        } else {
          a.push(f);
        }
      }
    }
    return this.members;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/names.js
function localFieldName(protoName, inOneof) {
  const name = protoCamelCase(protoName);
  if (inOneof) {
    return name;
  }
  return safeObjectProperty(safeMessageProperty(name));
}
function localOneofName(protoName) {
  return localFieldName(protoName, false);
}
var fieldJsonName = protoCamelCase;
function protoCamelCase(snakeCase) {
  let capNext = false;
  const b = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let c = snakeCase.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b.push(c);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        b.push(c);
        break;
    }
  }
  return b.join("");
}
var reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
var reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]);
var fallback = (name) => `${name}$`;
var safeMessageProperty = (name) => {
  if (reservedMessageProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var safeObjectProperty = (name) => {
  if (reservedObjectProperties.has(name)) {
    return fallback(name);
  }
  return name;
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field.js
var InternalOneofInfo = class {
  constructor(name) {
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this.default = void 0;
    this.fields = [];
    this.name = name;
    this.localName = localOneofName(name);
  }
  addField(field) {
    assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
    this.fields.push(field);
  }
  findField(localName2) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < this.fields.length; i++) {
        this._lookup[this.fields[i].localName] = this.fields[i];
      }
    }
    return this._lookup[localName2];
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a2, _b2, _c, _d, _e, _f;
  const r = [];
  let o;
  for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
    const f = field;
    f.localName = localFieldName(field.name, field.oneof !== void 0);
    f.jsonName = (_a2 = field.jsonName) !== null && _a2 !== void 0 ? _a2 : fieldJsonName(field.name);
    f.repeated = (_b2 = field.repeated) !== null && _b2 !== void 0 ? _b2 : false;
    if (field.kind == "scalar") {
      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
    }
    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
    if (field.packed === void 0) {
      if (packedByDefault) {
        f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      } else {
        f.packed = false;
      }
    }
    if (field.oneof !== void 0) {
      const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
      if (!o || o.name != ooname) {
        o = new InternalOneofInfo(ooname);
      }
      f.oneof = o;
      o.addField(f);
    }
    r.push(f);
  }
  return r;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto3.js
var proto3 = makeProtoRuntime(
  "proto3",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      if (member.opt) {
        continue;
      }
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "enum":
          t[name] = 0;
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
          t[name] = scalarZeroValue(member.T, member.L);
          break;
        case "message":
          break;
      }
    }
  }
);

// node_modules/@bufbuild/protobuf/dist/esm/proto2.js
var proto2 = makeProtoRuntime(
  "proto2",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, false));
  },
  // TODO merge with proto3 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
        case "enum":
        case "message":
          break;
      }
    }
  }
);

// node_modules/@bufbuild/protobuf/dist/esm/proto-double.js
var protoDouble = {
  NaN: Number.NaN,
  POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
  NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY
};

// node_modules/@bufbuild/protobuf/dist/esm/service-type.js
var MethodKind;
(function(MethodKind2) {
  MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
  MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
  MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
  MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
})(MethodKind || (MethodKind = {}));
var MethodIdempotency;
(function(MethodIdempotency2) {
  MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
  MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
})(MethodIdempotency || (MethodIdempotency = {}));

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js
var Edition;
(function(Edition2) {
  Edition2[Edition2["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
  Edition2[Edition2["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
  Edition2[Edition2["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
  Edition2[Edition2["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
  Edition2[Edition2["EDITION_2023"] = 1e3] = "EDITION_2023";
  Edition2[Edition2["EDITION_2024"] = 1001] = "EDITION_2024";
  Edition2[Edition2["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
  Edition2[Edition2["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
  Edition2[Edition2["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
  Edition2[Edition2["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
  Edition2[Edition2["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
  Edition2[Edition2["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
})(Edition || (Edition = {}));
proto2.util.setEnumType(Edition, "google.protobuf.Edition", [
  { no: 0, name: "EDITION_UNKNOWN" },
  { no: 900, name: "EDITION_LEGACY" },
  { no: 998, name: "EDITION_PROTO2" },
  { no: 999, name: "EDITION_PROTO3" },
  { no: 1e3, name: "EDITION_2023" },
  { no: 1001, name: "EDITION_2024" },
  { no: 1, name: "EDITION_1_TEST_ONLY" },
  { no: 2, name: "EDITION_2_TEST_ONLY" },
  { no: 99997, name: "EDITION_99997_TEST_ONLY" },
  { no: 99998, name: "EDITION_99998_TEST_ONLY" },
  { no: 99999, name: "EDITION_99999_TEST_ONLY" },
  { no: 2147483647, name: "EDITION_MAX" }
]);
var FileDescriptorSet = class _FileDescriptorSet extends Message {
  constructor(data) {
    super();
    this.file = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileDescriptorSet().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FileDescriptorSet().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileDescriptorSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FileDescriptorSet, a, b);
  }
};
FileDescriptorSet.runtime = proto2;
FileDescriptorSet.typeName = "google.protobuf.FileDescriptorSet";
FileDescriptorSet.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "file", kind: "message", T: FileDescriptorProto, repeated: true }
]);
var FileDescriptorProto = class _FileDescriptorProto extends Message {
  constructor(data) {
    super();
    this.dependency = [];
    this.publicDependency = [];
    this.weakDependency = [];
    this.messageType = [];
    this.enumType = [];
    this.service = [];
    this.extension = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FileDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FileDescriptorProto, a, b);
  }
};
FileDescriptorProto.runtime = proto2;
FileDescriptorProto.typeName = "google.protobuf.FileDescriptorProto";
FileDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "package", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: true },
  { no: 10, name: "public_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 4, name: "message_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 5, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 6, name: "service", kind: "message", T: ServiceDescriptorProto, repeated: true },
  { no: 7, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 8, name: "options", kind: "message", T: FileOptions, opt: true },
  { no: 9, name: "source_code_info", kind: "message", T: SourceCodeInfo, opt: true },
  { no: 12, name: "syntax", kind: "scalar", T: 9, opt: true },
  { no: 14, name: "edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true }
]);
var DescriptorProto = class _DescriptorProto extends Message {
  constructor(data) {
    super();
    this.field = [];
    this.extension = [];
    this.nestedType = [];
    this.enumType = [];
    this.extensionRange = [];
    this.oneofDecl = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_DescriptorProto, a, b);
  }
};
DescriptorProto.runtime = proto2;
DescriptorProto.typeName = "google.protobuf.DescriptorProto";
DescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "field", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 6, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 3, name: "nested_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 4, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 5, name: "extension_range", kind: "message", T: DescriptorProto_ExtensionRange, repeated: true },
  { no: 8, name: "oneof_decl", kind: "message", T: OneofDescriptorProto, repeated: true },
  { no: 7, name: "options", kind: "message", T: MessageOptions, opt: true },
  { no: 9, name: "reserved_range", kind: "message", T: DescriptorProto_ReservedRange, repeated: true },
  { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
var DescriptorProto_ExtensionRange = class _DescriptorProto_ExtensionRange extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto_ExtensionRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DescriptorProto_ExtensionRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_DescriptorProto_ExtensionRange, a, b);
  }
};
DescriptorProto_ExtensionRange.runtime = proto2;
DescriptorProto_ExtensionRange.typeName = "google.protobuf.DescriptorProto.ExtensionRange";
DescriptorProto_ExtensionRange.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: ExtensionRangeOptions, opt: true }
]);
var DescriptorProto_ReservedRange = class _DescriptorProto_ReservedRange extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto_ReservedRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DescriptorProto_ReservedRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto_ReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_DescriptorProto_ReservedRange, a, b);
  }
};
DescriptorProto_ReservedRange.runtime = proto2;
DescriptorProto_ReservedRange.typeName = "google.protobuf.DescriptorProto.ReservedRange";
DescriptorProto_ReservedRange.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
var ExtensionRangeOptions = class _ExtensionRangeOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    this.declaration = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ExtensionRangeOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ExtensionRangeOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ExtensionRangeOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ExtensionRangeOptions, a, b);
  }
};
ExtensionRangeOptions.runtime = proto2;
ExtensionRangeOptions.typeName = "google.protobuf.ExtensionRangeOptions";
ExtensionRangeOptions.fields = proto2.util.newFieldList(() => [
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true },
  { no: 2, name: "declaration", kind: "message", T: ExtensionRangeOptions_Declaration, repeated: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "verification", kind: "enum", T: proto2.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED }
]);
var ExtensionRangeOptions_VerificationState;
(function(ExtensionRangeOptions_VerificationState2) {
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
})(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));
proto2.util.setEnumType(ExtensionRangeOptions_VerificationState, "google.protobuf.ExtensionRangeOptions.VerificationState", [
  { no: 0, name: "DECLARATION" },
  { no: 1, name: "UNVERIFIED" }
]);
var ExtensionRangeOptions_Declaration = class _ExtensionRangeOptions_Declaration extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ExtensionRangeOptions_Declaration().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ExtensionRangeOptions_Declaration().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ExtensionRangeOptions_Declaration, a, b);
  }
};
ExtensionRangeOptions_Declaration.runtime = proto2;
ExtensionRangeOptions_Declaration.typeName = "google.protobuf.ExtensionRangeOptions.Declaration";
ExtensionRangeOptions_Declaration.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "full_name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "type", kind: "scalar", T: 9, opt: true },
  { no: 5, name: "reserved", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "repeated", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto = class _FieldDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldDescriptorProto, a, b);
  }
};
FieldDescriptorProto.runtime = proto2;
FieldDescriptorProto.typeName = "google.protobuf.FieldDescriptorProto";
FieldDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "label", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Label), opt: true },
  { no: 5, name: "type", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Type), opt: true },
  { no: 6, name: "type_name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "extendee", kind: "scalar", T: 9, opt: true },
  { no: 7, name: "default_value", kind: "scalar", T: 9, opt: true },
  { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: true },
  { no: 10, name: "json_name", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "options", kind: "message", T: FieldOptions, opt: true },
  { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
proto2.util.setEnumType(FieldDescriptorProto_Type, "google.protobuf.FieldDescriptorProto.Type", [
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
proto2.util.setEnumType(FieldDescriptorProto_Label, "google.protobuf.FieldDescriptorProto.Label", [
  { no: 1, name: "LABEL_OPTIONAL" },
  { no: 3, name: "LABEL_REPEATED" },
  { no: 2, name: "LABEL_REQUIRED" }
]);
var OneofDescriptorProto = class _OneofDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _OneofDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _OneofDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _OneofDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_OneofDescriptorProto, a, b);
  }
};
OneofDescriptorProto.runtime = proto2;
OneofDescriptorProto.typeName = "google.protobuf.OneofDescriptorProto";
OneofDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "options", kind: "message", T: OneofOptions, opt: true }
]);
var EnumDescriptorProto = class _EnumDescriptorProto extends Message {
  constructor(data) {
    super();
    this.value = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumDescriptorProto, a, b);
  }
};
EnumDescriptorProto.runtime = proto2;
EnumDescriptorProto.typeName = "google.protobuf.EnumDescriptorProto";
EnumDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "value", kind: "message", T: EnumValueDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: EnumOptions, opt: true },
  { no: 4, name: "reserved_range", kind: "message", T: EnumDescriptorProto_EnumReservedRange, repeated: true },
  { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
var EnumDescriptorProto_EnumReservedRange = class _EnumDescriptorProto_EnumReservedRange extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumDescriptorProto_EnumReservedRange, a, b);
  }
};
EnumDescriptorProto_EnumReservedRange.runtime = proto2;
EnumDescriptorProto_EnumReservedRange.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange";
EnumDescriptorProto_EnumReservedRange.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
var EnumValueDescriptorProto = class _EnumValueDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValueDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumValueDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValueDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumValueDescriptorProto, a, b);
  }
};
EnumValueDescriptorProto.runtime = proto2;
EnumValueDescriptorProto.typeName = "google.protobuf.EnumValueDescriptorProto";
EnumValueDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: EnumValueOptions, opt: true }
]);
var ServiceDescriptorProto = class _ServiceDescriptorProto extends Message {
  constructor(data) {
    super();
    this.method = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ServiceDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ServiceDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ServiceDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ServiceDescriptorProto, a, b);
  }
};
ServiceDescriptorProto.runtime = proto2;
ServiceDescriptorProto.typeName = "google.protobuf.ServiceDescriptorProto";
ServiceDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "method", kind: "message", T: MethodDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: ServiceOptions, opt: true }
]);
var MethodDescriptorProto = class _MethodDescriptorProto extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MethodDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _MethodDescriptorProto().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MethodDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_MethodDescriptorProto, a, b);
  }
};
MethodDescriptorProto.runtime = proto2;
MethodDescriptorProto.typeName = "google.protobuf.MethodDescriptorProto";
MethodDescriptorProto.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "input_type", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "output_type", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "options", kind: "message", T: MethodOptions, opt: true },
  { no: 5, name: "client_streaming", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "server_streaming", kind: "scalar", T: 8, opt: true, default: false }
]);
var FileOptions = class _FileOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FileOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FileOptions, a, b);
  }
};
FileOptions.runtime = proto2;
FileOptions.typeName = "google.protobuf.FileOptions";
FileOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "java_package", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: true },
  { no: 10, name: "java_multiple_files", kind: "scalar", T: 8, opt: true, default: false },
  { no: 20, name: "java_generate_equals_and_hash", kind: "scalar", T: 8, opt: true },
  { no: 27, name: "java_string_check_utf8", kind: "scalar", T: 8, opt: true, default: false },
  { no: 9, name: "optimize_for", kind: "enum", T: proto2.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },
  { no: 11, name: "go_package", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "cc_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "java_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 18, name: "py_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 23, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 31, name: "cc_enable_arenas", kind: "scalar", T: 8, opt: true, default: true },
  { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: true },
  { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: true },
  { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: true },
  { no: 44, name: "php_metadata_namespace", kind: "scalar", T: 9, opt: true },
  { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
proto2.util.setEnumType(FileOptions_OptimizeMode, "google.protobuf.FileOptions.OptimizeMode", [
  { no: 1, name: "SPEED" },
  { no: 2, name: "CODE_SIZE" },
  { no: 3, name: "LITE_RUNTIME" }
]);
var MessageOptions = class _MessageOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MessageOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _MessageOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MessageOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_MessageOptions, a, b);
  }
};
MessageOptions.runtime = proto2;
MessageOptions.typeName = "google.protobuf.MessageOptions";
MessageOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "message_set_wire_format", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "no_standard_descriptor_accessor", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: true },
  { no: 11, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 12, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions = class _FieldOptions extends Message {
  constructor(data) {
    super();
    this.targets = [];
    this.editionDefaults = [];
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldOptions, a, b);
  }
};
FieldOptions.runtime = proto2;
FieldOptions.typeName = "google.protobuf.FieldOptions";
FieldOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "ctype", kind: "enum", T: proto2.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },
  { no: 2, name: "packed", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "jstype", kind: "enum", T: proto2.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },
  { no: 5, name: "lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 15, name: "unverified_lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 10, name: "weak", kind: "scalar", T: 8, opt: true, default: false },
  { no: 16, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "retention", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionRetention), opt: true },
  { no: 19, name: "targets", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionTargetType), repeated: true },
  { no: 20, name: "edition_defaults", kind: "message", T: FieldOptions_EditionDefault, repeated: true },
  { no: 21, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 22, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
})(FieldOptions_CType || (FieldOptions_CType = {}));
proto2.util.setEnumType(FieldOptions_CType, "google.protobuf.FieldOptions.CType", [
  { no: 0, name: "STRING" },
  { no: 1, name: "CORD" },
  { no: 2, name: "STRING_PIECE" }
]);
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
})(FieldOptions_JSType || (FieldOptions_JSType = {}));
proto2.util.setEnumType(FieldOptions_JSType, "google.protobuf.FieldOptions.JSType", [
  { no: 0, name: "JS_NORMAL" },
  { no: 1, name: "JS_STRING" },
  { no: 2, name: "JS_NUMBER" }
]);
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
proto2.util.setEnumType(FieldOptions_OptionRetention, "google.protobuf.FieldOptions.OptionRetention", [
  { no: 0, name: "RETENTION_UNKNOWN" },
  { no: 1, name: "RETENTION_RUNTIME" },
  { no: 2, name: "RETENTION_SOURCE" }
]);
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
proto2.util.setEnumType(FieldOptions_OptionTargetType, "google.protobuf.FieldOptions.OptionTargetType", [
  { no: 0, name: "TARGET_TYPE_UNKNOWN" },
  { no: 1, name: "TARGET_TYPE_FILE" },
  { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
  { no: 3, name: "TARGET_TYPE_MESSAGE" },
  { no: 4, name: "TARGET_TYPE_FIELD" },
  { no: 5, name: "TARGET_TYPE_ONEOF" },
  { no: 6, name: "TARGET_TYPE_ENUM" },
  { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
  { no: 8, name: "TARGET_TYPE_SERVICE" },
  { no: 9, name: "TARGET_TYPE_METHOD" }
]);
var FieldOptions_EditionDefault = class _FieldOptions_EditionDefault extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions_EditionDefault().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldOptions_EditionDefault().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions_EditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldOptions_EditionDefault, a, b);
  }
};
FieldOptions_EditionDefault.runtime = proto2;
FieldOptions_EditionDefault.typeName = "google.protobuf.FieldOptions.EditionDefault";
FieldOptions_EditionDefault.fields = proto2.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 2, name: "value", kind: "scalar", T: 9, opt: true }
]);
var FieldOptions_FeatureSupport = class _FieldOptions_FeatureSupport extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions_FeatureSupport().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldOptions_FeatureSupport().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions_FeatureSupport().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FieldOptions_FeatureSupport, a, b);
  }
};
FieldOptions_FeatureSupport.runtime = proto2;
FieldOptions_FeatureSupport.typeName = "google.protobuf.FieldOptions.FeatureSupport";
FieldOptions_FeatureSupport.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "edition_introduced", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 2, name: "edition_deprecated", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 3, name: "deprecation_warning", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "edition_removed", kind: "enum", T: proto2.getEnumType(Edition), opt: true }
]);
var OneofOptions = class _OneofOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _OneofOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _OneofOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _OneofOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_OneofOptions, a, b);
  }
};
OneofOptions.runtime = proto2;
OneofOptions.typeName = "google.protobuf.OneofOptions";
OneofOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var EnumOptions = class _EnumOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumOptions, a, b);
  }
};
EnumOptions.runtime = proto2;
EnumOptions.typeName = "google.protobuf.EnumOptions";
EnumOptions.fields = proto2.util.newFieldList(() => [
  { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: true },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 7, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var EnumValueOptions = class _EnumValueOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValueOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumValueOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValueOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_EnumValueOptions, a, b);
  }
};
EnumValueOptions.runtime = proto2;
EnumValueOptions.typeName = "google.protobuf.EnumValueOptions";
EnumValueOptions.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 4, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var ServiceOptions = class _ServiceOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ServiceOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ServiceOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ServiceOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_ServiceOptions, a, b);
  }
};
ServiceOptions.runtime = proto2;
ServiceOptions.typeName = "google.protobuf.ServiceOptions";
ServiceOptions.fields = proto2.util.newFieldList(() => [
  { no: 34, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions = class _MethodOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MethodOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _MethodOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MethodOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_MethodOptions, a, b);
  }
};
MethodOptions.runtime = proto2;
MethodOptions.typeName = "google.protobuf.MethodOptions";
MethodOptions.fields = proto2.util.newFieldList(() => [
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 34, name: "idempotency_level", kind: "enum", T: proto2.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },
  { no: 35, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
proto2.util.setEnumType(MethodOptions_IdempotencyLevel, "google.protobuf.MethodOptions.IdempotencyLevel", [
  { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
  { no: 1, name: "NO_SIDE_EFFECTS" },
  { no: 2, name: "IDEMPOTENT" }
]);
var UninterpretedOption = class _UninterpretedOption extends Message {
  constructor(data) {
    super();
    this.name = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UninterpretedOption().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UninterpretedOption().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UninterpretedOption().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_UninterpretedOption, a, b);
  }
};
UninterpretedOption.runtime = proto2;
UninterpretedOption.typeName = "google.protobuf.UninterpretedOption";
UninterpretedOption.fields = proto2.util.newFieldList(() => [
  { no: 2, name: "name", kind: "message", T: UninterpretedOption_NamePart, repeated: true },
  { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: true },
  { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: true },
  { no: 6, name: "double_value", kind: "scalar", T: 1, opt: true },
  { no: 7, name: "string_value", kind: "scalar", T: 12, opt: true },
  { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: true }
]);
var UninterpretedOption_NamePart = class _UninterpretedOption_NamePart extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UninterpretedOption_NamePart().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UninterpretedOption_NamePart().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UninterpretedOption_NamePart().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_UninterpretedOption_NamePart, a, b);
  }
};
UninterpretedOption_NamePart.runtime = proto2;
UninterpretedOption_NamePart.typeName = "google.protobuf.UninterpretedOption.NamePart";
UninterpretedOption_NamePart.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name_part", kind: "scalar", T: 9, req: true },
  { no: 2, name: "is_extension", kind: "scalar", T: 8, req: true }
]);
var FeatureSet = class _FeatureSet extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSet().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FeatureSet().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FeatureSet, a, b);
  }
};
FeatureSet.runtime = proto2;
FeatureSet.typeName = "google.protobuf.FeatureSet";
FeatureSet.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "field_presence", kind: "enum", T: proto2.getEnumType(FeatureSet_FieldPresence), opt: true },
  { no: 2, name: "enum_type", kind: "enum", T: proto2.getEnumType(FeatureSet_EnumType), opt: true },
  { no: 3, name: "repeated_field_encoding", kind: "enum", T: proto2.getEnumType(FeatureSet_RepeatedFieldEncoding), opt: true },
  { no: 4, name: "utf8_validation", kind: "enum", T: proto2.getEnumType(FeatureSet_Utf8Validation), opt: true },
  { no: 5, name: "message_encoding", kind: "enum", T: proto2.getEnumType(FeatureSet_MessageEncoding), opt: true },
  { no: 6, name: "json_format", kind: "enum", T: proto2.getEnumType(FeatureSet_JsonFormat), opt: true }
]);
var FeatureSet_FieldPresence;
(function(FeatureSet_FieldPresence2) {
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["EXPLICIT"] = 1] = "EXPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["IMPLICIT"] = 2] = "IMPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
})(FeatureSet_FieldPresence || (FeatureSet_FieldPresence = {}));
proto2.util.setEnumType(FeatureSet_FieldPresence, "google.protobuf.FeatureSet.FieldPresence", [
  { no: 0, name: "FIELD_PRESENCE_UNKNOWN" },
  { no: 1, name: "EXPLICIT" },
  { no: 2, name: "IMPLICIT" },
  { no: 3, name: "LEGACY_REQUIRED" }
]);
var FeatureSet_EnumType;
(function(FeatureSet_EnumType2) {
  FeatureSet_EnumType2[FeatureSet_EnumType2["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["OPEN"] = 1] = "OPEN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["CLOSED"] = 2] = "CLOSED";
})(FeatureSet_EnumType || (FeatureSet_EnumType = {}));
proto2.util.setEnumType(FeatureSet_EnumType, "google.protobuf.FeatureSet.EnumType", [
  { no: 0, name: "ENUM_TYPE_UNKNOWN" },
  { no: 1, name: "OPEN" },
  { no: 2, name: "CLOSED" }
]);
var FeatureSet_RepeatedFieldEncoding;
(function(FeatureSet_RepeatedFieldEncoding2) {
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["PACKED"] = 1] = "PACKED";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["EXPANDED"] = 2] = "EXPANDED";
})(FeatureSet_RepeatedFieldEncoding || (FeatureSet_RepeatedFieldEncoding = {}));
proto2.util.setEnumType(FeatureSet_RepeatedFieldEncoding, "google.protobuf.FeatureSet.RepeatedFieldEncoding", [
  { no: 0, name: "REPEATED_FIELD_ENCODING_UNKNOWN" },
  { no: 1, name: "PACKED" },
  { no: 2, name: "EXPANDED" }
]);
var FeatureSet_Utf8Validation;
(function(FeatureSet_Utf8Validation2) {
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["VERIFY"] = 2] = "VERIFY";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["NONE"] = 3] = "NONE";
})(FeatureSet_Utf8Validation || (FeatureSet_Utf8Validation = {}));
proto2.util.setEnumType(FeatureSet_Utf8Validation, "google.protobuf.FeatureSet.Utf8Validation", [
  { no: 0, name: "UTF8_VALIDATION_UNKNOWN" },
  { no: 2, name: "VERIFY" },
  { no: 3, name: "NONE" }
]);
var FeatureSet_MessageEncoding;
(function(FeatureSet_MessageEncoding2) {
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["DELIMITED"] = 2] = "DELIMITED";
})(FeatureSet_MessageEncoding || (FeatureSet_MessageEncoding = {}));
proto2.util.setEnumType(FeatureSet_MessageEncoding, "google.protobuf.FeatureSet.MessageEncoding", [
  { no: 0, name: "MESSAGE_ENCODING_UNKNOWN" },
  { no: 1, name: "LENGTH_PREFIXED" },
  { no: 2, name: "DELIMITED" }
]);
var FeatureSet_JsonFormat;
(function(FeatureSet_JsonFormat2) {
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["ALLOW"] = 1] = "ALLOW";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
})(FeatureSet_JsonFormat || (FeatureSet_JsonFormat = {}));
proto2.util.setEnumType(FeatureSet_JsonFormat, "google.protobuf.FeatureSet.JsonFormat", [
  { no: 0, name: "JSON_FORMAT_UNKNOWN" },
  { no: 1, name: "ALLOW" },
  { no: 2, name: "LEGACY_BEST_EFFORT" }
]);
var FeatureSetDefaults = class _FeatureSetDefaults extends Message {
  constructor(data) {
    super();
    this.defaults = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSetDefaults().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FeatureSetDefaults().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSetDefaults().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FeatureSetDefaults, a, b);
  }
};
FeatureSetDefaults.runtime = proto2;
FeatureSetDefaults.typeName = "google.protobuf.FeatureSetDefaults";
FeatureSetDefaults.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "defaults", kind: "message", T: FeatureSetDefaults_FeatureSetEditionDefault, repeated: true },
  { no: 4, name: "minimum_edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 5, name: "maximum_edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true }
]);
var FeatureSetDefaults_FeatureSetEditionDefault = class _FeatureSetDefaults_FeatureSetEditionDefault extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_FeatureSetDefaults_FeatureSetEditionDefault, a, b);
  }
};
FeatureSetDefaults_FeatureSetEditionDefault.runtime = proto2;
FeatureSetDefaults_FeatureSetEditionDefault.typeName = "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
FeatureSetDefaults_FeatureSetEditionDefault.fields = proto2.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto2.getEnumType(Edition), opt: true },
  { no: 4, name: "overridable_features", kind: "message", T: FeatureSet, opt: true },
  { no: 5, name: "fixed_features", kind: "message", T: FeatureSet, opt: true }
]);
var SourceCodeInfo = class _SourceCodeInfo extends Message {
  constructor(data) {
    super();
    this.location = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceCodeInfo().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _SourceCodeInfo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_SourceCodeInfo, a, b);
  }
};
SourceCodeInfo.runtime = proto2;
SourceCodeInfo.typeName = "google.protobuf.SourceCodeInfo";
SourceCodeInfo.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "location", kind: "message", T: SourceCodeInfo_Location, repeated: true }
]);
var SourceCodeInfo_Location = class _SourceCodeInfo_Location extends Message {
  constructor(data) {
    super();
    this.path = [];
    this.span = [];
    this.leadingDetachedComments = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceCodeInfo_Location().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _SourceCodeInfo_Location().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceCodeInfo_Location().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_SourceCodeInfo_Location, a, b);
  }
};
SourceCodeInfo_Location.runtime = proto2;
SourceCodeInfo_Location.typeName = "google.protobuf.SourceCodeInfo.Location";
SourceCodeInfo_Location.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "span", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: true },
  { no: 6, name: "leading_detached_comments", kind: "scalar", T: 9, repeated: true }
]);
var GeneratedCodeInfo = class _GeneratedCodeInfo extends Message {
  constructor(data) {
    super();
    this.annotation = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _GeneratedCodeInfo().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _GeneratedCodeInfo().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _GeneratedCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_GeneratedCodeInfo, a, b);
  }
};
GeneratedCodeInfo.runtime = proto2;
GeneratedCodeInfo.typeName = "google.protobuf.GeneratedCodeInfo";
GeneratedCodeInfo.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "annotation", kind: "message", T: GeneratedCodeInfo_Annotation, repeated: true }
]);
var GeneratedCodeInfo_Annotation = class _GeneratedCodeInfo_Annotation extends Message {
  constructor(data) {
    super();
    this.path = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _GeneratedCodeInfo_Annotation().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _GeneratedCodeInfo_Annotation().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_GeneratedCodeInfo_Annotation, a, b);
  }
};
GeneratedCodeInfo_Annotation.runtime = proto2;
GeneratedCodeInfo_Annotation.typeName = "google.protobuf.GeneratedCodeInfo.Annotation";
GeneratedCodeInfo_Annotation.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "source_file", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "begin", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 5, name: "semantic", kind: "enum", T: proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true }
]);
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
proto2.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, "google.protobuf.GeneratedCodeInfo.Annotation.Semantic", [
  { no: 0, name: "NONE" },
  { no: 1, name: "SET" },
  { no: 2, name: "ALIAS" }
]);

// node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js
var fieldTypeToScalarType = {
  [FieldDescriptorProto_Type.DOUBLE]: ScalarType.DOUBLE,
  [FieldDescriptorProto_Type.FLOAT]: ScalarType.FLOAT,
  [FieldDescriptorProto_Type.INT64]: ScalarType.INT64,
  [FieldDescriptorProto_Type.UINT64]: ScalarType.UINT64,
  [FieldDescriptorProto_Type.INT32]: ScalarType.INT32,
  [FieldDescriptorProto_Type.FIXED64]: ScalarType.FIXED64,
  [FieldDescriptorProto_Type.FIXED32]: ScalarType.FIXED32,
  [FieldDescriptorProto_Type.BOOL]: ScalarType.BOOL,
  [FieldDescriptorProto_Type.STRING]: ScalarType.STRING,
  [FieldDescriptorProto_Type.GROUP]: void 0,
  [FieldDescriptorProto_Type.MESSAGE]: void 0,
  [FieldDescriptorProto_Type.BYTES]: ScalarType.BYTES,
  [FieldDescriptorProto_Type.UINT32]: ScalarType.UINT32,
  [FieldDescriptorProto_Type.ENUM]: void 0,
  [FieldDescriptorProto_Type.SFIXED32]: ScalarType.SFIXED32,
  [FieldDescriptorProto_Type.SFIXED64]: ScalarType.SFIXED64,
  [FieldDescriptorProto_Type.SINT32]: ScalarType.SINT32,
  [FieldDescriptorProto_Type.SINT64]: ScalarType.SINT64
};
var FieldNumber;
(function(FieldNumber2) {
  FieldNumber2[FieldNumber2["FileDescriptorProto_Package"] = 2] = "FileDescriptorProto_Package";
  FieldNumber2[FieldNumber2["FileDescriptorProto_MessageType"] = 4] = "FileDescriptorProto_MessageType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_EnumType"] = 5] = "FileDescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Service"] = 6] = "FileDescriptorProto_Service";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Extension"] = 7] = "FileDescriptorProto_Extension";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Syntax"] = 12] = "FileDescriptorProto_Syntax";
  FieldNumber2[FieldNumber2["DescriptorProto_Field"] = 2] = "DescriptorProto_Field";
  FieldNumber2[FieldNumber2["DescriptorProto_NestedType"] = 3] = "DescriptorProto_NestedType";
  FieldNumber2[FieldNumber2["DescriptorProto_EnumType"] = 4] = "DescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["DescriptorProto_Extension"] = 6] = "DescriptorProto_Extension";
  FieldNumber2[FieldNumber2["DescriptorProto_OneofDecl"] = 8] = "DescriptorProto_OneofDecl";
  FieldNumber2[FieldNumber2["EnumDescriptorProto_Value"] = 2] = "EnumDescriptorProto_Value";
  FieldNumber2[FieldNumber2["ServiceDescriptorProto_Method"] = 2] = "ServiceDescriptorProto_Method";
})(FieldNumber || (FieldNumber = {}));

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js
var Timestamp = class _Timestamp extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3.json.debug(json)}`);
    }
    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
    if (Number.isNaN(ms)) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    this.seconds = protoInt64.parse(ms / 1e3);
    this.nanos = 0;
    if (matches[7]) {
      this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
    }
    return this;
  }
  toJson(options) {
    const ms = Number(this.seconds) * 1e3;
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    if (this.nanos < 0) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
    }
    let z = "Z";
    if (this.nanos > 0) {
      const nanosStr = (this.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000") {
        z = "." + nanosStr.substring(0, 3) + "Z";
      } else if (nanosStr.substring(6) === "000") {
        z = "." + nanosStr.substring(0, 6) + "Z";
      } else {
        z = "." + nanosStr + "Z";
      }
    }
    return new Date(ms).toISOString().replace(".000Z", z);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(date) {
    const ms = date.getTime();
    return new _Timestamp({
      seconds: protoInt64.parse(Math.floor(ms / 1e3)),
      nanos: ms % 1e3 * 1e6
    });
  }
  static fromBinary(bytes, options) {
    return new _Timestamp().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Timestamp().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Timestamp().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Timestamp, a, b);
  }
};
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js
var Duration = class _Duration extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
    }
    const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
    if (match === null) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
    }
    const longSeconds = Number(match[1]);
    if (longSeconds > 315576e6 || longSeconds < -315576e6) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
    }
    this.seconds = protoInt64.parse(longSeconds);
    if (typeof match[2] == "string") {
      const nanosStr = match[2] + "0".repeat(9 - match[2].length);
      this.nanos = parseInt(nanosStr);
      if (longSeconds < 0 || Object.is(longSeconds, -0)) {
        this.nanos = -this.nanos;
      }
    }
    return this;
  }
  toJson(options) {
    if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6) {
      throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);
    }
    let text = this.seconds.toString();
    if (this.nanos !== 0) {
      let nanosStr = Math.abs(this.nanos).toString();
      nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
      if (nanosStr.substring(3) === "000000") {
        nanosStr = nanosStr.substring(0, 3);
      } else if (nanosStr.substring(6) === "000") {
        nanosStr = nanosStr.substring(0, 6);
      }
      text += "." + nanosStr;
      if (this.nanos < 0 && Number(this.seconds) == 0) {
        text = "-" + text;
      }
    }
    return text + "s";
  }
  static fromBinary(bytes, options) {
    return new _Duration().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Duration().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Duration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Duration, a, b);
  }
};
Duration.runtime = proto3;
Duration.typeName = "google.protobuf.Duration";
Duration.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js
var Any = class _Any extends Message {
  constructor(data) {
    super();
    this.typeUrl = "";
    this.value = new Uint8Array(0);
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    var _a2;
    if (this.typeUrl === "") {
      return {};
    }
    const typeName = this.typeUrlToName(this.typeUrl);
    const messageType = (_a2 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a2 === void 0 ? void 0 : _a2.findMessage(typeName);
    if (!messageType) {
      throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
    }
    const message = messageType.fromBinary(this.value);
    let json = message.toJson(options);
    if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
      json = { value: json };
    }
    json["@type"] = this.typeUrl;
    return json;
  }
  fromJson(json, options) {
    var _a2;
    if (json === null || Array.isArray(json) || typeof json != "object") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
    }
    if (Object.keys(json).length == 0) {
      return this;
    }
    const typeUrl = json["@type"];
    if (typeof typeUrl != "string" || typeUrl == "") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
    }
    const typeName = this.typeUrlToName(typeUrl), messageType = (_a2 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a2 === void 0 ? void 0 : _a2.findMessage(typeName);
    if (!messageType) {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
    }
    let message;
    if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
      message = messageType.fromJson(json["value"], options);
    } else {
      const copy = Object.assign({}, json);
      delete copy["@type"];
      message = messageType.fromJson(copy, options);
    }
    this.packFrom(message);
    return this;
  }
  packFrom(message) {
    this.value = message.toBinary();
    this.typeUrl = this.typeNameToUrl(message.getType().typeName);
  }
  unpackTo(target) {
    if (!this.is(target.getType())) {
      return false;
    }
    target.fromBinary(this.value);
    return true;
  }
  unpack(registry) {
    if (this.typeUrl === "") {
      return void 0;
    }
    const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
    if (!messageType) {
      return void 0;
    }
    return messageType.fromBinary(this.value);
  }
  is(type) {
    if (this.typeUrl === "") {
      return false;
    }
    const name = this.typeUrlToName(this.typeUrl);
    let typeName = "";
    if (typeof type === "string") {
      typeName = type;
    } else {
      typeName = type.typeName;
    }
    return name === typeName;
  }
  typeNameToUrl(name) {
    return `type.googleapis.com/${name}`;
  }
  typeUrlToName(url) {
    if (!url.length) {
      throw new Error(`invalid type url: ${url}`);
    }
    const slash = url.lastIndexOf("/");
    const name = slash >= 0 ? url.substring(slash + 1) : url;
    if (!name.length) {
      throw new Error(`invalid type url: ${url}`);
    }
    return name;
  }
  static pack(message) {
    const any = new _Any();
    any.packFrom(message);
    return any;
  }
  static fromBinary(bytes, options) {
    return new _Any().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Any().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Any().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Any, a, b);
  }
};
Any.runtime = proto3;
Any.typeName = "google.protobuf.Any";
Any.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js
var Empty = class _Empty extends Message {
  constructor(data) {
    super();
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Empty().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Empty().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Empty().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Empty, a, b);
  }
};
Empty.runtime = proto3;
Empty.typeName = "google.protobuf.Empty";
Empty.fields = proto3.util.newFieldList(() => []);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js
var FieldMask = class _FieldMask extends Message {
  constructor(data) {
    super();
    this.paths = [];
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    function protoCamelCase2(snakeCase) {
      let capNext = false;
      const b = [];
      for (let i = 0; i < snakeCase.length; i++) {
        let c = snakeCase.charAt(i);
        switch (c) {
          case "_":
            capNext = true;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            b.push(c);
            capNext = false;
            break;
          default:
            if (capNext) {
              capNext = false;
              c = c.toUpperCase();
            }
            b.push(c);
            break;
        }
      }
      return b.join("");
    }
    return this.paths.map((p) => {
      if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
        throw new Error('cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' + p + '" is irreversible');
      }
      return protoCamelCase2(p);
    }).join(",");
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error("cannot decode google.protobuf.FieldMask from JSON: " + proto3.json.debug(json));
    }
    if (json === "") {
      return this;
    }
    function camelToSnake(str) {
      if (str.includes("_")) {
        throw new Error("cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase");
      }
      const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
      return sc[0] === "_" ? sc.substring(1) : sc;
    }
    this.paths = json.split(",").map(camelToSnake);
    return this;
  }
  static fromBinary(bytes, options) {
    return new _FieldMask().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FieldMask().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldMask().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_FieldMask, a, b);
  }
};
FieldMask.runtime = proto3;
FieldMask.typeName = "google.protobuf.FieldMask";
FieldMask.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "paths", kind: "scalar", T: 9, repeated: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (NullValue = {}));
proto3.util.setEnumType(NullValue, "google.protobuf.NullValue", [
  { no: 0, name: "NULL_VALUE" }
]);
var Struct = class _Struct extends Message {
  constructor(data) {
    super();
    this.fields = {};
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    const json = {};
    for (const [k, v] of Object.entries(this.fields)) {
      json[k] = v.toJson(options);
    }
    return json;
  }
  fromJson(json, options) {
    if (typeof json != "object" || json == null || Array.isArray(json)) {
      throw new Error("cannot decode google.protobuf.Struct from JSON " + proto3.json.debug(json));
    }
    for (const [k, v] of Object.entries(json)) {
      this.fields[k] = Value.fromJson(v);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Struct().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Struct().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Struct().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Struct, a, b);
  }
};
Struct.runtime = proto3;
Struct.typeName = "google.protobuf.Struct";
Struct.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: Value } }
]);
var Value = class _Value2 extends Message {
  constructor(data) {
    super();
    this.kind = { case: void 0 };
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    switch (this.kind.case) {
      case "nullValue":
        return null;
      case "numberValue":
        if (!Number.isFinite(this.kind.value)) {
          throw new Error("google.protobuf.Value cannot be NaN or Infinity");
        }
        return this.kind.value;
      case "boolValue":
        return this.kind.value;
      case "stringValue":
        return this.kind.value;
      case "structValue":
      case "listValue":
        return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));
    }
    throw new Error("google.protobuf.Value must have a value");
  }
  fromJson(json, options) {
    switch (typeof json) {
      case "number":
        this.kind = { case: "numberValue", value: json };
        break;
      case "string":
        this.kind = { case: "stringValue", value: json };
        break;
      case "boolean":
        this.kind = { case: "boolValue", value: json };
        break;
      case "object":
        if (json === null) {
          this.kind = { case: "nullValue", value: NullValue.NULL_VALUE };
        } else if (Array.isArray(json)) {
          this.kind = { case: "listValue", value: ListValue.fromJson(json) };
        } else {
          this.kind = { case: "structValue", value: Struct.fromJson(json) };
        }
        break;
      default:
        throw new Error("cannot decode google.protobuf.Value from JSON " + proto3.json.debug(json));
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Value2().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Value2().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Value2().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Value2, a, b);
  }
};
Value.runtime = proto3;
Value.typeName = "google.protobuf.Value";
Value.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "null_value", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "kind" },
  { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
  { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
  { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
  { no: 5, name: "struct_value", kind: "message", T: Struct, oneof: "kind" },
  { no: 6, name: "list_value", kind: "message", T: ListValue, oneof: "kind" }
]);
var ListValue = class _ListValue extends Message {
  constructor(data) {
    super();
    this.values = [];
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return this.values.map((v) => v.toJson());
  }
  fromJson(json, options) {
    if (!Array.isArray(json)) {
      throw new Error("cannot decode google.protobuf.ListValue from JSON " + proto3.json.debug(json));
    }
    for (let e of json) {
      this.values.push(Value.fromJson(e));
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _ListValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ListValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ListValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_ListValue, a, b);
  }
};
ListValue.runtime = proto3;
ListValue.typeName = "google.protobuf.ListValue";
ListValue.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "values", kind: "message", T: Value, repeated: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js
var DoubleValue = class _DoubleValue extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.DOUBLE, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.DOUBLE, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.DoubleValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _DoubleValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _DoubleValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DoubleValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_DoubleValue, a, b);
  }
};
DoubleValue.runtime = proto3;
DoubleValue.typeName = "google.protobuf.DoubleValue";
DoubleValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }
]);
DoubleValue.fieldWrapper = {
  wrapField(value) {
    return new DoubleValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var FloatValue = class _FloatValue extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.FLOAT, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.FLOAT, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.FloatValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _FloatValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _FloatValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FloatValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_FloatValue, a, b);
  }
};
FloatValue.runtime = proto3;
FloatValue.typeName = "google.protobuf.FloatValue";
FloatValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }
]);
FloatValue.fieldWrapper = {
  wrapField(value) {
    return new FloatValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var Int64Value = class _Int64Value extends Message {
  constructor(data) {
    super();
    this.value = protoInt64.zero;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.INT64, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.INT64, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Int64Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Int64Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Int64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Int64Value, a, b);
  }
};
Int64Value.runtime = proto3;
Int64Value.typeName = "google.protobuf.Int64Value";
Int64Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
Int64Value.fieldWrapper = {
  wrapField(value) {
    return new Int64Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var UInt64Value = class _UInt64Value extends Message {
  constructor(data) {
    super();
    this.value = protoInt64.zero;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.UINT64, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.UINT64, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _UInt64Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UInt64Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UInt64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_UInt64Value, a, b);
  }
};
UInt64Value.runtime = proto3;
UInt64Value.typeName = "google.protobuf.UInt64Value";
UInt64Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }
]);
UInt64Value.fieldWrapper = {
  wrapField(value) {
    return new UInt64Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var Int32Value = class _Int32Value extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.INT32, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.INT32, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Int32Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Int32Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Int32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Int32Value, a, b);
  }
};
Int32Value.runtime = proto3;
Int32Value.typeName = "google.protobuf.Int32Value";
Int32Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
Int32Value.fieldWrapper = {
  wrapField(value) {
    return new Int32Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var UInt32Value = class _UInt32Value extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.UINT32, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.UINT32, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _UInt32Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UInt32Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UInt32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_UInt32Value, a, b);
  }
};
UInt32Value.runtime = proto3;
UInt32Value.typeName = "google.protobuf.UInt32Value";
UInt32Value.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]);
UInt32Value.fieldWrapper = {
  wrapField(value) {
    return new UInt32Value({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var BoolValue = class _BoolValue extends Message {
  constructor(data) {
    super();
    this.value = false;
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.BOOL, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.BOOL, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BoolValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _BoolValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _BoolValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _BoolValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_BoolValue, a, b);
  }
};
BoolValue.runtime = proto3;
BoolValue.typeName = "google.protobuf.BoolValue";
BoolValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]);
BoolValue.fieldWrapper = {
  wrapField(value) {
    return new BoolValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var StringValue = class _StringValue extends Message {
  constructor(data) {
    super();
    this.value = "";
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.STRING, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.STRING, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.StringValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _StringValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _StringValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _StringValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_StringValue, a, b);
  }
};
StringValue.runtime = proto3;
StringValue.typeName = "google.protobuf.StringValue";
StringValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
StringValue.fieldWrapper = {
  wrapField(value) {
    return new StringValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};
var BytesValue = class _BytesValue extends Message {
  constructor(data) {
    super();
    this.value = new Uint8Array(0);
    proto3.util.initPartial(data, this);
  }
  toJson(options) {
    return proto3.json.writeScalar(ScalarType.BYTES, this.value, true);
  }
  fromJson(json, options) {
    try {
      this.value = proto3.json.readScalar(ScalarType.BYTES, json);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BytesValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _BytesValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _BytesValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _BytesValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_BytesValue, a, b);
  }
};
BytesValue.runtime = proto3;
BytesValue.typeName = "google.protobuf.BytesValue";
BytesValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);
BytesValue.fieldWrapper = {
  wrapField(value) {
    return new BytesValue({ value });
  },
  unwrapField(value) {
    return value.value;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js
var wkEnums = [getEnumType(NullValue)];

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js
var Version = class _Version extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Version().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Version().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Version().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_Version, a, b);
  }
};
Version.runtime = proto2;
Version.typeName = "google.protobuf.compiler.Version";
Version.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "major", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "minor", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "patch", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "suffix", kind: "scalar", T: 9, opt: true }
]);
var CodeGeneratorRequest = class _CodeGeneratorRequest extends Message {
  constructor(data) {
    super();
    this.fileToGenerate = [];
    this.protoFile = [];
    this.sourceFileDescriptors = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorRequest().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _CodeGeneratorRequest().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorRequest().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_CodeGeneratorRequest, a, b);
  }
};
CodeGeneratorRequest.runtime = proto2;
CodeGeneratorRequest.typeName = "google.protobuf.compiler.CodeGeneratorRequest";
CodeGeneratorRequest.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: true },
  { no: 2, name: "parameter", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "proto_file", kind: "message", T: FileDescriptorProto, repeated: true },
  { no: 17, name: "source_file_descriptors", kind: "message", T: FileDescriptorProto, repeated: true },
  { no: 3, name: "compiler_version", kind: "message", T: Version, opt: true }
]);
var CodeGeneratorResponse = class _CodeGeneratorResponse extends Message {
  constructor(data) {
    super();
    this.file = [];
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorResponse().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _CodeGeneratorResponse().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorResponse().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_CodeGeneratorResponse, a, b);
  }
};
CodeGeneratorResponse.runtime = proto2;
CodeGeneratorResponse.typeName = "google.protobuf.compiler.CodeGeneratorResponse";
CodeGeneratorResponse.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "error", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: true },
  { no: 3, name: "minimum_edition", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "maximum_edition", kind: "scalar", T: 5, opt: true },
  { no: 15, name: "file", kind: "message", T: CodeGeneratorResponse_File, repeated: true }
]);
var CodeGeneratorResponse_Feature;
(function(CodeGeneratorResponse_Feature2) {
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["SUPPORTS_EDITIONS"] = 2] = "SUPPORTS_EDITIONS";
})(CodeGeneratorResponse_Feature || (CodeGeneratorResponse_Feature = {}));
proto2.util.setEnumType(CodeGeneratorResponse_Feature, "google.protobuf.compiler.CodeGeneratorResponse.Feature", [
  { no: 0, name: "FEATURE_NONE" },
  { no: 1, name: "FEATURE_PROTO3_OPTIONAL" },
  { no: 2, name: "FEATURE_SUPPORTS_EDITIONS" }
]);
var CodeGeneratorResponse_File = class _CodeGeneratorResponse_File extends Message {
  constructor(data) {
    super();
    proto2.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorResponse_File().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _CodeGeneratorResponse_File().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorResponse_File().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto2.util.equals(_CodeGeneratorResponse_File, a, b);
  }
};
CodeGeneratorResponse_File.runtime = proto2;
CodeGeneratorResponse_File.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File";
CodeGeneratorResponse_File.fields = proto2.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "content", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "generated_code_info", kind: "message", T: GeneratedCodeInfo, opt: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js
var SourceContext = class _SourceContext extends Message {
  constructor(data) {
    super();
    this.fileName = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceContext().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _SourceContext().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceContext().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_SourceContext, a, b);
  }
};
SourceContext.runtime = proto3;
SourceContext.typeName = "google.protobuf.SourceContext";
SourceContext.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "file_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js
var Syntax;
(function(Syntax2) {
  Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
  Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
  Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
})(Syntax || (Syntax = {}));
proto3.util.setEnumType(Syntax, "google.protobuf.Syntax", [
  { no: 0, name: "SYNTAX_PROTO2" },
  { no: 1, name: "SYNTAX_PROTO3" },
  { no: 2, name: "SYNTAX_EDITIONS" }
]);
var Type = class _Type extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.fields = [];
    this.oneofs = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Type().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Type().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Type().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Type, a, b);
  }
};
Type.runtime = proto3;
Type.typeName = "google.protobuf.Type";
Type.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "fields", kind: "message", T: Field, repeated: true },
  { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: true },
  { no: 4, name: "options", kind: "message", T: Option, repeated: true },
  { no: 5, name: "source_context", kind: "message", T: SourceContext },
  { no: 6, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
  {
    no: 7,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field = class _Field extends Message {
  constructor(data) {
    super();
    this.kind = Field_Kind.TYPE_UNKNOWN;
    this.cardinality = Field_Cardinality.UNKNOWN;
    this.number = 0;
    this.name = "";
    this.typeUrl = "";
    this.oneofIndex = 0;
    this.packed = false;
    this.options = [];
    this.jsonName = "";
    this.defaultValue = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Field().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Field().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Field().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Field, a, b);
  }
};
Field.runtime = proto3;
Field.typeName = "google.protobuf.Field";
Field.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(Field_Kind) },
  { no: 2, name: "cardinality", kind: "enum", T: proto3.getEnumType(Field_Cardinality) },
  {
    no: 3,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 4,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "oneof_index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 8,
    name: "packed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 9, name: "options", kind: "message", T: Option, repeated: true },
  {
    no: 10,
    name: "json_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 11,
    name: "default_value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field_Kind;
(function(Field_Kind2) {
  Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
  Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
  Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
  Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
  Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
})(Field_Kind || (Field_Kind = {}));
proto3.util.setEnumType(Field_Kind, "google.protobuf.Field.Kind", [
  { no: 0, name: "TYPE_UNKNOWN" },
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var Field_Cardinality;
(function(Field_Cardinality2) {
  Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
  Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
  Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
  Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
})(Field_Cardinality || (Field_Cardinality = {}));
proto3.util.setEnumType(Field_Cardinality, "google.protobuf.Field.Cardinality", [
  { no: 0, name: "CARDINALITY_UNKNOWN" },
  { no: 1, name: "CARDINALITY_OPTIONAL" },
  { no: 2, name: "CARDINALITY_REQUIRED" },
  { no: 3, name: "CARDINALITY_REPEATED" }
]);
var Enum = class _Enum extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.enumvalue = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Enum().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Enum().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Enum().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Enum, a, b);
  }
};
Enum.runtime = proto3;
Enum.typeName = "google.protobuf.Enum";
Enum.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "enumvalue", kind: "message", T: EnumValue, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true },
  { no: 4, name: "source_context", kind: "message", T: SourceContext },
  { no: 5, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
  {
    no: 6,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var EnumValue = class _EnumValue extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.number = 0;
    this.options = [];
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _EnumValue().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_EnumValue, a, b);
  }
};
EnumValue.runtime = proto3;
EnumValue.typeName = "google.protobuf.EnumValue";
EnumValue.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true }
]);
var Option = class _Option extends Message {
  constructor(data) {
    super();
    this.name = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Option().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Option().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Option().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Option, a, b);
  }
};
Option.runtime = proto3;
Option.typeName = "google.protobuf.Option";
Option.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "value", kind: "message", T: Any }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js
var Api = class _Api extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.methods = [];
    this.options = [];
    this.version = "";
    this.mixins = [];
    this.syntax = Syntax.PROTO2;
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Api().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Api().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Api().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Api, a, b);
  }
};
Api.runtime = proto3;
Api.typeName = "google.protobuf.Api";
Api.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "methods", kind: "message", T: Method, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option, repeated: true },
  {
    no: 4,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 5, name: "source_context", kind: "message", T: SourceContext },
  { no: 6, name: "mixins", kind: "message", T: Mixin, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
]);
var Method = class _Method extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.requestTypeUrl = "";
    this.requestStreaming = false;
    this.responseTypeUrl = "";
    this.responseStreaming = false;
    this.options = [];
    this.syntax = Syntax.PROTO2;
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Method().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Method().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Method().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Method, a, b);
  }
};
Method.runtime = proto3;
Method.typeName = "google.protobuf.Method";
Method.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "request_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "request_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 4,
    name: "response_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "response_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 6, name: "options", kind: "message", T: Option, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
]);
var Mixin = class _Mixin extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.root = "";
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Mixin().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Mixin().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Mixin().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Mixin, a, b);
  }
};
Mixin.runtime = proto3;
Mixin.typeName = "google.protobuf.Mixin";
Mixin.fields = proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "root",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);

// node_modules/@graphprotocol/grc-20/dist/src/proto/gen/src/proto/ipfs_pb.js
var DataType;
(function(DataType2) {
  DataType2[DataType2["TEXT"] = 0] = "TEXT";
  DataType2[DataType2["NUMBER"] = 1] = "NUMBER";
  DataType2[DataType2["CHECKBOX"] = 2] = "CHECKBOX";
  DataType2[DataType2["TIME"] = 3] = "TIME";
  DataType2[DataType2["POINT"] = 4] = "POINT";
  DataType2[DataType2["RELATION"] = 5] = "RELATION";
})(DataType || (DataType = {}));
proto3.util.setEnumType(DataType, "grc20.DataType", [
  { no: 0, name: "TEXT" },
  { no: 1, name: "NUMBER" },
  { no: 2, name: "CHECKBOX" },
  { no: 3, name: "TIME" },
  { no: 4, name: "POINT" },
  { no: 5, name: "RELATION" }
]);
var _Edit = class _Edit extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: string name = 2;
     */
    __publicField(this, "name", "");
    /**
     * @generated from field: repeated grc20.Op ops = 3;
     */
    __publicField(this, "ops", []);
    /**
     * @generated from field: repeated bytes authors = 4;
     */
    __publicField(this, "authors", []);
    /**
     * @generated from field: optional bytes language = 5;
     */
    __publicField(this, "language");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Edit().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Edit().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Edit().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Edit, a, b);
  }
};
__publicField(_Edit, "runtime", proto3);
__publicField(_Edit, "typeName", "grc20.Edit");
__publicField(_Edit, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "ops", kind: "message", T: Op, repeated: true },
  { no: 4, name: "authors", kind: "scalar", T: 12, repeated: true },
  { no: 5, name: "language", kind: "scalar", T: 12, opt: true }
]));
var Edit = _Edit;
var _ImportEdit = class _ImportEdit extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: string name = 2;
     */
    __publicField(this, "name", "");
    /**
     * @generated from field: repeated grc20.Op ops = 3;
     */
    __publicField(this, "ops", []);
    /**
     * @generated from field: repeated bytes authors = 4;
     */
    __publicField(this, "authors", []);
    /**
     * @generated from field: bytes created_by = 5;
     */
    __publicField(this, "createdBy", new Uint8Array(0));
    /**
     * @generated from field: string created_at = 6;
     */
    __publicField(this, "createdAt", "");
    /**
     * @generated from field: bytes block_hash = 7;
     */
    __publicField(this, "blockHash", new Uint8Array(0));
    /**
     * @generated from field: string block_number = 8;
     */
    __publicField(this, "blockNumber", "");
    /**
     * @generated from field: bytes transaction_hash = 9;
     */
    __publicField(this, "transactionHash", new Uint8Array(0));
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ImportEdit().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _ImportEdit().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ImportEdit().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_ImportEdit, a, b);
  }
};
__publicField(_ImportEdit, "runtime", proto3);
__publicField(_ImportEdit, "typeName", "grc20.ImportEdit");
__publicField(_ImportEdit, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "ops", kind: "message", T: Op, repeated: true },
  { no: 4, name: "authors", kind: "scalar", T: 12, repeated: true },
  {
    no: 5,
    name: "created_by",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 6,
    name: "created_at",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "block_hash",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 8,
    name: "block_number",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 9,
    name: "transaction_hash",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]));
var ImportEdit = _ImportEdit;
var _Import = class _Import extends Message {
  constructor(data) {
    super();
    /**
     * these strings are IPFS cids representing the import edit message
     *
     * @generated from field: repeated string edits = 1;
     */
    __publicField(this, "edits", []);
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Import().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Import().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Import().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Import, a, b);
  }
};
__publicField(_Import, "runtime", proto3);
__publicField(_Import, "typeName", "grc20.Import");
__publicField(_Import, "fields", proto3.util.newFieldList(() => [
  { no: 1, name: "edits", kind: "scalar", T: 9, repeated: true }
]));
var Import = _Import;
var _File = class _File extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: string version = 1;
     */
    __publicField(this, "version", "");
    /**
     * @generated from oneof grc20.File.payload
     */
    __publicField(this, "payload", { case: void 0 });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _File().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _File().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _File().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_File, a, b);
  }
};
__publicField(_File, "runtime", proto3);
__publicField(_File, "typeName", "grc20.File");
__publicField(_File, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "add_edit", kind: "message", T: Edit, oneof: "payload" },
  { no: 3, name: "import_space", kind: "message", T: Import, oneof: "payload" },
  { no: 4, name: "archive_space", kind: "scalar", T: 12, oneof: "payload" }
]));
var File = _File;
var _Op = class _Op extends Message {
  constructor(data) {
    super();
    /**
     * @generated from oneof grc20.Op.payload
     */
    __publicField(this, "payload", { case: void 0 });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Op().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Op().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Op().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Op, a, b);
  }
};
__publicField(_Op, "runtime", proto3);
__publicField(_Op, "typeName", "grc20.Op");
__publicField(_Op, "fields", proto3.util.newFieldList(() => [
  { no: 1, name: "update_entity", kind: "message", T: Entity, oneof: "payload" },
  { no: 2, name: "create_relation", kind: "message", T: Relation, oneof: "payload" },
  { no: 3, name: "update_relation", kind: "message", T: RelationUpdate, oneof: "payload" },
  { no: 4, name: "delete_relation", kind: "scalar", T: 12, oneof: "payload" },
  { no: 5, name: "create_property", kind: "message", T: Property, oneof: "payload" },
  { no: 6, name: "unset_entity_values", kind: "message", T: UnsetEntityValues, oneof: "payload" },
  { no: 7, name: "unset_relation_fields", kind: "message", T: UnsetRelationFields, oneof: "payload" }
]));
var Op = _Op;
var _Property = class _Property extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: grc20.DataType data_type = 2;
     */
    __publicField(this, "dataType", DataType.TEXT);
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Property().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Property().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Property().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Property, a, b);
  }
};
__publicField(_Property, "runtime", proto3);
__publicField(_Property, "typeName", "grc20.Property");
__publicField(_Property, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "data_type", kind: "enum", T: proto3.getEnumType(DataType) }
]));
var Property = _Property;
var _UnsetEntityValues = class _UnsetEntityValues extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: repeated bytes properties = 2;
     */
    __publicField(this, "properties", []);
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UnsetEntityValues().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UnsetEntityValues().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UnsetEntityValues().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_UnsetEntityValues, a, b);
  }
};
__publicField(_UnsetEntityValues, "runtime", proto3);
__publicField(_UnsetEntityValues, "typeName", "grc20.UnsetEntityValues");
__publicField(_UnsetEntityValues, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "properties", kind: "scalar", T: 12, repeated: true }
]));
var UnsetEntityValues = _UnsetEntityValues;
var _Relation = class _Relation extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: bytes type = 2;
     */
    __publicField(this, "type", new Uint8Array(0));
    /**
     * @generated from field: bytes from_entity = 3;
     */
    __publicField(this, "fromEntity", new Uint8Array(0));
    /**
     * @generated from field: optional bytes from_space = 4;
     */
    __publicField(this, "fromSpace");
    /**
     * @generated from field: optional bytes from_version = 5;
     */
    __publicField(this, "fromVersion");
    /**
     * @generated from field: bytes to_entity = 6;
     */
    __publicField(this, "toEntity", new Uint8Array(0));
    /**
     * @generated from field: optional bytes to_space = 7;
     */
    __publicField(this, "toSpace");
    /**
     * @generated from field: optional bytes to_version = 8;
     */
    __publicField(this, "toVersion");
    /**
     * @generated from field: bytes entity = 9;
     */
    __publicField(this, "entity", new Uint8Array(0));
    /**
     * @generated from field: optional string position = 10;
     */
    __publicField(this, "position");
    /**
     * @generated from field: optional bool verified = 11;
     */
    __publicField(this, "verified");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Relation().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Relation().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Relation().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Relation, a, b);
  }
};
__publicField(_Relation, "runtime", proto3);
__publicField(_Relation, "typeName", "grc20.Relation");
__publicField(_Relation, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "type",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 3,
    name: "from_entity",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 4, name: "from_space", kind: "scalar", T: 12, opt: true },
  { no: 5, name: "from_version", kind: "scalar", T: 12, opt: true },
  {
    no: 6,
    name: "to_entity",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 7, name: "to_space", kind: "scalar", T: 12, opt: true },
  { no: 8, name: "to_version", kind: "scalar", T: 12, opt: true },
  {
    no: 9,
    name: "entity",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 10, name: "position", kind: "scalar", T: 9, opt: true },
  { no: 11, name: "verified", kind: "scalar", T: 8, opt: true }
]));
var Relation = _Relation;
var _RelationUpdate = class _RelationUpdate extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: optional bytes from_space = 2;
     */
    __publicField(this, "fromSpace");
    /**
     * @generated from field: optional bytes from_version = 3;
     */
    __publicField(this, "fromVersion");
    /**
     * @generated from field: optional bytes to_space = 4;
     */
    __publicField(this, "toSpace");
    /**
     * @generated from field: optional bytes to_version = 5;
     */
    __publicField(this, "toVersion");
    /**
     * @generated from field: optional string position = 6;
     */
    __publicField(this, "position");
    /**
     * @generated from field: optional bool verified = 7;
     */
    __publicField(this, "verified");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _RelationUpdate().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _RelationUpdate().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _RelationUpdate().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_RelationUpdate, a, b);
  }
};
__publicField(_RelationUpdate, "runtime", proto3);
__publicField(_RelationUpdate, "typeName", "grc20.RelationUpdate");
__publicField(_RelationUpdate, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "from_space", kind: "scalar", T: 12, opt: true },
  { no: 3, name: "from_version", kind: "scalar", T: 12, opt: true },
  { no: 4, name: "to_space", kind: "scalar", T: 12, opt: true },
  { no: 5, name: "to_version", kind: "scalar", T: 12, opt: true },
  { no: 6, name: "position", kind: "scalar", T: 9, opt: true },
  { no: 7, name: "verified", kind: "scalar", T: 8, opt: true }
]));
var RelationUpdate = _RelationUpdate;
var _UnsetRelationFields = class _UnsetRelationFields extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: optional bool from_space = 2;
     */
    __publicField(this, "fromSpace");
    /**
     * @generated from field: optional bool from_version = 3;
     */
    __publicField(this, "fromVersion");
    /**
     * @generated from field: optional bool to_space = 4;
     */
    __publicField(this, "toSpace");
    /**
     * @generated from field: optional bool to_version = 5;
     */
    __publicField(this, "toVersion");
    /**
     * @generated from field: optional bool position = 6;
     */
    __publicField(this, "position");
    /**
     * @generated from field: optional bool verified = 7;
     */
    __publicField(this, "verified");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UnsetRelationFields().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _UnsetRelationFields().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UnsetRelationFields().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_UnsetRelationFields, a, b);
  }
};
__publicField(_UnsetRelationFields, "runtime", proto3);
__publicField(_UnsetRelationFields, "typeName", "grc20.UnsetRelationFields");
__publicField(_UnsetRelationFields, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "from_space", kind: "scalar", T: 8, opt: true },
  { no: 3, name: "from_version", kind: "scalar", T: 8, opt: true },
  { no: 4, name: "to_space", kind: "scalar", T: 8, opt: true },
  { no: 5, name: "to_version", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "position", kind: "scalar", T: 8, opt: true },
  { no: 7, name: "verified", kind: "scalar", T: 8, opt: true }
]));
var UnsetRelationFields = _UnsetRelationFields;
var _Entity = class _Entity extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: repeated grc20.Value values = 2;
     */
    __publicField(this, "values", []);
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Entity().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Entity().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Entity().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Entity, a, b);
  }
};
__publicField(_Entity, "runtime", proto3);
__publicField(_Entity, "typeName", "grc20.Entity");
__publicField(_Entity, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "values", kind: "message", T: Value2, repeated: true }
]));
var Entity = _Entity;
var _Options = class _Options extends Message {
  constructor(data) {
    super();
    /**
     * @generated from oneof grc20.Options.value
     */
    __publicField(this, "value", { case: void 0 });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Options().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Options().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Options().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Options, a, b);
  }
};
__publicField(_Options, "runtime", proto3);
__publicField(_Options, "typeName", "grc20.Options");
__publicField(_Options, "fields", proto3.util.newFieldList(() => [
  { no: 1, name: "text", kind: "message", T: TextOptions, oneof: "value" },
  { no: 2, name: "number", kind: "message", T: NumberOptions, oneof: "value" }
]));
var Options = _Options;
var _Value = class _Value extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes property = 1;
     */
    __publicField(this, "property", new Uint8Array(0));
    /**
     * @generated from field: string value = 2;
     */
    __publicField(this, "value", "");
    /**
     * @generated from field: optional grc20.Options options = 3;
     */
    __publicField(this, "options");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Value().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_Value, a, b);
  }
};
__publicField(_Value, "runtime", proto3);
__publicField(_Value, "typeName", "grc20.Value");
__publicField(_Value, "fields", proto3.util.newFieldList(() => [
  {
    no: 1,
    name: "property",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "options", kind: "message", T: Options, opt: true }
]));
var Value2 = _Value;
var _TextOptions = class _TextOptions extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: optional bytes language = 1;
     */
    __publicField(this, "language");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _TextOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _TextOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _TextOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_TextOptions, a, b);
  }
};
__publicField(_TextOptions, "runtime", proto3);
__publicField(_TextOptions, "typeName", "grc20.TextOptions");
__publicField(_TextOptions, "fields", proto3.util.newFieldList(() => [
  { no: 1, name: "language", kind: "scalar", T: 12, opt: true }
]));
var TextOptions = _TextOptions;
var _NumberOptions = class _NumberOptions extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: optional bytes unit = 1;
     */
    __publicField(this, "unit");
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _NumberOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _NumberOptions().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _NumberOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(_NumberOptions, a, b);
  }
};
__publicField(_NumberOptions, "runtime", proto3);
__publicField(_NumberOptions, "typeName", "grc20.NumberOptions");
__publicField(_NumberOptions, "fields", proto3.util.newFieldList(() => [
  { no: 1, name: "unit", kind: "scalar", T: 12, opt: true }
]));
var NumberOptions = _NumberOptions;

// node_modules/@graphprotocol/grc-20/dist/src/proto/edit.js
var edit_exports = {};
__export(edit_exports, {
  encode: () => encode
});
function hexToBytes(hex) {
  let hexString = hex;
  if (hexString.startsWith("0x")) {
    hexString = hexString.slice(2);
  }
  if (hex.length % 2 !== 0) {
    throw new Error("Invalid hex string: must have an even length");
  }
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}
function encode({ name, ops, author, language }) {
  return new Edit({
    id: toBytes(generate()),
    name,
    ops: opsToBinary(ops),
    authors: [hexToBytes(author)],
    language: language ? toBytes(language) : void 0
  }).toBinary();
}
function convertRelationIdsToBase64(relation) {
  const result = {
    id: toBase64(relation.id),
    type: toBase64(relation.type),
    from_entity: toBase64(relation.fromEntity),
    to_entity: toBase64(relation.toEntity),
    entity: toBase64(relation.entity)
  };
  if (relation.fromSpace) {
    result.from_space = toBase64(relation.fromSpace);
  }
  if (relation.fromVersion) {
    result.from_version = toBase64(relation.fromVersion);
  }
  if (relation.toSpace) {
    result.to_space = toBase64(relation.toSpace);
  }
  if (relation.toVersion) {
    result.to_version = toBase64(relation.toVersion);
  }
  if (relation.position !== void 0) {
    result.position = relation.position;
  }
  if (relation.verified !== void 0) {
    result.verified = relation.verified;
  }
  return result;
}
function convertUnsetEntityValuesToBase64(unsetEntityValues2) {
  return {
    id: toBase64(unsetEntityValues2.id),
    properties: unsetEntityValues2.properties.map((propertyId) => toBase64(propertyId))
  };
}
function convertUpdateRelationToBase64(relation) {
  const result = {
    id: toBase64(relation.id)
  };
  if (relation.fromSpace) {
    result.from_space = toBase64(relation.fromSpace);
  }
  if (relation.fromVersion) {
    result.from_version = toBase64(relation.fromVersion);
  }
  if (relation.toSpace) {
    result.to_space = toBase64(relation.toSpace);
  }
  if (relation.toVersion) {
    result.to_version = toBase64(relation.toVersion);
  }
  if (relation.position !== void 0) {
    result.position = relation.position;
  }
  if (relation.verified !== void 0) {
    result.verified = relation.verified;
  }
  return result;
}
function convertUnsetRelationFieldsToBase64(unsetRelationFields2) {
  const result = {
    id: toBase64(unsetRelationFields2.id)
  };
  if (unsetRelationFields2.fromSpace !== void 0) {
    result.from_space = unsetRelationFields2.fromSpace;
  }
  if (unsetRelationFields2.fromVersion !== void 0) {
    result.from_version = unsetRelationFields2.fromVersion;
  }
  if (unsetRelationFields2.toSpace !== void 0) {
    result.to_space = unsetRelationFields2.toSpace;
  }
  if (unsetRelationFields2.toVersion !== void 0) {
    result.to_version = unsetRelationFields2.toVersion;
  }
  if (unsetRelationFields2.position !== void 0) {
    result.position = unsetRelationFields2.position;
  }
  if (unsetRelationFields2.verified !== void 0) {
    result.verified = unsetRelationFields2.verified;
  }
  return result;
}
function convertUpdateEntityToBase64(entity) {
  return {
    id: toBase64(entity.id).toString(),
    values: entity.values.map((value) => {
      let options;
      if (value.options) {
        if (value.options.text) {
          options = {
            text: {
              ...value.options.text.language ? {
                language: toBase64(Id(value.options.text.language)).toString()
              } : null
            }
          };
        } else if (value.options.number) {
          options = {
            number: {
              ...value.options.number.unit ? { unit: toBase64(Id(value.options.number.unit)).toString() } : {}
            }
          };
        }
      }
      const valueEntry = {
        property: toBase64(value.property).toString(),
        value: value.value
      };
      if (options) {
        valueEntry.options = options;
      }
      return valueEntry;
    })
  };
}
function convertPropertyToBase64(property) {
  return {
    id: toBase64(property.id).toString(),
    dataType: property.dataType
  };
}
function opsToBinary(ops) {
  return ops.map((o) => {
    switch (o.type) {
      case "CREATE_RELATION":
        return new Op({
          payload: {
            case: "createRelation",
            value: Relation.fromJson(convertRelationIdsToBase64(o.relation))
          }
        });
      case "CREATE_PROPERTY":
        return new Op({
          payload: {
            case: "createProperty",
            value: Property.fromJson(convertPropertyToBase64(o.property))
          }
        });
      case "DELETE_RELATION":
        return new Op({
          payload: {
            case: "deleteRelation",
            value: toBytes(o.id)
          }
        });
      case "UPDATE_ENTITY":
        return new Op({
          payload: {
            case: "updateEntity",
            value: Entity.fromJson(convertUpdateEntityToBase64(o.entity))
          }
        });
      case "UNSET_ENTITY_VALUES":
        return new Op({
          payload: {
            case: "unsetEntityValues",
            value: UnsetEntityValues.fromJson(convertUnsetEntityValuesToBase64(o.unsetEntityValues))
          }
        });
      case "UPDATE_RELATION":
        return new Op({
          payload: {
            case: "updateRelation",
            value: RelationUpdate.fromJson(convertUpdateRelationToBase64(o.relation))
          }
        });
      case "UNSET_RELATION_FIELDS":
        return new Op({
          payload: {
            case: "unsetRelationFields",
            value: UnsetRelationFields.fromJson(convertUnsetRelationFieldsToBase64(o.unsetRelationFields))
          }
        });
    }
  });
}

// node_modules/@graphprotocol/grc-20/dist/src/ipfs.js
var IpfsUploadError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "_tag", "IpfsUploadError");
  }
};
async function publishEdit(args) {
  const { name, ops, author, network = "MAINNET" } = args;
  const edit = edit_exports.encode({ name, ops, author });
  const blob = new Blob([edit], { type: "application/octet-stream" });
  const formData = new FormData();
  formData.append("file", blob);
  const cid = await Micro_exports.runPromise(uploadBinary(formData, network));
  const result = Edit.fromBinary(edit);
  return { cid, editId: fromBytes(result.id) };
}
async function uploadImage(params, network) {
  const formData = new FormData();
  let blob;
  if ("blob" in params) {
    blob = params.blob;
  } else {
    const response = await fetch(params.url);
    blob = await response.blob();
  }
  formData.append("file", blob);
  const buffer = Buffer.from(await blob.arrayBuffer());
  let dimensions;
  try {
    dimensions = imageSize(buffer);
  } catch (error) {
  }
  const cid = await Micro_exports.runPromise(uploadFile(formData, network));
  if (dimensions) {
    return {
      cid,
      dimensions: {
        width: dimensions.width,
        height: dimensions.height
      }
    };
  }
  return {
    cid
  };
}
async function uploadCSV(csvString, network) {
  const encoder = new TextEncoder();
  const csvStringBytes = encoder.encode(csvString);
  const blob = await gzipSync(csvStringBytes);
  const formData = new FormData();
  formData.append("file", new Blob([blob], { type: "text/csv" }));
  return await Micro_exports.runPromise(uploadBinary(formData, network));
}
function uploadBinary(formData, network) {
  return Micro_exports.gen(function* () {
    const result = yield* Micro_exports.tryPromise({
      try: () => fetch(`${network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN}/ipfs/upload-edit`, {
        method: "POST",
        body: formData
      }),
      catch: (error) => new IpfsUploadError(`Could not upload data to IPFS: ${error}`)
    });
    const maybeCid = yield* Micro_exports.tryPromise({
      try: async () => {
        const { cid } = await result.json();
        return cid;
      },
      catch: (error) => new IpfsUploadError(`Could not parse response from IPFS: ${error}`)
    });
    return maybeCid;
  });
}
function uploadFile(formData, network) {
  return Micro_exports.gen(function* () {
    const result = yield* Micro_exports.tryPromise({
      try: () => fetch(`${network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN}/ipfs/upload-file`, {
        method: "POST",
        body: formData
      }),
      catch: (error) => new IpfsUploadError(`Could not upload file to IPFS: ${error}`)
    });
    const maybeCid = yield* Micro_exports.tryPromise({
      try: async () => {
        const { cid } = await result.json();
        return cid;
      },
      catch: (error) => new IpfsUploadError(`Could not parse response from IPFS: ${error}`)
    });
    return maybeCid;
  });
}

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-image.js
var createImage = async ({ name, description, id: providedId, ...params }) => {
  if (providedId)
    assertValid(providedId, "`id` in `createImage`");
  const id = providedId ?? generate();
  const { cid, dimensions } = await uploadImage(params);
  const values = [];
  values.push({
    property: IMAGE_URL_PROPERTY,
    value: cid
  });
  if (dimensions == null ? void 0 : dimensions.height) {
    values.push({
      property: IMAGE_HEIGHT_PROPERTY,
      value: dimensions.height.toString()
    });
  }
  if (dimensions == null ? void 0 : dimensions.width) {
    values.push({
      property: IMAGE_WIDTH_PROPERTY,
      value: dimensions.width.toString()
    });
  }
  const { ops } = createEntity({
    id,
    name,
    description,
    values
  });
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: generate(),
      entity: generate(),
      fromEntity: Id(id),
      toEntity: IMAGE_TYPE,
      type: TYPES_PROPERTY
    }
  });
  return {
    id: Id(id),
    ops
  };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-property.js
var createProperty = (params) => {
  const { id, name, description, cover } = params;
  if (id) {
    assertValid(id, "`id` in `createProperty`");
  }
  if (cover)
    assertValid(cover, "`cover` in `createProperty`");
  if (params.dataType === "RELATION") {
    for (const propertyId of params.properties ?? []) {
      assertValid(propertyId, "`properties` in `createProperty`");
    }
    for (const relationValueTypeId of params.relationValueTypes ?? []) {
      assertValid(relationValueTypeId, "`relationValueTypes` in `createProperty`");
    }
  }
  const entityId = id ?? generate();
  const ops = [];
  ops.push({
    type: "CREATE_PROPERTY",
    property: {
      id: Id(entityId),
      dataType: params.dataType
    }
  });
  const { ops: entityOps } = createEntity({
    id: entityId,
    name,
    description,
    cover
  });
  ops.push(...entityOps);
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: generate(),
      entity: generate(),
      fromEntity: Id(entityId),
      toEntity: PROPERTY,
      type: TYPES_PROPERTY
    }
  });
  if (params.dataType === "RELATION") {
    if (params.properties) {
      for (const propertyId of params.properties) {
        assertValid(propertyId);
        const { ops: relationOps } = createRelation({
          fromEntity: entityId,
          toEntity: propertyId,
          type: PROPERTY
        });
        ops.push(...relationOps);
      }
    }
    if (params.relationValueTypes) {
      for (const relationValueTypeId of params.relationValueTypes) {
        assertValid(relationValueTypeId);
        const { ops: relationOps } = createRelation({
          fromEntity: entityId,
          toEntity: relationValueTypeId,
          type: RELATION_VALUE_RELATIONSHIP_TYPE
        });
        ops.push(...relationOps);
      }
    }
  }
  return { id: Id(entityId), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-space.js
var createSpace = async (params) => {
  const apiHost = params.network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN;
  console.log("apiHost", apiHost);
  const formData = new FormData();
  formData.append("name", params.name);
  formData.append("editorAddress", params.editorAddress);
  if (params.spaceEntityId) {
    formData.append("spaceEntityId", params.spaceEntityId);
  }
  if (params.ops) {
    formData.append("ops", JSON.stringify(params.ops));
  }
  const result = await fetch(`${apiHost}/deploy`, {
    method: "POST",
    body: JSON.stringify({
      spaceName: params.name,
      initialEditorAddress: params.editorAddress,
      ops: params.ops,
      spaceEntityId: params.spaceEntityId
    }),
    headers: {
      "Content-Type": "application/json"
    }
  });
  const jsonResult = await result.json();
  return { id: jsonResult.spaceId };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-type.js
var createType = ({ id: providedId, name, description, cover, properties }) => {
  if (providedId) {
    assertValid(providedId, "`id` in `createType`");
  }
  for (const propertyId of properties ?? []) {
    assertValid(propertyId, "`properties` in `createType`");
  }
  const id = providedId ?? generate();
  const { ops } = createEntity({
    id,
    name,
    description,
    cover
  });
  assertValid(id);
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: generate(),
      entity: generate(),
      fromEntity: Id(id),
      toEntity: SCHEMA_TYPE,
      type: TYPES_PROPERTY
    }
  });
  if (properties) {
    for (const propertyId of properties) {
      assertValid(propertyId, "`propertyId` in `createType`");
      ops.push({
        type: "CREATE_RELATION",
        relation: {
          id: generate(),
          entity: generate(),
          fromEntity: Id(id),
          toEntity: Id(propertyId),
          type: PROPERTY
        }
      });
    }
  }
  return { id: Id(id), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/delete-relation.js
var deleteRelation = ({ id }) => {
  assertValid(id, "`id` in `deleteRelation`");
  const op = {
    type: "DELETE_RELATION",
    id: Id(id)
  };
  return { id: Id(id), ops: [op] };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/serialize.js
var serializeNumber = (value) => {
  return value.toString();
};
var serializeCheckbox = (value) => {
  return value ? "1" : "0";
};
var serializeDate = (value) => {
  return value.toISOString();
};
var serializePoint = (value) => {
  return value.join(",");
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/unset-entity-values.js
var unsetEntityValues = ({ id, properties }) => {
  assertValid(id, "`id` in `unsetEntityValues`");
  for (const propertyId of properties) {
    assertValid(propertyId, "`properties` in `unsetEntityValues`");
  }
  const op = {
    type: "UNSET_ENTITY_VALUES",
    unsetEntityValues: {
      id: Id(id),
      properties: properties.map((propertyId) => Id(propertyId))
    }
  };
  return { id: Id(id), ops: [op] };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/unset-relation-fields.js
var unsetRelationFields = ({ id, fromVersion, toSpace, toVersion, position, verified }) => {
  assertValid(id, "`id` in `unsetRelationFields`");
  const op = {
    type: "UNSET_RELATION_FIELDS",
    unsetRelationFields: {
      id: Id(id),
      fromVersion,
      toSpace,
      toVersion,
      position,
      verified
    }
  };
  return { id, ops: [op] };
};

// node_modules/@graphprotocol/grc-20/dist/src/core/position.js
var position_exports = {};
__export(position_exports, {
  compare: () => compare,
  generate: () => generate2,
  generateBetween: () => generateBetween,
  sort: () => sort
});

// node_modules/fractional-indexing-jittered/lib/index.js
function indexCharacterSet(options) {
  const dicts = createCharSetDicts(options.chars);
  const limits = integerLimits(
    dicts,
    options.firstPositive,
    options.mostPositive,
    options.mostNegative
  );
  const jitterRange = options.jitterRange ?? Math.floor(Math.pow(dicts.length, 3) / 5);
  const paddingRange = paddingDict(jitterRange, dicts.length);
  return {
    chars: options.chars,
    byChar: dicts.byChar,
    byCode: dicts.byCode,
    length: dicts.length,
    first: dicts.byCode[0],
    last: dicts.byCode[dicts.length - 1],
    firstPositive: limits.firstPositive,
    mostPositive: limits.mostPositive,
    firstNegative: limits.firstNegative,
    mostNegative: limits.mostNegative,
    jitterRange,
    paddingDict: paddingRange
  };
}
function createCharSetDicts(charSet) {
  const byCode = {};
  const byChar = {};
  const length = charSet.length;
  for (let i = 0; i < length; i++) {
    const char = charSet[i];
    byCode[i] = char;
    byChar[char] = i;
  }
  return {
    byCode,
    byChar,
    length
  };
}
function integerLimits(dicts, firstPositive, mostPositive, mostNegative) {
  const firstPositiveIndex = firstPositive ? dicts.byChar[firstPositive] : Math.ceil(dicts.length / 2);
  const mostPositiveIndex = mostPositive ? dicts.byChar[mostPositive] : dicts.length - 1;
  const mostNegativeIndex = mostNegative ? dicts.byChar[mostNegative] : 0;
  if (firstPositiveIndex === void 0 || mostPositiveIndex === void 0 || mostNegativeIndex === void 0) {
    throw new Error("invalid charSet");
  }
  if (mostPositiveIndex - firstPositiveIndex < 3) {
    throw new Error(
      "mostPositive must be at least 3 characters away from neutral"
    );
  }
  if (firstPositiveIndex - mostNegativeIndex < 3) {
    throw new Error(
      "mostNegative must be at least 3 characters away from neutral"
    );
  }
  return {
    firstPositive: dicts.byCode[firstPositiveIndex],
    mostPositive: dicts.byCode[mostPositiveIndex],
    firstNegative: dicts.byCode[firstPositiveIndex - 1],
    mostNegative: dicts.byCode[mostNegativeIndex]
  };
}
function paddingDict(jitterRange, charSetLength) {
  const paddingDict2 = {};
  let distance = 0;
  for (let i = 0; i < 100; i++) {
    paddingDict2[i] = Math.pow(charSetLength, i);
    if (paddingDict2[i] > jitterRange) {
      break;
    }
  }
  return paddingDict2;
}
var _base62CharSet = null;
function base62CharSet() {
  if (_base62CharSet)
    return _base62CharSet;
  return _base62CharSet = indexCharacterSet({
    // Base62 are all the alphanumeric characters, database and user friendly
    // For shorter strings and more room you could opt for more characters
    chars: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    // This gives us nice human readable keys to start with a0 a1 etc
    firstPositive: "a",
    mostPositive: "z",
    mostNegative: "A"
  });
}
function distanceBetween(a, b, charSet) {
  const indexA = charSet.byChar[a];
  const indexB = charSet.byChar[b];
  return Math.abs(indexA - indexB);
}
function integerLength(head, charSet) {
  const firstChar = head[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive) {
    const firstLevel = distanceBetween(firstChar, charSet.firstPositive, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head.slice(1), "positive", charSet);
  }
  if (firstChar === charSet.mostNegative) {
    const firstLevel = distanceBetween(firstChar, charSet.firstNegative, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head.slice(1), "negative", charSet);
  }
  const isPositiveRange = firstChar >= charSet.firstPositive;
  if (isPositiveRange) {
    return distanceBetween(firstChar, charSet.firstPositive, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.firstNegative, charSet) + 2;
  }
}
function integerLengthFromSecondLevel(key, direction, charSet) {
  const firstChar = key[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive && direction === "positive") {
    const totalPositiveRoom = distanceBetween(firstChar, charSet.mostNegative, charSet) + 1;
    return totalPositiveRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (firstChar === charSet.mostNegative && direction === "negative") {
    const totalNegativeRoom = distanceBetween(firstChar, charSet.mostPositive, charSet) + 1;
    return totalNegativeRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (direction === "positive") {
    return distanceBetween(firstChar, charSet.mostNegative, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.mostPositive, charSet) + 2;
  }
}
function makeSameLength(a, b, pad, fillChar, forceLength) {
  const max2 = forceLength ?? Math.max(a.length, b.length);
  if (pad === "start") {
    return [a.padStart(max2, fillChar), b.padStart(max2, fillChar)];
  }
  return [a.padEnd(max2, fillChar), b.padEnd(max2, fillChar)];
}
function midPoint(lower, upper, charSet) {
  let [paddedLower, paddedUpper] = makeSameLength(
    lower,
    upper,
    "end",
    charSet.first
  );
  let distance = lexicalDistance(paddedLower, paddedUpper, charSet);
  if (distance === 1) {
    paddedLower = paddedLower.padEnd(paddedLower.length + 1, charSet.first);
    distance = charSet.length;
  }
  const mid = encodeToCharSet(Math.floor(distance / 2), charSet);
  return addCharSetKeys(paddedLower, mid, charSet);
}
function lexicalDistance(a, b, charSet) {
  const [lower, upper] = makeSameLength(a, b, "end", charSet.first).sort();
  const distance = subtractCharSetKeys(upper, lower, charSet);
  return decodeCharSetToNumber(distance, charSet);
}
function addCharSetKeys(a, b, charSet) {
  const base = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a, b, "start", charSet.first);
  const result = [];
  let carry = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    const digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]];
    const sum = digitA + digitB + carry;
    carry = Math.floor(sum / base);
    const remainder = sum % base;
    result.unshift(charSet.byCode[remainder]);
  }
  if (carry > 0) {
    result.unshift(charSet.byCode[carry]);
  }
  return result.join("");
}
function subtractCharSetKeys(a, b, charSet, stripLeadingZeros = true) {
  const base = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a, b, "start", charSet.first);
  const result = [];
  let borrow = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    let digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]] + borrow;
    if (digitA < digitB) {
      borrow = 1;
      digitA += base;
    } else {
      borrow = 0;
    }
    const difference = digitA - digitB;
    result.unshift(charSet.byCode[difference]);
  }
  if (borrow > 0) {
    throw new Error(
      "Subtraction result is negative. Ensure a is greater than or equal to b."
    );
  }
  while (stripLeadingZeros && result.length > 1 && result[0] === charSet.first) {
    result.shift();
  }
  return result.join("");
}
function incrementKey(key, charSet) {
  return addCharSetKeys(key, charSet.byCode[1], charSet);
}
function decrementKey(key, charSet) {
  return subtractCharSetKeys(key, charSet.byCode[1], charSet, false);
}
function encodeToCharSet(int, charSet) {
  if (int === 0) {
    return charSet.byCode[0];
  }
  let res = "";
  const max2 = charSet.length;
  while (int > 0) {
    res = charSet.byCode[int % max2] + res;
    int = Math.floor(int / max2);
  }
  return res;
}
function decodeCharSetToNumber(key, charSet) {
  let res = 0;
  const length = key.length;
  const max2 = charSet.length;
  for (let i = 0; i < length; i++) {
    res += charSet.byChar[key[i]] * Math.pow(max2, length - i - 1);
  }
  return res;
}
function startKey(charSet) {
  return charSet.firstPositive + charSet.byCode[0];
}
function validInteger(integer, charSet) {
  const length = integerLength(integer, charSet);
  return length === integer.length;
}
function validateOrderKey(orderKey, charSet) {
  getIntegerPart(orderKey, charSet);
}
function getIntegerPart(orderKey, charSet) {
  const head = integerHead(orderKey, charSet);
  const integerPartLength = integerLength(head, charSet);
  if (integerPartLength > orderKey.length) {
    throw new Error("invalid order key length: " + orderKey);
  }
  return orderKey.slice(0, integerPartLength);
}
function validateInteger(integer, charSet) {
  if (!validInteger(integer, charSet)) {
    throw new Error("invalid integer length: " + integer);
  }
}
function incrementInteger(integer, charSet) {
  validateInteger(integer, charSet);
  const [head, digs] = splitInteger(integer, charSet);
  const anyNonMaxedDigit = digs.split("").some((d) => d !== charSet.byCode[charSet.length - 1]);
  if (anyNonMaxedDigit) {
    const newDigits = incrementKey(digs, charSet);
    return head + newDigits;
  }
  const nextHead = incrementIntegerHead(head, charSet);
  return startOnNewHead(nextHead, "lower", charSet);
}
function decrementInteger(integer, charSet) {
  validateInteger(integer, charSet);
  const [head, digs] = splitInteger(integer, charSet);
  const anyNonLimitDigit = digs.split("").some((d) => d !== charSet.byCode[0]);
  if (anyNonLimitDigit) {
    const newDigits = decrementKey(digs, charSet);
    return head + newDigits;
  }
  const nextHead = decrementIntegerHead(head, charSet);
  return startOnNewHead(nextHead, "upper", charSet);
}
function integerHead(integer, charSet) {
  let i = 0;
  if (integer[0] === charSet.mostPositive) {
    while (integer[i] === charSet.mostPositive) {
      i = i + 1;
    }
  }
  if (integer[0] === charSet.mostNegative) {
    while (integer[i] === charSet.mostNegative) {
      i = i + 1;
    }
  }
  return integer.slice(0, i + 1);
}
function splitInteger(integer, charSet) {
  const head = integerHead(integer, charSet);
  const tail = integer.slice(head.length);
  return [head, tail];
}
function incrementIntegerHead(head, charSet) {
  const inPositiveRange = head >= charSet.firstPositive;
  const nextHead = incrementKey(head, charSet);
  const headIsLimitMax = head[head.length - 1] === charSet.mostPositive;
  const nextHeadIsLimitMax = nextHead[nextHead.length - 1] === charSet.mostPositive;
  if (inPositiveRange && nextHeadIsLimitMax) {
    return nextHead + charSet.mostNegative;
  }
  if (!inPositiveRange && headIsLimitMax) {
    return head.slice(0, head.length - 1);
  }
  return nextHead;
}
function decrementIntegerHead(head, charSet) {
  const inPositiveRange = head >= charSet.firstPositive;
  const headIsLimitMin = head[head.length - 1] === charSet.mostNegative;
  if (inPositiveRange && headIsLimitMin) {
    const nextLevel = head.slice(0, head.length - 1);
    return decrementKey(nextLevel, charSet);
  }
  if (!inPositiveRange && headIsLimitMin) {
    return head + charSet.mostPositive;
  }
  return decrementKey(head, charSet);
}
function startOnNewHead(head, limit, charSet) {
  const newLength = integerLength(head, charSet);
  const fillChar = limit === "upper" ? charSet.byCode[charSet.length - 1] : charSet.byCode[0];
  return head + fillChar.repeat(newLength - head.length);
}
function jitterString(orderKey, charSet) {
  const shift = encodeToCharSet(
    Math.floor(Math.random() * charSet.jitterRange),
    charSet
  );
  return addCharSetKeys(orderKey, shift, charSet);
}
function padAndJitterString(orderKey, numberOfChars, charSet) {
  const paddedKey = orderKey.padEnd(
    orderKey.length + numberOfChars,
    charSet.first
  );
  return jitterString(paddedKey, charSet);
}
function paddingNeededForJitter(orderKey, b, charSet) {
  const integer = getIntegerPart(orderKey, charSet);
  const nextInteger = incrementInteger(integer, charSet);
  let needed = 0;
  if (b !== null) {
    const distanceToB = lexicalDistance(orderKey, b, charSet);
    if (distanceToB < charSet.jitterRange + 1) {
      needed = Math.max(needed, paddingNeededForDistance(distanceToB, charSet));
    }
  }
  const distanceToNextInteger = lexicalDistance(orderKey, nextInteger, charSet);
  if (distanceToNextInteger < charSet.jitterRange + 1) {
    needed = Math.max(
      needed,
      paddingNeededForDistance(distanceToNextInteger, charSet)
    );
  }
  return needed;
}
function paddingNeededForDistance(distance, charSet) {
  const gap = charSet.jitterRange - distance;
  const firstBigger = Object.entries(charSet.paddingDict).find(
    ([_key, value]) => {
      return value > gap;
    }
  );
  return firstBigger ? parseInt(firstBigger[0]) : 0;
}
function generateKeyBetween(lower, upper, charSet = base62CharSet()) {
  if (lower !== null) {
    validateOrderKey(lower, charSet);
  }
  if (upper !== null) {
    validateOrderKey(upper, charSet);
  }
  if (lower === null && upper === null) {
    return startKey(charSet);
  }
  if (lower === null) {
    const integer = getIntegerPart(upper, charSet);
    return decrementInteger(integer, charSet);
  }
  if (upper === null) {
    const integer = getIntegerPart(lower, charSet);
    return incrementInteger(integer, charSet);
  }
  if (lower >= upper) {
    throw new Error(lower + " >= " + upper);
  }
  return midPoint(lower, upper, charSet);
}
function generateJitteredKeyBetween(lower, upper, charSet = base62CharSet()) {
  const key = generateKeyBetween(lower, upper, charSet);
  const paddingNeeded = paddingNeededForJitter(key, upper, charSet);
  if (paddingNeeded) {
    return padAndJitterString(key, paddingNeeded, charSet);
  }
  return jitterString(key, charSet);
}

// node_modules/@graphprotocol/grc-20/dist/src/core/position.js
function generateBetween(first, second) {
  return generateJitteredKeyBetween(first, second);
}
function generate2() {
  return generateBetween(null, null);
}
function compare(a, b) {
  if (a === null && b === null)
    return 0;
  if (a === null)
    return 1;
  if (b === null)
    return -1;
  return a.localeCompare(b);
}
function sort(positions) {
  return positions.sort(compare);
}

// node_modules/@graphprotocol/grc-20/dist/src/core/scheme.js
var scheme_exports = {};
__export(scheme_exports, {
  fromEntityId: () => fromEntityId,
  isValid: () => isValid2,
  toEntityId: () => toEntityId,
  toSpaceId: () => toSpaceId
});
var SPACE_SEARCH_PARAM = "s";
var SCHEME_PREFIX = "graph";
function fromEntityId(entityId, params = {}) {
  if (isValid2(entityId)) {
    throw new Error(`The passed in entityId should not start with ${SCHEME_PREFIX}://`);
  }
  let uri = `${SCHEME_PREFIX}://${entityId}`;
  if (params.spaceId) {
    uri = `${uri}?${SPACE_SEARCH_PARAM}=${params.spaceId}`;
  }
  return uri;
}
function isValid2(value) {
  return value.startsWith(`${SCHEME_PREFIX}://`);
}
function toEntityId(uri) {
  var _a2, _b2;
  const entity = (_b2 = (_a2 = uri.split(`${SCHEME_PREFIX}://`)) == null ? void 0 : _a2[1]) == null ? void 0 : _b2.split("?")[0];
  if (!entity) {
    throw new Error(`Could not parse entity id from provided URI: ${uri}`);
  }
  return entity;
}
function toSpaceId(uri) {
  const url = new URL(uri);
  const searchParams = url.searchParams;
  if (!searchParams.has(SPACE_SEARCH_PARAM)) {
    return null;
  }
  return searchParams.get(SPACE_SEARCH_PARAM);
}

// node_modules/@graphprotocol/grc-20/dist/src/smart-wallet.js
var MAINNET_DEFAULT_RPC_URL = "https://rpc-geo-genesis-h0q2s21xx8.t.conduit.xyz";
var TESTNET_DEFAULT_RPC_URL = "https://rpc-geo-test-zc16z3tcvf.t.conduit.xyz";
var DEFAULT_API_KEY = "pim_KqHm63txxhbCYjdDaWaHqH";
var createChain = (network, rpcUrl) => {
  const chain = {
    id: network === "TESTNET" ? Number("19411") : Number("80451"),
    name: "Geo Genesis",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: [rpcUrl ?? (network === "TESTNET" ? TESTNET_DEFAULT_RPC_URL : MAINNET_DEFAULT_RPC_URL)]
      },
      public: {
        http: [rpcUrl ?? (network === "TESTNET" ? TESTNET_DEFAULT_RPC_URL : MAINNET_DEFAULT_RPC_URL)]
      }
    }
  };
  return chain;
};
var getSmartAccountWalletClient = async ({ privateKey, rpcUrl = MAINNET_DEFAULT_RPC_URL }) => {
  const chain = createChain("MAINNET", rpcUrl);
  const transport = http(rpcUrl);
  const publicClient = createPublicClient({
    transport,
    chain
  });
  const safeAccount = await toSafeSmartAccount({
    client: publicClient,
    owners: [privateKeyToAccount(privateKey)],
    entryPoint: {
      // optional, defaults to 0.7
      address: entryPoint07Address,
      version: "0.7"
    },
    version: "1.4.1"
  });
  const bundlerTransport = http(`https://api.pimlico.io/v2/80451/rpc?apikey=${DEFAULT_API_KEY}`);
  const paymasterClient = createPimlicoClient({
    transport: bundlerTransport,
    chain,
    entryPoint: {
      address: entryPoint07Address,
      version: "0.7"
    }
  });
  const smartAccount = createSmartAccountClient({
    chain,
    account: safeAccount,
    paymaster: paymasterClient,
    bundlerTransport,
    userOperation: {
      estimateFeesPerGas: async () => {
        return (await paymasterClient.getUserOperationGasPrice()).fast;
      }
    }
  });
  return smartAccount;
};
var getWalletClient = async ({ privateKey, rpcUrl = TESTNET_DEFAULT_RPC_URL }) => {
  const chain = createChain("TESTNET", rpcUrl);
  const transport = http(rpcUrl);
  const wallet = createWalletClient({
    account: privateKeyToAccount(privateKey),
    chain,
    transport
  });
  return wallet;
};

// node_modules/@graphprotocol/grc-20/dist/src/core/base58.js
var base58_exports = {};
__export(base58_exports, {
  BASE58_ALLOWED_CHARS: () => BASE58_ALLOWED_CHARS,
  decodeBase58ToUUID: () => decodeBase58ToUUID,
  encodeBase58: () => encodeBase58
});
var BASE58_ALLOWED_CHARS = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encodeBase58(val) {
  const hex = BigInt(`0x${val}`);
  let remainder = hex;
  const result = [];
  while (remainder > 0n) {
    const mod = remainder % 58n;
    const base58CharAtMod = BASE58_ALLOWED_CHARS[Number(mod)];
    if (base58CharAtMod) {
      result.push(base58CharAtMod);
    }
    remainder = remainder / 58n;
  }
  return result.reverse().join("");
}
function decodeBase58ToUUID(encoded) {
  let decoded = 0n;
  for (const char of encoded) {
    const index = BASE58_ALLOWED_CHARS.indexOf(char);
    if (index === -1) {
      throw new Error("Invalid Base58 character");
    }
    decoded = decoded * 58n + BigInt(index);
  }
  let hexStr = decoded.toString(16);
  hexStr = hexStr.padStart(32, "0");
  return [hexStr.slice(0, 8), hexStr.slice(8, 12), hexStr.slice(12, 16), hexStr.slice(16, 20), hexStr.slice(20)].join("-");
}

export {
  VoteOption,
  id_exports,
  getProcessGeoProposalArguments,
  getAcceptSubspaceArguments,
  getRemoveSubspaceArguments,
  getAcceptEditorArguments,
  getRemoveEditorArguments,
  getCalldataForSpaceGovernanceType,
  system_exports,
  getChecksumAddress,
  network_exports,
  account_exports,
  content_exports,
  data_exports,
  text_exports,
  encoding_exports,
  ipfs_exports,
  graph_exports,
  position_exports,
  scheme_exports,
  getSmartAccountWalletClient,
  getWalletClient,
  base58_exports
};
//# sourceMappingURL=chunk-6X5HNRIJ.js.map
