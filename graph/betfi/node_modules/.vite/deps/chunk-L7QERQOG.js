import {
  AccountNotFoundError,
  Array$,
  Boolean$,
  Class,
  Date$,
  Effect_exports,
  Literal,
  Number$,
  Record,
  Schema_exports,
  String$,
  Struct,
  TaggedError,
  URL$,
  Uint8Array$,
  Undefined,
  Union,
  abool,
  abytes,
  aexists,
  anumber,
  aoutput,
  blake2b,
  blake3,
  bytesToHex,
  checkOpts,
  clean,
  copyBytes,
  createPimlicoClient,
  createPublicClient,
  createSmartAccountClient,
  decodeEither,
  decodeSync,
  decodeUnknownSync,
  dual,
  encodeInstallModule,
  encodePacked,
  encodeSync,
  entryPoint07Address,
  equalBytes,
  evolve,
  fail,
  fromKey,
  gcm,
  generatePrivateKey,
  getAccountNonce,
  getAction,
  getOutput,
  getUserOperationHash,
  hasProperty,
  hashTypedData,
  hexToBytes,
  http,
  isLeft,
  isPropertySignature,
  isSchema,
  optional,
  parseModuleTypeId,
  parse_default,
  partial,
  pipeArguments,
  privateKeyToAccount,
  propertySignature,
  publicKeyToAddress,
  readContract,
  sendUserOperation,
  sha256,
  stringify_default,
  succeed,
  supportsExecutionMode,
  supportsModule,
  toBytes,
  toSafeSmartAccount,
  transform,
  u32,
  u64Lengths,
  v4_default,
  validateSync,
  verifyMessage,
  wrapCipher,
  zeroAddress
} from "./chunk-UMZOSOLW.js";
import {
  Field,
  FpInvertBatch,
  FpSqrtEven,
  _createCurveFields,
  createHasher,
  hmac,
  isNegativeLE,
  mod,
  normalizeZ,
  pippenger,
  pow2,
  secp256k1,
  sha512,
  wNAF
} from "./chunk-C2RWQPKW.js";
import {
  ContractFunctionExecutionError,
  call,
  concat,
  decodeFunctionResult,
  encodeAbiParameters,
  encodeFunctionData,
  fromHex,
  getAbiItem,
  getAddress,
  isAddress,
  keccak256,
  pad,
  parseAbi,
  parseAbiParameters,
  parseAccount,
  slice,
  toBytes as toBytes3,
  toFunctionSelector,
  toHex
} from "./chunk-6CZFMNNW.js";
import {
  _validateObject,
  aInRange,
  abool as abool2,
  abytes as abytes2,
  ahash,
  anumber as anumber2,
  bytesToHex as bytesToHex2,
  bytesToNumberLE,
  bytesToUtf8,
  clean as clean2,
  concatBytes,
  ensureBytes,
  equalBytes as equalBytes2,
  hexToBytes as hexToBytes2,
  memoized,
  numberToBytesLE,
  randomBytes,
  toBytes as toBytes2,
  u32 as u322,
  u8,
  utf8ToBytes
} from "./chunk-OBH2DAM5.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/solady/js/solady.js
var require_solady = __commonJS({
  "node_modules/solady/js/solady.js"(exports, module) {
    (function(global, factory) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(global, 1);
        if (typeof exports === "object") {
          exports.LibZip = module.exports.LibZip;
          exports.ERC1967Factory = module.exports.ERC1967Factory;
        }
      } else {
        factory(global);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var solady = {};
      var LibZip2 = {};
      solady.LibZip = LibZip2;
      function hexString(data) {
        if (typeof data === "string" || data instanceof String) {
          if (data = data.match(/^[\s\uFEFF\xA0]*(0[Xx])?([0-9A-Fa-f]*)[\s\uFEFF\xA0]*$/)) {
            if (data[2].length % 2) {
              throw new Error("Hex string length must be a multiple of 2.");
            }
            return data[2];
          }
        }
        throw new Error("Data must be a hex string.");
      }
      function byteToString(b) {
        return (b | 256).toString(16).slice(1);
      }
      function parseByte(data, i) {
        return parseInt(data.substr(i, 2), 16);
      }
      function hexToBytes6(data) {
        var a = [], i = 0;
        for (; i < data.length; i += 2) a.push(parseByte(data, i));
        return a;
      }
      function bytesToHex6(a) {
        var o = "0x", i = 0;
        for (; i < a.length; o += byteToString(a[i++])) ;
        return o;
      }
      LibZip2.flzCompress = function(data) {
        var ib = hexToBytes6(hexString(data)), b = ib.length - 4;
        var ht = [], ob = [], a = 0, i = 2, o = 0, j, s, h, d, c, l, r, p, q, e;
        function u24(i2) {
          return ib[i2] | ib[++i2] << 8 | ib[++i2] << 16;
        }
        function hash(x) {
          return 2654435769 * x >> 19 & 8191;
        }
        function literals(r2, s2) {
          while (r2 >= 32) for (ob[o++] = 31, j = 32; j--; r2--) ob[o++] = ib[s2++];
          if (r2) for (ob[o++] = r2 - 1; r2--; ) ob[o++] = ib[s2++];
        }
        while (i < b - 9) {
          do {
            r = ht[h = hash(s = u24(i))] || 0;
            c = (d = (ht[h] = i) - r) < 8192 ? u24(r) : 16777216;
          } while (i < b - 9 && i++ && s != c);
          if (i >= b - 9) break;
          if (--i > a) literals(i - a, a);
          for (l = 0, p = r + 3, q = i + 3, e = b - q; l < e; l++) e *= ib[p + l] === ib[q + l];
          i += l;
          for (--d; l > 262; l -= 262) ob[o++] = 224 + (d >> 8), ob[o++] = 253, ob[o++] = d & 255;
          if (l < 7) ob[o++] = (l << 5) + (d >> 8), ob[o++] = d & 255;
          else ob[o++] = 224 + (d >> 8), ob[o++] = l - 7, ob[o++] = d & 255;
          ht[hash(u24(i))] = i++, ht[hash(u24(i))] = i++, a = i;
        }
        literals(b + 4 - a, a);
        return bytesToHex6(ob);
      };
      LibZip2.flzDecompress = function(data) {
        var ib = hexToBytes6(hexString(data)), i = 0, o = 0, l, f, t, r, h, ob = [];
        while (i < ib.length) {
          if (!(t = ib[i] >> 5)) {
            for (l = 1 + ib[i++]; l--; ) ob[o++] = ib[i++];
          } else {
            f = 256 * (ib[i] & 31) + ib[i + 2 - (t = t < 7)];
            l = t ? 2 + (ib[i] >> 5) : 9 + ib[i + 1];
            i = i + 3 - t;
            r = o - f - 1;
            while (l--) ob[o++] = ob[r++];
          }
        }
        return bytesToHex6(ob);
      };
      LibZip2.cdCompress = function(data) {
        data = hexString(data);
        var o = "0x", z = 0, y = 0, i = 0, c;
        function pushByte(b) {
          o += byteToString((o.length < 4 * 2 + 2) * 255 ^ b);
        }
        function rle(v, d) {
          pushByte(0);
          pushByte(d - 1 + v * 128);
        }
        for (; i < data.length; i += 2) {
          c = parseByte(data, i);
          if (!c) {
            if (y) rle(1, y), y = 0;
            if (++z === 128) rle(0, 128), z = 0;
            continue;
          }
          if (c === 255) {
            if (z) rle(0, z), z = 0;
            if (++y === 32) rle(1, 32), y = 0;
            continue;
          }
          if (y) rle(1, y), y = 0;
          if (z) rle(0, z), z = 0;
          pushByte(c);
        }
        if (y) rle(1, y), y = 0;
        if (z) rle(0, z), z = 0;
        return o;
      };
      LibZip2.cdDecompress = function(data) {
        data = hexString(data);
        var o = "0x", i = 0, j, c, s;
        while (i < data.length) {
          c = (i < 4 * 2) * 255 ^ parseByte(data, i);
          i += 2;
          if (!c) {
            c = (i < 4 * 2) * 255 ^ parseByte(data, i);
            s = (c & 127) + 1;
            i += 2;
            for (j = 0; j < s; ++j) o += byteToString((c >> 7 && j < 32) * 255);
            continue;
          }
          o += byteToString(c);
        }
        return o;
      };
      var ERC1967Factory = {};
      solady.ERC1967Factory = ERC1967Factory;
      ERC1967Factory.address = "0x0000000000006396FF2a80c067f99B3d2Ab4Df24";
      ERC1967Factory.abi = JSON.parse('[{0:[],1:"DeploymentFailed"96"SaltDoesNotStartWithCaller"96"Unauthorized"96"UpgradeFailed",2:3959790,9791],1:"AdminChanged",2:10959790,9792,9791],1:"Deployed",2:10959790,9792],1:"Upgraded",2:10},{0:[{90],1:"adminOf",12:[{9199{0:[{90,{91],1:"changeAdmin",12:[],13:"nonpayable",2:15},{0:[{92,{91],1:"deploy",12:[{9098,{0:[{92,{91,{94],1:"deployAndCall",12:[{9098,{0:[{92,{91,{93],1:"deployDeterministic",12:[{9098,{0:[{92,{91,{93,{94],1:"deployDeterministicAndCall",12:[{9098,{0:[],1:"initCodeHash",12:[{6:19,1:"result",2:19}99{0:[{93],1:"predictDeterministicAddress",12:[{6:7,1:"predicted",2:7}99{0:[{90,{92],1:"upgrade",12:[98,{0:[{90,{92,{94],1:"upgradeAndCall",12:[98]'.replace(/9\d/g, function(m) {
        return ["6:7,1:8,2:7}", "6:7,1:9,2:7}", "6:7,1:11,2:7}", "6:19,1:20,2:19}", "6:17,1:18,2:17}", "},{4:false,0:[", ",2:3},{0:[],1:", "{5:true,", "],13:16,2:15}", "],13:14,2:15},"][m - 90];
      }).replace(/\d+/g, function(m) {
        return '"' + "inputs,name,type,error,anonymous,indexed,internalType,address,proxy,admin,event,implementation,outputs,stateMutability,view,function,payable,bytes,data,bytes32,salt".split(",")[m] + '"';
      }));
      if (typeof define === "function" && define.amd) {
        define("solady", [], function() {
          return solady;
        });
      }
      if (!noGlobal) {
        window2.solady = solady;
      }
      return solady;
    });
  }
});

// node_modules/@graphprotocol/hypergraph/dist/connect/index.js
var connect_exports = {};
__export(connect_exports, {
  AppIdentityResponse: () => AppIdentityResponse,
  DEFAULT_RPC_URL: () => DEFAULT_RPC_URL,
  GEOGENESIS: () => GEOGENESIS,
  GEO_TESTNET: () => GEO_TESTNET,
  InvalidIdentityError: () => InvalidIdentityError,
  KeysSchema: () => KeysSchema,
  TESTNET_RPC_URL: () => TESTNET_RPC_URL,
  addSmartAccountOwner: () => addSmartAccountOwner,
  buildAccountAddressStorageKey: () => buildAccountAddressStorageKey,
  buildKeysStorageKey: () => buildKeysStorageKey,
  buildSessionTokenStorageKey: () => buildSessionTokenStorageKey,
  createAppIdentity: () => createAppIdentity,
  createAuthUrl: () => createAuthUrl,
  createCallbackParams: () => createCallbackParams,
  createSmartSession: () => createSmartSession,
  decryptAppIdentity: () => decryptAppIdentity,
  decryptIdentity: () => decryptIdentity,
  encryptAppIdentity: () => encryptAppIdentity,
  encryptIdentity: () => encryptIdentity,
  getEnv: () => getEnv,
  getSmartAccountWalletClient: () => getSmartAccountWalletClient,
  getSmartSessionClient: () => getSmartSessionClient,
  getSpendingLimitsPolicy: () => getSpendingLimitsPolicy,
  getSudoPolicy: () => getSudoPolicy,
  getTimeFramePolicy: () => getTimeFramePolicy,
  getUniversalActionPolicy: () => getUniversalActionPolicy,
  getUsageLimitPolicy: () => getUsageLimitPolicy,
  getValueLimitPolicy: () => getValueLimitPolicy,
  identityExists: () => identityExists,
  isSmartAccountDeployed: () => isSmartAccountDeployed,
  legacySmartAccountUpdateStatus: () => legacySmartAccountUpdateStatus,
  loadAccountAddress: () => loadAccountAddress,
  loadKeys: () => loadKeys,
  loadSyncServerSessionToken: () => loadSyncServerSessionToken,
  login: () => login,
  parseAuthParams: () => parseAuthParams,
  parseCallbackParams: () => parseCallbackParams,
  restoreKeys: () => restoreKeys,
  signup: () => signup,
  smartAccountNeedsUpdate: () => smartAccountNeedsUpdate,
  storeAccountAddress: () => storeAccountAddress,
  storeKeys: () => storeKeys,
  storeSyncServerSessionToken: () => storeSyncServerSessionToken,
  updateLegacySmartAccount: () => updateLegacySmartAccount,
  wipeAccountAddress: () => wipeAccountAddress,
  wipeAllAuthData: () => wipeAllAuthData,
  wipeKeys: () => wipeKeys,
  wipeSyncServerSessionToken: () => wipeSyncServerSessionToken
});

// node_modules/@graphprotocol/hypergraph/dist/messages/index.js
var messages_exports = {};
__export(messages_exports, {
  AccountInbox: () => AccountInbox,
  AccountInboxPublic: () => AccountInboxPublic,
  IdentityKeyBox: () => IdentityKeyBox,
  InboxMessage: () => InboxMessage,
  Invitation: () => Invitation,
  KeyBox: () => KeyBox,
  KeyBoxWithKeyId: () => KeyBoxWithKeyId,
  RequestAcceptInvitationEvent: () => RequestAcceptInvitationEvent,
  RequestConnectAddAppIdentityToSpaces: () => RequestConnectAddAppIdentityToSpaces,
  RequestConnectCreateAppIdentity: () => RequestConnectCreateAppIdentity,
  RequestConnectCreateIdentity: () => RequestConnectCreateIdentity,
  RequestConnectCreateSpaceEvent: () => RequestConnectCreateSpaceEvent,
  RequestCreateAccountInbox: () => RequestCreateAccountInbox,
  RequestCreateAccountInboxMessage: () => RequestCreateAccountInboxMessage,
  RequestCreateIdentity: () => RequestCreateIdentity,
  RequestCreateInvitationEvent: () => RequestCreateInvitationEvent,
  RequestCreateSpaceEvent: () => RequestCreateSpaceEvent,
  RequestCreateSpaceInboxEvent: () => RequestCreateSpaceInboxEvent,
  RequestCreateSpaceInboxMessage: () => RequestCreateSpaceInboxMessage,
  RequestCreateUpdate: () => RequestCreateUpdate,
  RequestGetAccountInboxes: () => RequestGetAccountInboxes,
  RequestGetLatestAccountInboxMessages: () => RequestGetLatestAccountInboxMessages,
  RequestGetLatestSpaceInboxMessages: () => RequestGetLatestSpaceInboxMessages,
  RequestListInvitations: () => RequestListInvitations,
  RequestListSpaces: () => RequestListSpaces,
  RequestLogin: () => RequestLogin,
  RequestLoginNonce: () => RequestLoginNonce,
  RequestLoginWithSigningKey: () => RequestLoginWithSigningKey,
  RequestMessage: () => RequestMessage,
  RequestSubscribeToSpace: () => RequestSubscribeToSpace,
  ResponseAccountInbox: () => ResponseAccountInbox,
  ResponseAccountInboxMessage: () => ResponseAccountInboxMessage,
  ResponseAccountInboxMessages: () => ResponseAccountInboxMessages,
  ResponseAccountInboxPublic: () => ResponseAccountInboxPublic,
  ResponseAccountInboxes: () => ResponseAccountInboxes,
  ResponseConnectCreateIdentity: () => ResponseConnectCreateIdentity,
  ResponseIdentity: () => ResponseIdentity,
  ResponseIdentityEncrypted: () => ResponseIdentityEncrypted,
  ResponseIdentityExistsError: () => ResponseIdentityExistsError,
  ResponseIdentityNotFoundError: () => ResponseIdentityNotFoundError,
  ResponseListAccountInboxesPublic: () => ResponseListAccountInboxesPublic,
  ResponseListInvitations: () => ResponseListInvitations,
  ResponseListSpaceInboxesPublic: () => ResponseListSpaceInboxesPublic,
  ResponseListSpaces: () => ResponseListSpaces,
  ResponseMessage: () => ResponseMessage,
  ResponseSpace: () => ResponseSpace,
  ResponseSpaceEvent: () => ResponseSpaceEvent,
  ResponseSpaceInboxMessage: () => ResponseSpaceInboxMessage,
  ResponseSpaceInboxMessages: () => ResponseSpaceInboxMessages,
  ResponseSpaceInboxPublic: () => ResponseSpaceInboxPublic,
  ResponseUpdateConfirmed: () => ResponseUpdateConfirmed,
  ResponseUpdatesNotification: () => ResponseUpdatesNotification,
  SignedUpdate: () => SignedUpdate,
  SpaceInbox: () => SpaceInbox2,
  SpaceInboxPublic: () => SpaceInboxPublic,
  Updates: () => Updates,
  decryptMessage: () => decryptMessage,
  deserialize: () => deserialize,
  encryptMessage: () => encryptMessage,
  recoverUpdateMessageSigner: () => recoverUpdateMessageSigner,
  serialize: () => serialize,
  signedUpdateMessage: () => signedUpdateMessage
});

// node_modules/@noble/ciphers/esm/_arx.js
var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
var sigma16 = _utf8ToBytes("expand 16-byte k");
var sigma32 = _utf8ToBytes("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  anumber(counterLength);
  anumber(rounds);
  abool(counterRight);
  abool(allowShortKeys);
  return (key, nonce, data, output, counter = 0) => {
    abytes(key);
    abytes(nonce);
    abytes(data);
    const len = data.length;
    if (output === void 0)
      output = new Uint8Array(len);
    abytes(output);
    anumber(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output.length < len)
      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length;
    let k;
    let sigma;
    if (l === 32) {
      toClean.push(k = copyBytes(key));
      sigma = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce))
      toClean.push(nonce = copyBytes(nonce));
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output, counter, rounds);
    clean(...toClean);
    return output;
  };
}

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes(key);
    abytes(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad2 } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c;
      c = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad2[0];
    h[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h[i] + pad2[i] | 0) + (f >>> 16) | 0;
      h[i] = f & 65535;
    }
    clean(g);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20orig = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS16 = new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS16.subarray(left));
};
var ZEROS32 = new Uint8Array(32);
function computeTag(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS32);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);
  h.update(num);
  const res = h.digest();
  clean(authKey, num);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  return {
    encrypt(plaintext, output) {
      const plength = plaintext.length;
      output = getOutput(plength + tagLength, output, false);
      output.set(plaintext);
      const oPlain = output.subarray(0, -tagLength);
      xorStream(key, nonce, oPlain, oPlain, 1);
      const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
      output.set(tag, plength);
      clean(tag);
      return output;
    },
    decrypt(ciphertext, output) {
      output = getOutput(ciphertext.length - tagLength, output, false);
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes(passedTag, tag))
        throw new Error("invalid tag");
      output.set(ciphertext.subarray(0, -tagLength));
      xorStream(key, nonce, output, output, 1);
      clean(tag);
      return output;
    }
  };
};
var chacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/@graphprotocol/hypergraph/dist/messages/decrypt-message.js
function decryptMessage({
  nonceAndCiphertext,
  secretKey
}) {
  const nonce = nonceAndCiphertext.subarray(0, 24);
  const ciphertext = nonceAndCiphertext.subarray(24);
  const cipher = xchacha20poly1305(secretKey, nonce);
  return cipher.decrypt(ciphertext);
}

// node_modules/@noble/ciphers/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/ciphers/esm/webcrypto.js
function randomBytes2(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto && typeof crypto.randomBytes === "function") {
    return Uint8Array.from(crypto.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function getWebcryptoSubtle() {
  if (crypto && typeof crypto.subtle === "object" && crypto.subtle != null)
    return crypto.subtle;
  throw new Error("crypto.subtle must be defined");
}
var utils = {
  async encrypt(key, keyParams, cryptParams, plaintext) {
    const cr = getWebcryptoSubtle();
    const iKey = await cr.importKey("raw", key, keyParams, true, ["encrypt"]);
    const ciphertext = await cr.encrypt(cryptParams, iKey, plaintext);
    return new Uint8Array(ciphertext);
  },
  async decrypt(key, keyParams, cryptParams, ciphertext) {
    const cr = getWebcryptoSubtle();
    const iKey = await cr.importKey("raw", key, keyParams, true, ["decrypt"]);
    const plaintext = await cr.decrypt(cryptParams, iKey, ciphertext);
    return new Uint8Array(plaintext);
  }
};
var mode = {
  CBC: "AES-CBC",
  CTR: "AES-CTR",
  GCM: "AES-GCM"
};
function getCryptParams(algo, nonce, AAD) {
  if (algo === mode.CBC)
    return { name: mode.CBC, iv: nonce };
  if (algo === mode.CTR)
    return { name: mode.CTR, counter: nonce, length: 64 };
  if (algo === mode.GCM) {
    if (AAD)
      return { name: mode.GCM, iv: nonce, additionalData: AAD };
    else
      return { name: mode.GCM, iv: nonce };
  }
  throw new Error("unknown aes block mode");
}
function generate(algo) {
  return (key, nonce, AAD) => {
    abytes(key);
    abytes(nonce);
    const keyParams = { name: algo, length: key.length * 8 };
    const cryptParams = getCryptParams(algo, nonce, AAD);
    let consumed = false;
    return {
      // keyLength,
      encrypt(plaintext) {
        abytes(plaintext);
        if (consumed)
          throw new Error("Cannot encrypt() twice with same key / nonce");
        consumed = true;
        return utils.encrypt(key, keyParams, cryptParams, plaintext);
      },
      decrypt(ciphertext) {
        abytes(ciphertext);
        return utils.decrypt(key, keyParams, cryptParams, ciphertext);
      }
    };
  };
}
var cbc = (() => generate(mode.CBC))();
var ctr = (() => generate(mode.CTR))();
var gcm2 = (() => generate(mode.GCM))();

// node_modules/@graphprotocol/hypergraph/dist/messages/encrypt-message.js
function encryptMessage({
  message,
  secretKey
}) {
  const nonce = randomBytes2(24);
  const cipher = xchacha20poly1305(secretKey, nonce);
  const ciphertext = cipher.encrypt(message);
  return new Uint8Array([...nonce, ...ciphertext]);
}

// node_modules/@graphprotocol/hypergraph/dist/messages/serialize.js
function serialize(obj) {
  return JSON.stringify(obj, (_key, value) => {
    if (value instanceof Uint8Array) {
      return {
        __type: "Uint8Array",
        data: Array.from(value)
      };
    }
    if (value instanceof Date) {
      return {
        __type: "Date",
        data: value.toISOString()
      };
    }
    return value;
  });
}
function deserialize(json) {
  return JSON.parse(json, (_key, value) => {
    if (value && value.__type === "Uint8Array") {
      return value.data;
    }
    if (value && value.__type === "Date") {
      return new Date(value.data);
    }
    return value;
  });
}

// node_modules/@graphprotocol/hypergraph/dist/utils/index.js
var utils_exports = {};
__export(utils_exports, {
  InfinityNotAllowedError: () => InfinityNotAllowedError,
  NaNNotAllowedError: () => NaNNotAllowedError,
  assertExhaustive: () => assertExhaustive,
  automergeIdToId: () => automergeIdToId,
  bytesToHex: () => bytesToHex4,
  canonicalize: () => canonicalize,
  decodeBase58ToUUID: () => decodeBase58ToUUID,
  encodeBase58: () => encodeBase58,
  generateId: () => generateId,
  hexToBytes: () => hexToBytes4,
  idToAutomergeId: () => idToAutomergeId,
  isRelationField: () => isRelationField,
  publicKeyToAddress: () => publicKeyToAddress2,
  stringToUint8Array: () => stringToUint8Array,
  uint8ArrayToString: () => uint8ArrayToString
});

// node_modules/@graphprotocol/hypergraph/dist/utils/assertExhaustive.js
var assertExhaustive = (_value, message = "Reached unexpected case in exhaustive switch") => {
  throw new Error(message);
};

// node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0; i < ALPHABET2.length; i++) {
    const x = ALPHABET2.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var esm_default = base;

// node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/bs58check/src/esm/base.js
function base_default(checksumFn) {
  function encode(payload) {
    var payloadU8 = Uint8Array.from(payload);
    var checksum = checksumFn(payloadU8);
    var length = payloadU8.length + 4;
    var both = new Uint8Array(length);
    both.set(payloadU8, 0);
    both.set(checksum.subarray(0, 4), payloadU8.length);
    return esm_default2.encode(both);
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3])
      return;
    return payload;
  }
  function decodeUnsafe(str) {
    var buffer = esm_default2.decodeUnsafe(str);
    if (buffer == null)
      return;
    return decodeRaw(buffer);
  }
  function decode(str) {
    var buffer = esm_default2.decode(str);
    var payload = decodeRaw(buffer);
    if (payload == null)
      throw new Error("Invalid checksum");
    return payload;
  }
  return {
    encode,
    decode,
    decodeUnsafe
  };
}

// node_modules/bs58check/src/esm/index.js
function sha256x2(buffer) {
  return sha256(sha256(buffer));
}
var esm_default3 = base_default(sha256x2);

// node_modules/@graphprotocol/hypergraph/dist/utils/automergeId.js
function idToAutomergeId(uuid) {
  const payload = parse_default(uuid);
  return esm_default3.encode(payload);
}
function automergeIdToId(base58CheckUuid) {
  const versionedPayload = esm_default3.decode(base58CheckUuid);
  return stringify_default(versionedPayload);
}

// node_modules/@graphprotocol/hypergraph/dist/utils/internal/base58Utils.js
var BASE58_ALLOWED_CHARS = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

// node_modules/@graphprotocol/hypergraph/dist/utils/base58.js
function encodeBase58(val) {
  const hex = BigInt(`0x${val}`);
  let remainder = hex;
  const result = [];
  while (remainder > 0n) {
    const mod2 = remainder % 58n;
    const base58CharAtMod = BASE58_ALLOWED_CHARS[Number(mod2)];
    if (base58CharAtMod) {
      result.push(base58CharAtMod);
    }
    remainder = remainder / 58n;
  }
  return result.reverse().join("");
}
function decodeBase58ToUUID(encoded) {
  let decoded = 0n;
  for (const char of encoded) {
    const index = BASE58_ALLOWED_CHARS.indexOf(char);
    if (index === -1) {
      throw new Error("Invalid Base58 character");
    }
    decoded = decoded * 58n + BigInt(index);
  }
  let hexStr = decoded.toString(16);
  hexStr = hexStr.padStart(32, "0");
  return [hexStr.slice(0, 8), hexStr.slice(8, 12), hexStr.slice(12, 16), hexStr.slice(16, 20), hexStr.slice(20)].join("-");
}

// node_modules/@graphprotocol/hypergraph/dist/utils/generateId.js
function generateId() {
  return v4_default();
}

// node_modules/@noble/secp256k1/index.js
var secp256k1_CURVE = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  h: 1n,
  a: 0n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
};
var { p: P, n: N, Gx, Gy, b: _b } = secp256k1_CURVE;
var L = 32;
var L2 = 64;
var err = (m = "") => {
  throw new Error(m);
};
var isBig = (n) => typeof n === "bigint";
var isStr = (s) => typeof s === "string";
var isBytes = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
var abytes3 = (a, l) => !isBytes(a) || typeof l === "number" && l > 0 && a.length !== l ? err("Uint8Array expected") : a;
var u8n = (len) => new Uint8Array(len);
var u8fr = (buf) => Uint8Array.from(buf);
var padh = (n, pad2) => n.toString(16).padStart(pad2, "0");
var bytesToHex3 = (b) => Array.from(abytes3(b)).map((e) => padh(e, 2)).join("");
var C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
var _ch = (ch) => {
  if (ch >= C._0 && ch <= C._9)
    return ch - C._0;
  if (ch >= C.A && ch <= C.F)
    return ch - (C.A - 10);
  if (ch >= C.a && ch <= C.f)
    return ch - (C.a - 10);
  return;
};
var hexToBytes3 = (hex) => {
  const e = "hex invalid";
  if (!isStr(hex))
    return err(e);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    return err(e);
  const array = u8n(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = _ch(hex.charCodeAt(hi));
    const n2 = _ch(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0)
      return err(e);
    array[ai] = n1 * 16 + n2;
  }
  return array;
};
var toU8 = (a, len) => abytes3(isStr(a) ? hexToBytes3(a) : u8fr(abytes3(a)), len);
var concatBytes3 = (...arrs) => {
  const r = u8n(arrs.reduce((sum, a) => sum + abytes3(a).length, 0));
  let pad2 = 0;
  arrs.forEach((a) => {
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
};
var big = BigInt;
var arange = (n, min, max, msg = "bad number: out of range") => isBig(n) && min <= n && n < max ? n : err(msg);
var M = (a, b = P) => {
  const r = a % b;
  return r >= 0n ? r : b + r;
};
var invert = (num, md) => {
  if (num === 0n || md <= 0n)
    err("no inverse n=" + num + " mod=" + md);
  let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return b === 1n ? M(x, md) : err("no inverse");
};
var apoint = (p) => p instanceof Point ? p : err("Point expected");
var koblitz = (x) => M(M(x * x) * x + _b);
var afield0 = (n) => arange(n, 0n, P);
var afield = (n) => arange(n, 1n, P);
var agroup = (n) => arange(n, 1n, N);
var isEven = (y) => (y & 1n) === 0n;
var u8of = (n) => Uint8Array.of(n);
var getPrefix = (y) => u8of(isEven(y) ? 2 : 3);
var lift_x = (x) => {
  const c = koblitz(afield(x));
  let r = 1n;
  for (let num = c, e = (P + 1n) / 4n; e > 0n; e >>= 1n) {
    if (e & 1n)
      r = r * num % P;
    num = num * num % P;
  }
  return M(r * r) === c ? r : err("sqrt invalid");
};
var _Point = class _Point {
  constructor(px, py, pz) {
    __publicField(this, "px");
    __publicField(this, "py");
    __publicField(this, "pz");
    this.px = afield0(px);
    this.py = afield(py);
    this.pz = afield0(pz);
    Object.freeze(this);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(bytes) {
    abytes3(bytes);
    let p = void 0;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    const x = sliceBytesNumBE(tail, 0, L);
    const len = bytes.length;
    if (len === L + 1 && [2, 3].includes(head)) {
      let y = lift_x(x);
      const evenY = isEven(y);
      const evenH = isEven(big(head));
      if (evenH !== evenY)
        y = M(-y);
      p = new _Point(x, y, 1n);
    }
    if (len === L2 + 1 && head === 4)
      p = new _Point(x, sliceBytesNumBE(tail, L, L2), 1n);
    return p ? p.assertValidity() : err("bad point: not on curve");
  }
  /** Equality check: compare points P&Q. */
  equals(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = apoint(other);
    const X1Z2 = M(X1 * Z2);
    const X2Z1 = M(X2 * Z1);
    const Y1Z2 = M(Y1 * Z2);
    const Y2Z1 = M(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new _Point(this.px, M(-this.py), this.pz);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = apoint(other);
    const a = 0n;
    const b = _b;
    let X3 = 0n, Y3 = 0n, Z3 = 0n;
    const b3 = M(b * 3n);
    let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1);
    let t4 = M(X2 + Y2);
    t3 = M(t3 * t4);
    t4 = M(t0 + t1);
    t3 = M(t3 - t4);
    t4 = M(X1 + Z1);
    let t5 = M(X2 + Z2);
    t4 = M(t4 * t5);
    t5 = M(t0 + t2);
    t4 = M(t4 - t5);
    t5 = M(Y1 + Z1);
    X3 = M(Y2 + Z2);
    t5 = M(t5 * X3);
    X3 = M(t1 + t2);
    t5 = M(t5 - X3);
    Z3 = M(a * t4);
    X3 = M(b3 * t2);
    Z3 = M(X3 + Z3);
    X3 = M(t1 - Z3);
    Z3 = M(t1 + Z3);
    Y3 = M(X3 * Z3);
    t1 = M(t0 + t0);
    t1 = M(t1 + t0);
    t2 = M(a * t2);
    t4 = M(b3 * t4);
    t1 = M(t1 + t2);
    t2 = M(t0 - t2);
    t2 = M(a * t2);
    t4 = M(t4 + t2);
    t0 = M(t1 * t4);
    Y3 = M(Y3 + t0);
    t0 = M(t5 * t4);
    X3 = M(t3 * X3);
    X3 = M(X3 - t0);
    t0 = M(t3 * t1);
    Z3 = M(t5 * Z3);
    Z3 = M(Z3 + t0);
    return new _Point(X3, Y3, Z3);
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(n, safe = true) {
    if (!safe && n === 0n)
      return I;
    agroup(n);
    if (n === 1n)
      return this;
    if (this.equals(G))
      return wNAF2(n).p;
    let p = I;
    let f = G;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  /** Convert point to 2d xy affine point. (X, Y, Z) ∋ (x=X/Z, y=Y/Z) */
  toAffine() {
    const { px: x, py: y, pz: z } = this;
    if (this.equals(I))
      return { x: 0n, y: 0n };
    if (z === 1n)
      return { x, y };
    const iz = invert(z, P);
    if (M(z * iz) !== 1n)
      err("inverse invalid");
    return { x: M(x * iz), y: M(y * iz) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x, y } = this.toAffine();
    afield(x);
    afield(y);
    return M(y * y) === koblitz(x) ? this : err("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(isCompressed = true) {
    const { x, y } = this.assertValidity().toAffine();
    const x32b = numTo32b(x);
    if (isCompressed)
      return concatBytes3(getPrefix(y), x32b);
    return concatBytes3(u8of(4), x32b, numTo32b(y));
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(ap) {
    const { x, y } = ap;
    return x === 0n && y === 0n ? I : new _Point(x, y, 1n);
  }
  toHex(isCompressed) {
    return bytesToHex3(this.toBytes(isCompressed));
  }
  static fromPrivateKey(k) {
    return G.multiply(toPrivScalar(k));
  }
  static fromHex(hex) {
    return _Point.fromBytes(toU8(hex));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  toRawBytes(isCompressed) {
    return this.toBytes(isCompressed);
  }
};
__publicField(_Point, "BASE");
__publicField(_Point, "ZERO");
var Point = _Point;
var G = new Point(Gx, Gy, 1n);
var I = new Point(0n, 1n, 0n);
Point.BASE = G;
Point.ZERO = I;
var bytesToNumBE = (b) => big("0x" + (bytesToHex3(b) || "0"));
var sliceBytesNumBE = (b, from, to) => bytesToNumBE(b.subarray(from, to));
var B256 = 2n ** 256n;
var numTo32b = (num) => hexToBytes3(padh(arange(num, 0n, B256), L2));
var toPrivScalar = (pr) => {
  const num = isBig(pr) ? pr : bytesToNumBE(toU8(pr, L));
  return arange(num, 1n, N, "private key invalid 3");
};
var W = 8;
var scalarBits = 256;
var pwindows = Math.ceil(scalarBits / W) + 1;
var pwindowSize = 2 ** (W - 1);
var precompute = () => {
  const points = [];
  let p = G;
  let b = p;
  for (let w = 0; w < pwindows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < pwindowSize; i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
var Gpows = void 0;
var ctneg = (cnd, p) => {
  const n = p.negate();
  return cnd ? n : p;
};
var wNAF2 = (n) => {
  const comp = Gpows || (Gpows = precompute());
  let p = I;
  let f = G;
  const pow_2_w = 2 ** W;
  const maxNum = pow_2_w;
  const mask = big(pow_2_w - 1);
  const shiftBy = big(W);
  for (let w = 0; w < pwindows; w++) {
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > pwindowSize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off = w * pwindowSize;
    const offF = off;
    const offP = off + Math.abs(wbits) - 1;
    const isEven2 = w % 2 !== 0;
    const isNeg = wbits < 0;
    if (wbits === 0) {
      f = f.add(ctneg(isEven2, comp[offF]));
    } else {
      p = p.add(ctneg(isNeg, comp[offP]));
    }
  }
  return { p, f };
};

// node_modules/@graphprotocol/hypergraph/dist/utils/hexBytesAddressUtils.js
var bytesToHex4 = (bytes) => {
  return `0x${bytesToHex(bytes)}`;
};
var hexToBytes4 = (hex) => {
  return hexToBytes(hex.slice(2));
};
function decompressPublicKey(compressedKey) {
  const point = Point.fromHex(compressedKey.slice(2));
  const uncompressedKey = point.toRawBytes(false);
  return bytesToHex4(uncompressedKey);
}
var publicKeyToAddress2 = (publicKey) => {
  const uncompressedKey = decompressPublicKey(publicKey);
  return publicKeyToAddress(uncompressedKey);
};

// node_modules/@graphprotocol/hypergraph/dist/utils/isRelationField.js
var isRelationField = (field) => {
  if (field.ast._tag === "TupleType") {
    return true;
  }
  return false;
};

// node_modules/@graphprotocol/hypergraph/dist/utils/jsc.js
var NaNNotAllowedError = class extends Error {
  constructor() {
    super("NaN is not allowed");
  }
};
var InfinityNotAllowedError = class extends Error {
  constructor() {
    super("Infinity is not allowed");
  }
};
function canonicalize(object) {
  if (typeof object === "number" && Number.isNaN(object)) {
    throw new NaNNotAllowedError();
  }
  if (typeof object === "number" && !Number.isFinite(object)) {
    throw new InfinityNotAllowedError();
  }
  if (object === null || typeof object !== "object") {
    return JSON.stringify(object);
  }
  if (object.toJSON instanceof Function) {
    return canonicalize(object.toJSON());
  }
  if (Array.isArray(object)) {
    const values2 = object.reduce((t, cv) => {
      if (cv === void 0 || typeof cv === "symbol") {
        return t;
      }
      const comma = t.length === 0 ? "" : ",";
      return `${t}${comma}${canonicalize(cv)}`;
    }, "");
    return `[${values2}]`;
  }
  const values = Object.keys(object).sort().reduce((t, cv) => {
    if (object[cv] === void 0 || typeof object[cv] === "symbol") {
      return t;
    }
    const comma = t.length === 0 ? "" : ",";
    return `${t}${comma}${canonicalize(cv)}:${canonicalize(object[cv])}`;
  }, "");
  return `{${values}}`;
}

// node_modules/@graphprotocol/hypergraph/dist/utils/stringToUint8Array.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var stringToUint8Array = (str) => {
  return encoder.encode(str);
};
var uint8ArrayToString = (uint8Array) => {
  return decoder.decode(uint8Array);
};

// node_modules/@graphprotocol/hypergraph/dist/messages/signed-update-message.js
var signedUpdateMessage = ({
  accountAddress,
  updateId,
  spaceId,
  message,
  secretKey,
  signaturePrivateKey
}) => {
  const update2 = encryptMessage({
    message,
    secretKey: hexToBytes4(secretKey)
  });
  const messageToSign = stringToUint8Array(canonicalize({
    accountAddress,
    updateId,
    update: update2,
    spaceId
  }));
  const recoverySignature = secp256k1.sign(messageToSign, hexToBytes4(signaturePrivateKey), {
    prehash: true
  });
  const signature = {
    hex: recoverySignature.toCompactHex(),
    recovery: recoverySignature.recovery
  };
  return {
    type: "create-update",
    updateId,
    update: update2,
    spaceId,
    accountAddress,
    signature
  };
};
var recoverUpdateMessageSigner = ({
  update: update2,
  spaceId,
  updateId,
  signature,
  accountAddress
}) => {
  const recoveredSignature = secp256k1.Signature.fromCompact(signature.hex).addRecoveryBit(signature.recovery);
  const signedMessage = stringToUint8Array(canonicalize({
    accountAddress,
    updateId,
    update: update2,
    spaceId
  }));
  const signedMessageHash = sha256(signedMessage);
  return bytesToHex4(recoveredSignature.recoverPublicKey(signedMessageHash).toRawBytes(true));
};

// node_modules/@graphprotocol/hypergraph/dist/inboxes/types.js
var InboxSenderAuthPolicy = Union(Literal("anonymous"), Literal("optional_auth"), Literal("requires_auth"));

// node_modules/@graphprotocol/hypergraph/dist/space-events/index.js
var space_events_exports = {};
__export(space_events_exports, {
  AcceptInvitationEvent: () => AcceptInvitationEvent,
  Author: () => Author,
  CreateInvitationEvent: () => CreateInvitationEvent,
  CreateSpaceEvent: () => CreateSpaceEvent,
  CreateSpaceInboxEvent: () => CreateSpaceInboxEvent,
  DeleteSpaceEvent: () => DeleteSpaceEvent,
  EventAuthor: () => EventAuthor,
  InvalidEventError: () => InvalidEventError,
  SpaceEvent: () => SpaceEvent,
  SpaceInbox: () => SpaceInbox,
  SpaceInvitation: () => SpaceInvitation,
  SpaceMember: () => SpaceMember,
  SpaceState: () => SpaceState,
  VerifySignatureError: () => VerifySignatureError,
  acceptInvitation: () => acceptInvitation,
  applyEvent: () => applyEvent,
  createInbox: () => createInbox,
  createInvitation: () => createInvitation,
  createSpace: () => createSpace,
  deleteSpace: () => deleteSpace,
  hashEvent: () => hashEvent
});

// node_modules/@graphprotocol/hypergraph/dist/space-events/accept-invitation.js
var acceptInvitation = ({
  author,
  previousEventHash
}) => {
  const transaction = {
    id: generateId(),
    type: "accept-invitation",
    previousEventHash
  };
  const encodedTransaction = stringToUint8Array(canonicalize(transaction));
  const signatureResult = secp256k1.sign(encodedTransaction, hexToBytes4(author.signaturePrivateKey), {
    prehash: true
  });
  return Effect_exports.succeed({
    transaction,
    author: {
      accountAddress: author.accountAddress,
      signature: {
        hex: signatureResult.toCompactHex(),
        recovery: signatureResult.recovery
      }
    }
  });
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/hash-event.js
var hashEvent = (event) => {
  const hash = blake3(canonicalize(event));
  return bytesToHex4(hash);
};

// node_modules/@graphprotocol/hypergraph/dist/types.js
var SignatureWithRecovery = Struct({
  hex: String$,
  recovery: Number$
});
var ConnectAuthPayload = Struct({
  expiry: Number$,
  encryptionPublicKey: String$,
  appId: String$
});
var ConnectCallbackResult = Struct({
  appIdentityAddress: String$,
  appIdentityAddressPrivateKey: String$,
  accountAddress: String$,
  permissionId: String$,
  signaturePublicKey: String$,
  signaturePrivateKey: String$,
  encryptionPublicKey: String$,
  encryptionPrivateKey: String$,
  sessionToken: String$,
  sessionTokenExpires: Date$,
  privateSpaces: Array$(Struct({
    id: String$
  })),
  publicSpaces: Array$(Struct({
    id: String$
  }))
});
var ConnectCallbackDecryptedData = Struct({
  ...ConnectCallbackResult.fields,
  sessionTokenExpires: Number$,
  expiry: Number$
});
var FailedToParseConnectAuthUrl = class extends TaggedError("FailedToParseConnectAuthUrl") {
};
var FailedToParseAuthCallbackUrl = class extends TaggedError("FailedToParseAuthCallbackUrl") {
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/types.js
var EventAuthor = Struct({
  accountAddress: String$,
  signature: SignatureWithRecovery
});
var SpaceMember = Struct({
  accountAddress: String$,
  role: Union(Literal("admin"), Literal("member"))
});
var SpaceInvitation = Struct({
  inviteeAccountAddress: String$
});
var SpaceInbox = Struct({
  inboxId: String$,
  encryptionPublicKey: String$,
  isPublic: Boolean$,
  authPolicy: InboxSenderAuthPolicy,
  secretKey: String$
});
var SpaceState = Struct({
  id: String$,
  invitations: Record({
    key: String$,
    value: SpaceInvitation
  }),
  members: Record({
    key: String$,
    value: SpaceMember
  }),
  removedMembers: Record({
    key: String$,
    value: SpaceMember
  }),
  inboxes: Record({
    key: String$,
    value: SpaceInbox
  }),
  lastEventHash: String$
});
var CreateSpaceEvent = Struct({
  transaction: Struct({
    type: Literal("create-space"),
    id: String$,
    creatorAccountAddress: String$
  }),
  author: EventAuthor
});
var DeleteSpaceEvent = Struct({
  transaction: Struct({
    type: Literal("delete-space"),
    id: String$,
    previousEventHash: String$
  }),
  author: EventAuthor
});
var CreateInvitationEvent = Struct({
  transaction: Struct({
    type: Literal("create-invitation"),
    id: String$,
    inviteeAccountAddress: String$,
    previousEventHash: String$
  }),
  author: EventAuthor
});
var CreateSpaceInboxEvent = Struct({
  transaction: Struct({
    type: Literal("create-space-inbox"),
    id: String$,
    spaceId: String$,
    inboxId: String$,
    encryptionPublicKey: String$,
    secretKey: String$,
    isPublic: Boolean$,
    authPolicy: InboxSenderAuthPolicy,
    previousEventHash: String$
  }),
  author: EventAuthor
});
var AcceptInvitationEvent = Struct({
  transaction: Struct({
    id: String$,
    type: Literal("accept-invitation"),
    previousEventHash: String$
  }),
  author: EventAuthor
});
var SpaceEvent = Union(CreateSpaceEvent, DeleteSpaceEvent, CreateInvitationEvent, AcceptInvitationEvent, CreateSpaceInboxEvent);
var Author = Struct({
  accountAddress: String$,
  signaturePublicKey: String$,
  signaturePrivateKey: String$,
  encryptionPublicKey: String$
});
var VerifySignatureError = class {
  constructor() {
    __publicField(this, "_tag", "VerifySignatureError");
  }
};
var InvalidEventError = class {
  constructor() {
    __publicField(this, "_tag", "InvalidEventError");
  }
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/apply-event.js
var decodeSpaceEvent = Schema_exports.decodeUnknownEither(SpaceEvent);
var applyEvent = ({
  state,
  event: rawEvent,
  getVerifiedIdentity: getVerifiedIdentity2
}) => {
  const decodedEvent = decodeSpaceEvent(rawEvent);
  if (decodedEvent._tag === "Left") {
    return decodedEvent.left;
  }
  const event = decodedEvent.right;
  if (event.transaction.type !== "create-space") {
    if (state === void 0) {
      return Effect_exports.fail(new InvalidEventError());
    }
    if (event.transaction.previousEventHash !== state.lastEventHash) {
      return Effect_exports.fail(new InvalidEventError());
    }
  }
  const encodedTransaction = stringToUint8Array(canonicalize(event.transaction));
  let signatureInstance = secp256k1.Signature.fromCompact(event.author.signature.hex);
  signatureInstance = signatureInstance.addRecoveryBit(event.author.signature.recovery);
  const authorPublicKey = `0x${signatureInstance.recoverPublicKey(sha256(encodedTransaction)).toHex()}`;
  return Effect_exports.gen(function* () {
    var _a;
    const identity = yield* getVerifiedIdentity2(event.author.accountAddress);
    if (authorPublicKey !== identity.signaturePublicKey) {
      yield* Effect_exports.fail(new VerifySignatureError());
    }
    let id = "";
    let members = {};
    let removedMembers = {};
    let invitations = {};
    let inboxes = {};
    if (event.transaction.type === "create-space") {
      id = event.transaction.id;
      members[event.transaction.creatorAccountAddress] = {
        accountAddress: event.transaction.creatorAccountAddress,
        role: "admin"
      };
    } else if (state !== void 0) {
      id = state.id;
      members = {
        ...state.members
      };
      removedMembers = {
        ...state.removedMembers
      };
      invitations = {
        ...state.invitations
      };
      inboxes = {
        ...state.inboxes
      };
      if (event.transaction.type === "accept-invitation") {
        if (members[event.author.accountAddress] !== void 0) {
          yield* Effect_exports.fail(new InvalidEventError());
        }
        const result = Object.entries(invitations).find(([, invitation2]) => invitation2.inviteeAccountAddress === event.author.accountAddress);
        if (!result) {
          yield* Effect_exports.fail(new InvalidEventError());
        }
        const [id2, invitation] = result;
        members[invitation.inviteeAccountAddress] = {
          accountAddress: invitation.inviteeAccountAddress,
          role: "member"
        };
        delete invitations[id2];
        if (removedMembers[event.author.accountAddress] !== void 0) {
          delete removedMembers[event.author.accountAddress];
        }
      } else {
        if (((_a = members[event.author.accountAddress]) == null ? void 0 : _a.role) !== "admin") {
          yield* Effect_exports.fail(new InvalidEventError());
        }
        if (event.transaction.type === "delete-space") {
          removedMembers = {
            ...members
          };
          members = {};
          invitations = {};
        } else if (event.transaction.type === "create-invitation") {
          if (members[event.transaction.inviteeAccountAddress] !== void 0) {
            yield* Effect_exports.fail(new InvalidEventError());
          }
          for (const invitation of Object.values(invitations)) {
            if (invitation.inviteeAccountAddress === event.transaction.inviteeAccountAddress) {
              yield* Effect_exports.fail(new InvalidEventError());
            }
          }
          invitations[event.transaction.id] = {
            inviteeAccountAddress: event.transaction.inviteeAccountAddress
          };
        } else if (event.transaction.type === "create-space-inbox") {
          if (inboxes[event.transaction.inboxId] !== void 0) {
            yield* Effect_exports.fail(new InvalidEventError());
          }
          inboxes[event.transaction.inboxId] = {
            inboxId: event.transaction.inboxId,
            encryptionPublicKey: event.transaction.encryptionPublicKey,
            isPublic: event.transaction.isPublic,
            authPolicy: event.transaction.authPolicy,
            secretKey: event.transaction.secretKey
          };
        } else {
          yield* Effect_exports.fail(new InvalidEventError());
        }
      }
    }
    return {
      id,
      members,
      removedMembers,
      invitations,
      inboxes,
      lastEventHash: hashEvent(event)
    };
  });
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/create-inbox.js
var createInbox = ({
  author,
  spaceId,
  inboxId,
  encryptionPublicKey,
  secretKey,
  isPublic,
  authPolicy,
  previousEventHash
}) => {
  const transaction = {
    type: "create-space-inbox",
    id: generateId(),
    spaceId,
    inboxId,
    encryptionPublicKey,
    secretKey,
    isPublic,
    authPolicy,
    previousEventHash
  };
  const signature = secp256k1.sign(stringToUint8Array(canonicalize(transaction)), hexToBytes4(author.signaturePrivateKey), {
    prehash: true
  });
  const spaceEvent = {
    transaction,
    author: {
      accountAddress: author.accountAddress,
      signature: {
        hex: signature.toCompactHex(),
        recovery: signature.recovery
      }
    }
  };
  return Effect_exports.succeed(spaceEvent);
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/create-invitation.js
var createInvitation = ({
  author,
  previousEventHash,
  invitee
}) => {
  const transaction = {
    id: generateId(),
    type: "create-invitation",
    inviteeAccountAddress: invitee.accountAddress,
    previousEventHash
  };
  const encodedTransaction = stringToUint8Array(canonicalize(transaction));
  const signatureResult = secp256k1.sign(encodedTransaction, hexToBytes4(author.signaturePrivateKey), {
    prehash: true
  });
  return Effect_exports.succeed({
    transaction,
    author: {
      accountAddress: author.accountAddress,
      signature: {
        hex: signatureResult.toCompactHex(),
        recovery: signatureResult.recovery
      }
    }
  });
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/create-space.js
var createSpace = ({
  author,
  spaceId
}) => {
  const transaction = {
    type: "create-space",
    id: spaceId ?? generateId(),
    creatorAccountAddress: author.accountAddress
  };
  const encodedTransaction = stringToUint8Array(canonicalize(transaction));
  const signatureResult = secp256k1.sign(encodedTransaction, hexToBytes4(author.signaturePrivateKey), {
    prehash: true
  });
  const event = {
    transaction,
    author: {
      accountAddress: author.accountAddress,
      signature: {
        hex: signatureResult.toCompactHex(),
        recovery: signatureResult.recovery
      }
    }
  };
  return Effect_exports.succeed(event);
};

// node_modules/@graphprotocol/hypergraph/dist/space-events/delete-space.js
var deleteSpace = ({
  author,
  id,
  previousEventHash
}) => {
  const transaction = {
    type: "delete-space",
    id,
    previousEventHash
  };
  const encodedTransaction = stringToUint8Array(canonicalize(transaction));
  const signatureResult = secp256k1.sign(encodedTransaction, hexToBytes4(author.signaturePrivateKey), {
    prehash: true
  });
  const event = {
    transaction,
    author: {
      accountAddress: author.accountAddress,
      signature: {
        hex: signatureResult.toCompactHex(),
        recovery: signatureResult.recovery
      }
    }
  };
  return Effect_exports.succeed(event);
};

// node_modules/@graphprotocol/hypergraph/dist/messages/types.js
var SignedUpdate = Struct({
  update: Uint8Array$,
  accountAddress: String$,
  signature: SignatureWithRecovery,
  updateId: String$
});
var Updates = Struct({
  updates: Array$(SignedUpdate),
  firstUpdateClock: Number$,
  lastUpdateClock: Number$
});
var KeyBox = Struct({
  accountAddress: String$,
  ciphertext: String$,
  nonce: String$,
  authorPublicKey: String$
});
var KeyBoxWithKeyId = Struct({
  ...KeyBox.fields,
  id: String$
});
var IdentityKeyBox = Struct({
  signer: String$,
  accountAddress: String$,
  ciphertext: String$,
  nonce: String$
});
var RequestCreateSpaceEvent = Struct({
  type: Literal("create-space-event"),
  spaceId: String$,
  event: CreateSpaceEvent,
  keyBox: KeyBoxWithKeyId,
  name: String$
});
var RequestConnectCreateSpaceEvent = Struct({
  type: Literal("connect-create-space-event"),
  accountAddress: String$,
  spaceId: String$,
  event: CreateSpaceEvent,
  keyBox: KeyBoxWithKeyId,
  infoContent: String$,
  infoSignature: SignatureWithRecovery,
  name: String$
});
var RequestCreateInvitationEvent = Struct({
  type: Literal("create-invitation-event"),
  spaceId: String$,
  event: CreateInvitationEvent,
  keyBoxes: Array$(KeyBoxWithKeyId)
});
var RequestConnectAddAppIdentityToSpaces = Struct({
  type: Literal("connect-add-app-identity-to-spaces"),
  appIdentityAddress: String$,
  accountAddress: String$,
  spacesInput: Array$(Struct({
    id: String$,
    keyBoxes: Array$(KeyBoxWithKeyId)
  }))
});
var RequestAcceptInvitationEvent = Struct({
  type: Literal("accept-invitation-event"),
  spaceId: String$,
  event: AcceptInvitationEvent
});
var RequestSubscribeToSpace = Struct({
  type: Literal("subscribe-space"),
  id: String$,
  lastKnownUpdateClock: optional(Number$)
});
var RequestListSpaces = Struct({
  type: Literal("list-spaces")
});
var RequestListInvitations = Struct({
  type: Literal("list-invitations")
});
var RequestCreateUpdate = Struct({
  type: Literal("create-update"),
  accountAddress: String$,
  update: Uint8Array$,
  spaceId: String$,
  updateId: String$,
  // used to identify the confirmation message
  signature: SignatureWithRecovery
});
var RequestCreateAccountInbox = Struct({
  type: Literal("create-account-inbox"),
  accountAddress: String$,
  inboxId: String$,
  isPublic: Boolean$,
  authPolicy: InboxSenderAuthPolicy,
  encryptionPublicKey: String$,
  signature: SignatureWithRecovery
});
var RequestCreateSpaceInboxEvent = Struct({
  type: Literal("create-space-inbox-event"),
  spaceId: String$,
  event: CreateSpaceInboxEvent
});
var RequestGetLatestSpaceInboxMessages = Struct({
  type: Literal("get-latest-space-inbox-messages"),
  spaceId: String$,
  inboxId: String$,
  since: Date$
});
var RequestGetLatestAccountInboxMessages = Struct({
  type: Literal("get-latest-account-inbox-messages"),
  accountAddress: String$,
  inboxId: String$,
  since: Date$
});
var RequestGetAccountInboxes = Struct({
  type: Literal("get-account-inboxes")
});
var RequestMessage = Union(RequestCreateSpaceEvent, RequestCreateInvitationEvent, RequestAcceptInvitationEvent, RequestSubscribeToSpace, RequestListSpaces, RequestListInvitations, RequestCreateUpdate, RequestCreateAccountInbox, RequestCreateSpaceInboxEvent, RequestGetLatestSpaceInboxMessages, RequestGetLatestAccountInboxMessages, RequestGetAccountInboxes);
var RequestLoginNonce = Struct({
  accountAddress: String$
});
var RequestLogin = Struct({
  accountAddress: String$,
  message: String$,
  signature: String$
});
var RequestLoginWithSigningKey = Struct({
  accountAddress: String$,
  message: String$,
  publicKey: String$,
  signature: String$
});
var RequestCreateIdentity = Struct({
  keyBox: IdentityKeyBox,
  accountProof: String$,
  keyProof: String$,
  message: String$,
  signaturePublicKey: String$,
  encryptionPublicKey: String$,
  signature: String$
});
var RequestConnectCreateIdentity = Struct({
  keyBox: IdentityKeyBox,
  accountProof: String$,
  keyProof: String$,
  signaturePublicKey: String$,
  encryptionPublicKey: String$
});
var RequestConnectCreateAppIdentity = Struct({
  appId: String$,
  address: String$,
  accountAddress: String$,
  ciphertext: String$,
  nonce: String$,
  signaturePublicKey: String$,
  encryptionPublicKey: String$,
  accountProof: String$,
  keyProof: String$
});
var ResponseConnectCreateIdentity = Struct({
  success: Boolean$
});
var RequestCreateSpaceInboxMessage = Struct({
  ciphertext: String$,
  signature: optional(SignatureWithRecovery),
  authorAccountAddress: optional(String$)
});
var RequestCreateAccountInboxMessage = Struct({
  ciphertext: String$,
  signature: optional(SignatureWithRecovery),
  authorAccountAddress: optional(String$)
});
var ResponseListSpaces = Struct({
  type: Literal("list-spaces"),
  spaces: Array$(Struct({
    id: String$,
    name: String$
  }))
});
var Invitation = Struct({
  id: String$,
  previousEventHash: String$,
  spaceId: String$
});
var ResponseListInvitations = Struct({
  type: Literal("list-invitations"),
  invitations: Array$(Invitation)
});
var ResponseSpaceEvent = Struct({
  type: Literal("space-event"),
  spaceId: String$,
  event: SpaceEvent
});
var InboxMessage = Struct({
  id: String$,
  ciphertext: String$,
  signature: optional(SignatureWithRecovery),
  authorAccountAddress: optional(String$),
  createdAt: Date$
});
var SpaceInbox2 = Struct({
  inboxId: String$,
  isPublic: Boolean$,
  authPolicy: InboxSenderAuthPolicy,
  encryptionPublicKey: String$,
  secretKey: String$
});
var AccountInbox = Struct({
  accountAddress: String$,
  inboxId: String$,
  isPublic: Boolean$,
  authPolicy: InboxSenderAuthPolicy,
  encryptionPublicKey: String$,
  signature: SignatureWithRecovery
});
var ResponseAccountInbox = Struct({
  type: Literal("account-inbox"),
  inbox: AccountInbox
});
var ResponseSpace = Struct({
  type: Literal("space"),
  id: String$,
  name: String$,
  events: Array$(SpaceEvent),
  keyBoxes: Array$(KeyBoxWithKeyId),
  updates: optional(Updates),
  inboxes: Array$(SpaceInbox2)
});
var ResponseUpdateConfirmed = Struct({
  type: Literal("update-confirmed"),
  updateId: String$,
  clock: Number$,
  spaceId: String$
});
var ResponseUpdatesNotification = Struct({
  type: Literal("updates-notification"),
  updates: Updates,
  spaceId: String$
});
var ResponseSpaceInboxMessage = Struct({
  type: Literal("space-inbox-message"),
  spaceId: String$,
  inboxId: String$,
  message: InboxMessage
});
var ResponseSpaceInboxMessages = Struct({
  type: Literal("space-inbox-messages"),
  spaceId: String$,
  inboxId: String$,
  messages: Array$(InboxMessage)
});
var ResponseAccountInboxMessage = Struct({
  type: Literal("account-inbox-message"),
  accountAddress: String$,
  inboxId: String$,
  message: InboxMessage
});
var ResponseAccountInboxMessages = Struct({
  type: Literal("account-inbox-messages"),
  accountAddress: String$,
  inboxId: String$,
  messages: Array$(InboxMessage)
});
var ResponseAccountInboxes = Struct({
  type: Literal("account-inboxes"),
  inboxes: Array$(AccountInbox)
});
var ResponseMessage = Union(ResponseListSpaces, ResponseListInvitations, ResponseSpace, ResponseSpaceEvent, ResponseUpdateConfirmed, ResponseUpdatesNotification, ResponseAccountInbox, ResponseSpaceInboxMessage, ResponseSpaceInboxMessages, ResponseAccountInboxMessage, ResponseAccountInboxMessages, ResponseAccountInboxes);
var ResponseIdentityEncrypted = Struct({
  keyBox: IdentityKeyBox
});
var ResponseIdentity = Struct({
  accountAddress: String$,
  signaturePublicKey: String$,
  encryptionPublicKey: String$,
  accountProof: String$,
  keyProof: String$
});
var SpaceInboxPublic = Struct({
  inboxId: String$,
  isPublic: Boolean$,
  authPolicy: InboxSenderAuthPolicy,
  encryptionPublicKey: String$,
  creationEvent: CreateSpaceInboxEvent
});
var ResponseSpaceInboxPublic = Struct({
  inbox: SpaceInboxPublic
});
var ResponseListSpaceInboxesPublic = Struct({
  inboxes: Array$(SpaceInboxPublic)
});
var AccountInboxPublic = Struct({
  accountAddress: String$,
  inboxId: String$,
  isPublic: Boolean$,
  authPolicy: InboxSenderAuthPolicy,
  encryptionPublicKey: String$,
  signature: SignatureWithRecovery
});
var ResponseAccountInboxPublic = Struct({
  inbox: AccountInboxPublic
});
var ResponseListAccountInboxesPublic = Struct({
  inboxes: Array$(AccountInboxPublic)
});
var ResponseIdentityNotFoundError = Struct({
  accountAddress: String$
});
var ResponseIdentityExistsError = Struct({
  accountAddress: String$
});

// node_modules/@graphprotocol/hypergraph/dist/connect/types.js
var KeysSchema = Schema_exports.Struct({
  encryptionPublicKey: Schema_exports.String,
  encryptionPrivateKey: Schema_exports.String,
  signaturePublicKey: Schema_exports.String,
  signaturePrivateKey: Schema_exports.String
});
var AppIdentityResponse = Schema_exports.Struct({
  accountAddress: Schema_exports.String,
  signaturePublicKey: Schema_exports.String,
  encryptionPublicKey: Schema_exports.String,
  accountProof: Schema_exports.String,
  keyProof: Schema_exports.String,
  ciphertext: Schema_exports.String,
  nonce: Schema_exports.String,
  sessionToken: Schema_exports.String,
  address: Schema_exports.String,
  appId: Schema_exports.String,
  sessionTokenExpires: Schema_exports.String
});
var InvalidIdentityError = class {
  constructor() {
    __publicField(this, "_tag", "InvalidIdentityError");
  }
};

// node_modules/@graphprotocol/hypergraph/dist/connect/auth-storage.js
var getEnv = () => {
  return "dev";
};
var buildAccountAddressStorageKey = () => `hypergraph:${getEnv()}:id`;
var buildKeysStorageKey = (walletAddress) => walletAddress ? `hypergraph:${getEnv()}:keys:${walletAddress}` : "";
var buildSessionTokenStorageKey = (walletAddress) => walletAddress ? `hypergraph:${getEnv()}:session-token:${walletAddress}` : "";
var loadKeys = (storage, walletAddress) => {
  const accessKey = buildKeysStorageKey(walletAddress);
  const val = storage.getItem(accessKey);
  if (!val) {
    return null;
  }
  const deserialized = Schema_exports.decodeUnknownSync(KeysSchema)(deserialize(val));
  return {
    encryptionPublicKey: deserialized.encryptionPublicKey,
    encryptionPrivateKey: deserialized.encryptionPrivateKey,
    signaturePublicKey: deserialized.signaturePublicKey,
    signaturePrivateKey: deserialized.signaturePrivateKey
  };
};
var storeKeys = (storage, walletAddress, keys) => {
  const keysMsg = serialize(Schema_exports.encodeSync(KeysSchema)(keys));
  storage.setItem(buildKeysStorageKey(walletAddress), keysMsg);
};
var wipeKeys = (storage, walletAddress) => {
  storage.removeItem(buildKeysStorageKey(walletAddress));
};
var loadSyncServerSessionToken = (storage, address) => {
  const key = buildSessionTokenStorageKey(address);
  const token = storage.getItem(key);
  return token;
};
var storeSyncServerSessionToken = (storage, address, sessionToken) => {
  const key = buildSessionTokenStorageKey(address);
  storage.setItem(key, sessionToken);
};
var wipeSyncServerSessionToken = (storage, walletAddress) => {
  storage.removeItem(buildSessionTokenStorageKey(walletAddress));
};
var loadAccountAddress = (storage) => {
  return storage.getItem(buildAccountAddressStorageKey());
};
var storeAccountAddress = (storage, accountId2) => {
  storage.setItem(buildAccountAddressStorageKey(), accountId2);
};
var wipeAccountAddress = (storage) => {
  storage.removeItem(buildAccountAddressStorageKey());
};
var wipeAllAuthData = (addressStorage, keysAndTokenStorage) => {
  const accountAddress = loadAccountAddress(addressStorage);
  wipeAccountAddress(addressStorage);
  if (accountAddress) {
    wipeKeys(keysAndTokenStorage, accountAddress);
    wipeSyncServerSessionToken(keysAndTokenStorage, accountAddress);
  }
};

// node_modules/@graphprotocol/hypergraph/dist/key/index.js
var key_exports = {};
__export(key_exports, {
  createKey: () => createKey,
  decryptKey: () => decryptKey,
  decryptKeyBox: () => decryptKeyBox,
  encryptKey: () => encryptKey,
  encryptKeyBox: () => encryptKeyBox,
  generateKeypair: () => generateKeypair
});

// node_modules/@serenity-kit/noble-sodium/dist/constants.js
var crypto_box_NONCEBYTES = 24;
var crypto_box_PUBLICKEYBYTES = 32;
var crypto_box_SECRETKEYBYTES = 32;

// node_modules/@noble/ciphers/esm/salsa.js
function salsaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = k[0], y02 = k[1], y03 = k[2], y04 = k[3], y05 = s[1], y06 = n[0], y07 = n[1], y08 = cnt, y09 = 0, y10 = s[2], y11 = k[4], y12 = k[5], y13 = k[6], y14 = k[7], y15 = s[3];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hsalsa(s, k, i, o32) {
  let x00 = s[0], x01 = k[0], x02 = k[1], x03 = k[2], x04 = k[3], x05 = s[1], x06 = i[0], x07 = i[1], x08 = i[2], x09 = i[3], x10 = s[2], x11 = k[4], x12 = k[5], x13 = k[6], x14 = k[7], x15 = s[3];
  for (let r = 0; r < 20; r += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x05;
  o32[oi++] = x10;
  o32[oi++] = x15;
  o32[oi++] = x06;
  o32[oi++] = x07;
  o32[oi++] = x08;
  o32[oi++] = x09;
}
var salsa20 = createCipher(salsaCore, {
  allowShortKeys: true,
  counterRight: true
});
var xsalsa20 = createCipher(salsaCore, {
  counterRight: true,
  extendNonceFn: hsalsa
});
var xsalsa20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (key, nonce) => {
  return {
    encrypt(plaintext, output) {
      output = getOutput(plaintext.length + 32, output, false);
      const authKey = output.subarray(0, 32);
      const ciphPlaintext = output.subarray(32);
      output.set(plaintext, 32);
      clean(authKey);
      xsalsa20(key, nonce, output, output);
      const tag = poly1305(ciphPlaintext, authKey);
      output.set(tag, 16);
      clean(output.subarray(0, 16), tag);
      return output.subarray(16);
    },
    decrypt(ciphertext, output) {
      abytes(ciphertext);
      output = getOutput(ciphertext.length + 32, output, false);
      const tmp = output.subarray(0, 32);
      const passedTag = output.subarray(32, 48);
      const ciphPlaintext = output.subarray(48);
      output.set(ciphertext, 32);
      clean(tmp);
      const authKey = xsalsa20(key, nonce, tmp, tmp);
      const tag = poly1305(ciphPlaintext, authKey);
      if (!equalBytes(passedTag, tag))
        throw new Error("invalid tag");
      xsalsa20(key, nonce, output.subarray(16), output.subarray(16));
      clean(tmp, passedTag, tag);
      return ciphPlaintext;
    }
  };
});
function secretbox(key, nonce) {
  const xs = xsalsa20poly1305(key, nonce);
  return { seal: xs.encrypt, open: xs.decrypt };
}

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function isEdValidXY(Fp2, CURVE, x, y) {
  const x2 = Fp2.sqr(x);
  const y2 = Fp2.sqr(y);
  const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);
  const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));
  return Fp2.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
  const { Fp: Fp2, Fn } = _createCurveFields("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
  const modP = (n) => Fp2.create(n);
  const uvRatio2 = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(Fp2.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n };
    }
  });
  if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n, banZero = false) {
    const min = banZero ? _1n : _0n;
    aInRange("coordinate " + title, n, min, MASK);
    return n;
  }
  function aextpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n : Fp2.inv(z);
    const ax = modP(x * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n, y: _1n };
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point3 {
    constructor(ex, ey, ez, et) {
      this.ex = acoord("x", ex);
      this.ey = acoord("y", ey);
      this.ez = acoord("z", ez, true);
      this.et = acoord("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point3)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point3(x, y, _1n, modP(x * y));
    }
    static normalizeZ(points) {
      return normalizeZ(Point3, "ez", points);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point3, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_2n);
      return this;
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    negate() {
      return new Point3(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C2 = modP(_2n * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C2;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point3(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C2 = modP(T1 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C2;
      const G2 = D + C2;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point3(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n, CURVE_ORDER);
      const { p, f } = wnaf.wNAFCached(this, n, Point3.normalizeZ);
      return Point3.normalizeZ([p, f])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point3.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n, CURVE_ORDER);
      if (n === _0n)
        return Point3.ZERO;
      if (this.is0() || n === _1n)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n, Point3.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes, zip215 = false) {
      abytes2(bytes);
      return this.fromHex(bytes, zip215);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      abool2("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y, _0n, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n) === _1n;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point3.fromAffine({ x, y });
    }
    static fromPrivateScalar(scalar) {
      return Point3.BASE.multiply(scalar);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = numberToBytesLE(y, Fp2.BYTES);
      bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
      return bytes;
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex2(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
  Point3.ZERO = new Point3(_0n, _1n, _1n, _0n);
  Point3.Fp = Fp2;
  Point3.Fn = Fn;
  const wnaf = wNAF(Point3, Fn.BYTES * 8);
  return Point3;
}
function eddsa(Point3, eddsaOpts) {
  _validateObject(eddsaOpts, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash, hash: cHash } = eddsaOpts;
  const { BASE: G2, Fp: Fp2, Fn } = Point3;
  const CURVE_ORDER = Fn.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool2("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN(a) {
    return Fn.create(a);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = Fp2.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G2.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G2.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange("signature.s", s, _0n, CURVE_ORDER);
    const L3 = Fp2.BYTES;
    const res = concatBytes(R, numberToBytesLE(s, L3));
    return ensureBytes("result", res, L3 * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, len);
    if (zip215 !== void 0)
      abool2("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point3.fromHex(publicKey, zip215);
      R = Point3.fromHex(sig.slice(0, len), zip215);
      SB = G2.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G2.precompute(8);
  const utils2 = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes_(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return { getPublicKey, sign, verify, utils: utils2, Point: Point3 };
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp2 = c.Fp;
  const Fn = Field(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp2, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    hash: c.hash,
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point3 = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point3, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P: P2, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n2 ** BigInt(254) : _2n2 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n2 ** BigInt(251) - _1n2 : BigInt(4) * _2n2 ** BigInt(445) - _1n2;
  const maxScalar = minScalar + maxAdded + _1n2;
  const modP = (n) => mod(n, P2);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n2)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n2, P2);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n2;
    let z_2 = _0n2;
    let x_3 = u;
    let z_3 = _1n2;
    let swap = _0n2;
    for (let t = BigInt(montgomeryBits - 1); t >= _0n2; t--) {
      const k_t = k >> t & _1n2;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C2 = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C2 * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
    GuBytes: GuBytes.slice()
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _5n = BigInt(5);
var _8n2 = BigInt(8);
var ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n2,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P2 = ed25519_CURVE.p;
  const x2 = x * x % P2;
  const b2 = x2 * x % P2;
  const b4 = pow2(b2, _2n3, P2) * b2 % P2;
  const b5 = pow2(b4, _1n3, P2) * x % P2;
  const b10 = pow2(b5, _5n, P2) * b5 % P2;
  const b20 = pow2(b10, _10n, P2) * b10 % P2;
  const b40 = pow2(b20, _20n, P2) * b20 % P2;
  const b80 = pow2(b40, _40n, P2) * b40 % P2;
  const b160 = pow2(b80, _80n, P2) * b80 % P2;
  const b240 = pow2(b160, _80n, P2) * b80 % P2;
  const b250 = pow2(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow2(b250, _2n3, P2) * x % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P2 = ed25519_CURVE.p;
  const v3 = mod(v * v * v, P2);
  const v7 = mod(v3 * v3 * v, P2);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow, P2);
  const vx2 = mod(v * x * x, P2);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P2);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P2))
    x = mod(-x, P2);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp = (() => Field(ed25519_CURVE.p, void 0, true))();
var ed25519Defaults = (() => ({
  ...ed25519_CURVE,
  Fp,
  hash: sha512,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => {
  const P2 = ed25519_CURVE.p;
  return montgomery({
    P: P2,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod(pow2(pow_p_5_8, _3n, P2) * b2, P2);
    },
    adjustScalarBytes
  });
})();
var ELL2_C1 = (() => (Fp.ORDER + _3n) / _8n2)();
var ELL2_C2 = (() => Fp.pow(_2n3, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (Fp.ORDER - _5n) / _8n2;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n3);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n3 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e);
  xd = Fp.cmov(xd, Fp.ONE, e);
  yn = Fp.cmov(yn, Fp.ONE, e);
  yd = Fp.cmov(yd, Fp.ONE, e);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
var ed25519_hasher = (() => createHasher(ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => ed25519_hasher.hashToCurve)();
var encodeToCurve = (() => ed25519_hasher.encodeToCurve)();
function aristp(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number) => uvRatio(_1n3, number);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519.CURVE;
  const P2 = ed25519.CURVE.Fp.ORDER;
  const mod2 = ed25519.CURVE.Fp.create;
  const r = mod2(SQRT_M1 * r0 * r0);
  const Ns = mod2((r + _1n3) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D = mod2((c - d * r) * mod2(r + d));
  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
  let s_ = mod2(s * r0);
  if (!isNegativeLE(s_, P2))
    s_ = mod2(-s_);
  if (!Ns_D_is_sq)
    s = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod2(c * (r - _1n3) * D_MINUS_ONE_SQ - D);
  const s2 = s * s;
  const W0 = mod2((s + s) * D);
  const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod2(_1n3 - s2);
  const W3 = mod2(_1n3 + s2);
  return new ed25519.Point(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap) {
    return new _RistPoint(ed25519.Point.fromAffine(ap));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
   * the [website](https://ristretto.group/formulas/elligator.html).
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex) {
    hex = ensureBytes("ristrettoHash", hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistPoint(R1.add(R2));
  }
  static fromBytes(bytes) {
    abytes2(bytes);
    return this.fromHex(bytes);
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    hex = ensureBytes("ristrettoHex", hex, 32);
    const { a, d } = ed25519.CURVE;
    const P2 = Fp.ORDER;
    const mod2 = Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s = bytes255ToNumberLE(hex);
    if (!equalBytes2(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P2))
      throw new Error(emsg);
    const s2 = mod2(s * s);
    const u1 = mod2(_1n3 + a * s2);
    const u2 = mod2(_1n3 - a * s2);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v = mod2(a * d * u1_2 - u2_2);
    const { isValid, value: I2 } = invertSqrt(mod2(v * u2_2));
    const Dx = mod2(I2 * u2);
    const Dy = mod2(I2 * Dx * v);
    let x = mod2((s + s) * Dx);
    if (isNegativeLE(x, P2))
      x = mod2(-x);
    const y = mod2(u1 * Dy);
    const t = mod2(x * y);
    if (!isValid || isNegativeLE(t, P2) || y === _0n3)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.Point(x, y, _1n3, t));
  }
  static msm(points, scalars) {
    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);
    return pippenger(_RistPoint, Fn, points, scalars);
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { ex: x, ey: y, ez: z, et: t } = this.ep;
    const P2 = Fp.ORDER;
    const mod2 = Fp.create;
    const u1 = mod2(mod2(z + y) * mod2(z - y));
    const u2 = mod2(x * y);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D2 * t);
    let D;
    if (isNegativeLE(t * zInv, P2)) {
      let _x = mod2(y * SQRT_M1);
      let _y = mod2(x * SQRT_M1);
      x = _x;
      y = _y;
      D = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(x * zInv, P2))
      y = mod2(-y);
    let s = mod2((z - y) * D);
    if (isNegativeLE(s, P2))
      s = mod2(-s);
    return numberToBytesLE(s, 32);
  }
  /** @deprecated use `toBytes` */
  toRawBytes() {
    return this.toBytes();
  }
  toHex() {
    return bytesToHex2(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    aristp(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X2, ey: Y2 } = other.ep;
    const mod2 = Fp.create;
    const one = mod2(X1 * Y2) === mod2(Y1 * X2);
    const two = mod2(Y1 * Y2) === mod2(X1 * X2);
    return one || two;
  }
  add(other) {
    aristp(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    aristp(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.Point.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.Point.ZERO);
  return RistPoint;
})();

// node_modules/@serenity-kit/noble-sodium/dist/crypto-box-easy.js
function cryptoBoxEasy({ message, nonce, publicKey, privateKey }) {
  const sharedSecret = x25519.getSharedSecret(privateKey, publicKey);
  const sigma = new Uint32Array([
    1634760805,
    857760878,
    2036477234,
    1797285236
  ]);
  const output = new Uint32Array(8);
  const zeros = new Uint32Array(4).fill(0);
  hsalsa(sigma, u322(sharedSecret), zeros, output);
  const key = u8(output);
  const box = secretbox(key, nonce);
  return box.seal(message);
}

// node_modules/@serenity-kit/noble-sodium/dist/crypto-box-key-pair.js
function cryptoBoxKeyPair() {
  const privateKey = randomBytes(crypto_box_SECRETKEYBYTES);
  const publicKey = x25519.getPublicKey(privateKey);
  return { keyType: "x25519", publicKey, privateKey };
}

// node_modules/@serenity-kit/noble-sodium/dist/crypto-box-open-easy.js
function cryptoBoxOpenEasy({ ciphertext, nonce, publicKey, privateKey }) {
  const sharedSecret = x25519.getSharedSecret(privateKey, publicKey);
  const sigma = new Uint32Array([
    1634760805,
    857760878,
    2036477234,
    1797285236
  ]);
  const output = new Uint32Array(8);
  const zeros = new Uint32Array(4).fill(0);
  hsalsa(sigma, u322(sharedSecret), zeros, output);
  const key = u8(output);
  const box = secretbox(key, nonce);
  return box.open(ciphertext);
}

// node_modules/@noble/hashes/esm/blake2b.js
var blake2b2 = blake2b;

// node_modules/@serenity-kit/noble-sodium/dist/crypto-box-seal-open.js
function cryptoBoxSealOpen({ ciphertext, privateKey, publicKey }) {
  const ephemeralPublicKey = ciphertext.slice(0, crypto_box_PUBLICKEYBYTES);
  const nonce = blake2b2(new Uint8Array([...ephemeralPublicKey, ...publicKey]), {
    dkLen: crypto_box_NONCEBYTES
  });
  const encryptedMessage = ciphertext.slice(crypto_box_PUBLICKEYBYTES);
  return cryptoBoxOpenEasy({
    ciphertext: encryptedMessage,
    nonce,
    publicKey: ephemeralPublicKey,
    privateKey
  });
}

// node_modules/@serenity-kit/noble-sodium/dist/crypto-box-seal.js
function cryptoBoxSeal({ message, publicKey }) {
  const ephemeralKeyPair = cryptoBoxKeyPair();
  const nonce = blake2b2(new Uint8Array([...ephemeralKeyPair.publicKey, ...publicKey]), { dkLen: crypto_box_NONCEBYTES });
  const ciphertext = cryptoBoxEasy({
    message,
    nonce,
    publicKey,
    privateKey: ephemeralKeyPair.privateKey
  });
  return new Uint8Array([...ephemeralKeyPair.publicKey, ...ciphertext]);
}

// node_modules/@graphprotocol/hypergraph/dist/key/key-box.js
function generateKeypair() {
  const {
    publicKey,
    privateKey
  } = cryptoBoxKeyPair();
  return {
    publicKey,
    secretKey: privateKey
  };
}
function encryptKeyBox({
  message,
  publicKey,
  secretKey,
  nonce
}) {
  return cryptoBoxEasy({
    message,
    publicKey,
    privateKey: secretKey,
    nonce
  });
}
function decryptKeyBox({
  ciphertext,
  nonce,
  publicKey,
  secretKey
}) {
  return cryptoBoxOpenEasy({
    ciphertext,
    publicKey,
    privateKey: secretKey,
    nonce
  });
}

// node_modules/@graphprotocol/hypergraph/dist/key/encrypt-key.js
function encryptKey({
  privateKey,
  publicKey,
  key
}) {
  const nonce = randomBytes2(24);
  const ciphertext = encryptKeyBox({
    message: key,
    nonce,
    publicKey,
    secretKey: privateKey
  });
  return {
    keyBoxCiphertext: ciphertext,
    keyBoxNonce: nonce
  };
}

// node_modules/@graphprotocol/hypergraph/dist/key/create-key.js
function createKey({
  privateKey,
  publicKey
}) {
  const key = randomBytes2(32);
  const {
    keyBoxCiphertext,
    keyBoxNonce
  } = encryptKey({
    key,
    publicKey,
    privateKey
  });
  return {
    key,
    keyBoxCiphertext,
    keyBoxNonce
  };
}

// node_modules/@graphprotocol/hypergraph/dist/key/decrypt-key.js
function decryptKey({
  privateKey,
  publicKey,
  keyBoxNonce,
  keyBoxCiphertext
}) {
  const key = decryptKeyBox({
    nonce: keyBoxNonce,
    ciphertext: keyBoxCiphertext,
    publicKey,
    secretKey: privateKey
  });
  return key;
}

// node_modules/@graphprotocol/hypergraph/dist/connect/create-identity-keys.js
var createIdentityKeys = () => {
  const {
    publicKey: encryptionPublicKey,
    secretKey: encryptionPrivateKey
  } = generateKeypair();
  const signaturePrivateKey = secp256k1.utils.randomPrivateKey();
  const signaturePublicKey = secp256k1.getPublicKey(signaturePrivateKey);
  return {
    encryptionPublicKey: bytesToHex4(encryptionPublicKey),
    encryptionPrivateKey: bytesToHex4(encryptionPrivateKey),
    signaturePublicKey: bytesToHex4(signaturePublicKey),
    signaturePrivateKey: bytesToHex4(signaturePrivateKey)
  };
};

// node_modules/@graphprotocol/hypergraph/dist/connect/create-app-identity.js
var createAppIdentity = () => {
  const keys = createIdentityKeys();
  const addressPrivateKey = generatePrivateKey();
  const {
    address
  } = privateKeyToAccount(addressPrivateKey);
  return {
    ...keys,
    address,
    addressPrivateKey
  };
};

// node_modules/@graphprotocol/hypergraph/dist/connect/create-auth-url.js
var createAuthUrl = (params) => {
  const {
    redirectUrl,
    connectUrl,
    expiryMilliseconds = 24e4,
    // 4 minutes
    appId
  } = params;
  const {
    publicKey,
    secretKey
  } = generateKeypair();
  const expiry = Date.now() + expiryMilliseconds;
  const payload = {
    expiry,
    encryptionPublicKey: bytesToHex2(publicKey),
    appId
  };
  const data = encodeURIComponent(JSON.stringify(payload));
  const nonce = bytesToHex2(randomBytes(32));
  const url = new URL(connectUrl);
  url.searchParams.set("data", data);
  url.searchParams.set("redirect", encodeURIComponent(redirectUrl));
  url.searchParams.set("nonce", nonce);
  return {
    url,
    nonce,
    secretKey: bytesToHex2(secretKey),
    publicKey: bytesToHex2(publicKey),
    expiry
  };
};

// node_modules/@graphprotocol/hypergraph/dist/connect/create-callback-params.js
var createCallbackParams = ({
  nonce,
  ephemeralPublicKey,
  ...rest
}) => {
  const ciphertext = cryptoBoxSeal({
    message: utf8ToBytes(JSON.stringify(rest)),
    publicKey: hexToBytes2(ephemeralPublicKey.replace(/^0x/, ""))
  });
  return {
    ciphertext: bytesToHex2(ciphertext),
    nonce
  };
};

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash, ikm, salt) {
  ahash(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac(hash, toBytes2(salt), toBytes2(ikm));
}
var HKDF_COUNTER = Uint8Array.from([0]);
var EMPTY_BUFFER = Uint8Array.of();
function expand(hash, prk, info, length = 32) {
  ahash(hash);
  anumber2(length);
  const olen = hash.outputLen;
  if (length > 255 * olen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * olen);
  const HMAC = hmac.create(hash, prk);
  const HMACTmp = HMAC._cloneInto();
  const T = new Uint8Array(HMAC.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC._cloneInto(HMACTmp);
  }
  HMAC.destroy();
  HMACTmp.destroy();
  clean2(T, HKDF_COUNTER);
  return okm.slice(0, length);
}
var hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);

// node_modules/@graphprotocol/hypergraph/dist/connect/identity-encryption.js
var hkdfDeriveKey = (secret, salt) => {
  return hkdf(sha256, secret, salt, "", 32);
};
var encrypt = (msg, secret) => {
  const hkdfSalt = randomBytes2(32);
  const gcmNonce = randomBytes2(12);
  const derivedKey = hkdfDeriveKey(secret, hkdfSalt);
  const aes = gcm(derivedKey, gcmNonce);
  const ciphertext = aes.encrypt(msg);
  const ciphertextJson = canonicalize({
    aes256GcmHkdfSha256: {
      payload: bytesToHex4(ciphertext),
      hkdfSalt: bytesToHex4(hkdfSalt),
      gcmNonce: bytesToHex4(gcmNonce)
    }
  });
  return bytesToHex4(new TextEncoder().encode(ciphertextJson));
};
var decrypt = (ciphertext, secret) => {
  const ciphertextJson = new TextDecoder().decode(hexToBytes4(ciphertext));
  const {
    aes256GcmHkdfSha256
  } = JSON.parse(ciphertextJson);
  const hkdfSalt = hexToBytes4(aes256GcmHkdfSha256.hkdfSalt);
  const gcmNonce = hexToBytes4(aes256GcmHkdfSha256.gcmNonce);
  const derivedKey = hkdfDeriveKey(secret, hkdfSalt);
  const aes = gcm(derivedKey, gcmNonce);
  return aes.decrypt(hexToBytes4(aes256GcmHkdfSha256.payload));
};
var signatureMessage = (nonce) => {
  return `The Graph: sign to encrypt/decrypt identity keys.
Nonce: ${bytesToHex4(nonce)}
`;
};
var encryptIdentity = async (signer, keys) => {
  const nonce = randomBytes2(32);
  const message = signatureMessage(nonce);
  const signature = await signer.signMessage(message);
  const valid = await verifyMessage({
    address: await signer.getAddress(),
    message,
    signature
  });
  if (!valid) {
    throw new Error("Invalid signature");
  }
  const secretKey = hexToBytes4(signature);
  const keysTxt = [keys.encryptionPublicKey, keys.encryptionPrivateKey, keys.signaturePublicKey, keys.signaturePrivateKey].join("\n");
  const keysMsg = new TextEncoder().encode(keysTxt);
  const ciphertext = encrypt(keysMsg, secretKey);
  return {
    ciphertext,
    nonce: bytesToHex4(nonce)
  };
};
var decryptIdentity = async (signer, ciphertext, nonce) => {
  const message = signatureMessage(hexToBytes4(nonce));
  const signature = await signer.signMessage(message);
  const valid = await verifyMessage({
    address: await signer.getAddress(),
    message,
    signature
  });
  if (!valid) {
    throw new Error("Invalid signature");
  }
  const secretKey = hexToBytes4(signature);
  let keysMsg;
  try {
    keysMsg = await decrypt(ciphertext, secretKey);
  } catch (e) {
    if (secretKey.length !== 65) {
      throw new Error("Expected 65 bytes before trying a different recovery byte");
    }
    const lastByte = secretKey[secretKey.length - 1];
    let newSecret = secretKey.slice(0, secretKey.length - 1);
    if (lastByte < 27) {
      newSecret = new Uint8Array([...newSecret, lastByte + 27]);
    } else {
      newSecret = new Uint8Array([...newSecret, lastByte - 27]);
    }
    keysMsg = await decrypt(ciphertext, newSecret);
  }
  const keysTxt = new TextDecoder().decode(keysMsg);
  const [encryptionPublicKey, encryptionPrivateKey, signaturePublicKey, signaturePrivateKey] = keysTxt.split("\n");
  return {
    encryptionPublicKey,
    encryptionPrivateKey,
    signaturePublicKey,
    signaturePrivateKey
  };
};
var encryptAppIdentity = async (signer, appIdentityAddress, appIdentityAddressPrivateKey, permissionId, keys) => {
  const nonce = randomBytes2(32);
  const message = signatureMessage(nonce);
  const signature = await signer.signMessage(message);
  const valid = await verifyMessage({
    address: await signer.getAddress(),
    message,
    signature
  });
  if (!valid) {
    throw new Error("Invalid signature");
  }
  const secretKey = hexToBytes4(signature);
  const keysTxt = [keys.encryptionPublicKey, keys.encryptionPrivateKey, keys.signaturePublicKey, keys.signaturePrivateKey, appIdentityAddress, appIdentityAddressPrivateKey, permissionId].join("\n");
  const keysMsg = new TextEncoder().encode(keysTxt);
  const ciphertext = encrypt(keysMsg, secretKey);
  return {
    ciphertext,
    nonce: bytesToHex4(nonce)
  };
};
var decryptAppIdentity = async (signer, ciphertext, nonce) => {
  const message = signatureMessage(hexToBytes4(nonce));
  const signature = await signer.signMessage(message);
  const valid = await verifyMessage({
    address: await signer.getAddress(),
    message,
    signature
  });
  if (!valid) {
    throw new Error("Invalid signature");
  }
  const secretKey = hexToBytes4(signature);
  let keysMsg;
  try {
    keysMsg = await decrypt(ciphertext, secretKey);
  } catch (e) {
    if (secretKey.length !== 65) {
      throw new Error("Expected 65 bytes before trying a different recovery byte");
    }
    const lastByte = secretKey[secretKey.length - 1];
    let newSecret = secretKey.slice(0, secretKey.length - 1);
    if (lastByte < 27) {
      newSecret = new Uint8Array([...newSecret, lastByte + 27]);
    } else {
      newSecret = new Uint8Array([...newSecret, lastByte - 27]);
    }
    keysMsg = await decrypt(ciphertext, newSecret);
  }
  const keysTxt = new TextDecoder().decode(keysMsg);
  const [encryptionPublicKey, encryptionPrivateKey, signaturePublicKey, signaturePrivateKey, appIdentityAddress, appIdentityAddressPrivateKey, permissionId] = keysTxt.split("\n");
  return {
    encryptionPublicKey,
    encryptionPrivateKey,
    signaturePublicKey,
    signaturePrivateKey,
    address: appIdentityAddress,
    addressPrivateKey: appIdentityAddressPrivateKey,
    permissionId
  };
};

// node_modules/@graphprotocol/hypergraph/dist/identity/prove-ownership.js
var getAccountProofMessage = (accountAddress, publicKey) => {
  return `This message proves I am the owner of the account ${accountAddress} and the public key ${publicKey}`;
};
var getKeyProofMessage = (accountAddress, publicKey) => {
  return `The public key ${publicKey} is owned by the account ${accountAddress}`;
};
var accountProofDomain = {
  name: "Hypergraph",
  version: "1"
};
var proveIdentityOwnership = async (smartAccountClient, accountAddress, keys) => {
  if (!smartAccountClient.account) {
    throw new Error("Smart account client does not have an account");
  }
  if (!smartAccountClient.chain) {
    throw new Error("Smart account client does not have a chain");
  }
  const publicKey = keys.signaturePublicKey;
  const keyProofMessage = getKeyProofMessage(accountAddress, publicKey);
  const accountProof = await smartAccountClient.account.signTypedData({
    message: {
      message: getAccountProofMessage(accountAddress, publicKey)
    },
    types: {
      Message: [{
        name: "message",
        type: "string"
      }]
    },
    domain: accountProofDomain,
    primaryType: "Message"
  });
  console.log("accountProof", accountProof);
  const account = privateKeyToAccount(keys.signaturePrivateKey);
  const keyProof = await account.signMessage({
    message: keyProofMessage
  });
  return {
    accountProof,
    keyProof
  };
};
var verifyIdentityOwnership = async (accountAddress, publicKey, accountProof, keyProof, chain, rpcUrl) => {
  const keyProofMessage = getKeyProofMessage(accountAddress, publicKey);
  const publicClient = createPublicClient({
    chain,
    transport: http(rpcUrl)
  });
  const accountProofMessage = getAccountProofMessage(accountAddress, publicKey);
  const validAccountProof = await publicClient.verifyTypedData({
    address: accountAddress,
    message: {
      message: accountProofMessage
    },
    types: {
      Message: [{
        name: "message",
        type: "string"
      }]
    },
    domain: accountProofDomain,
    primaryType: "Message",
    signature: accountProof
  });
  if (!validAccountProof) {
    console.log("Invalid account proof");
    return false;
  }
  const keyAddress = publicKeyToAddress2(publicKey);
  const validKeyProof = await verifyMessage({
    address: keyAddress,
    message: keyProofMessage,
    signature: keyProof
  });
  if (!validKeyProof) {
    console.log("Invalid key proof");
    return false;
  }
  return true;
};

// node_modules/@graphprotocol/hypergraph/dist/store-connect.js
var store_connect_exports = {};
__export(store_connect_exports, {
  store: () => store
});

// node_modules/@xstate/store/dist/store-f80a6837.esm.js
function createReactiveSystem({
  update: update2,
  notify,
  unwatched
}) {
  return {
    link: link2,
    unlink: unlink2,
    propagate: propagate2,
    checkDirty: checkDirty2,
    endTracking: endTracking2,
    startTracking: startTracking2,
    shallowPropagate: shallowPropagate2
  };
  function link2(dep, sub) {
    const prevDep = sub._depsTail;
    if (prevDep !== void 0 && prevDep.dep === dep) {
      return;
    }
    let nextDep = void 0;
    const recursedCheck = sub._flags & 4;
    if (recursedCheck) {
      nextDep = prevDep !== void 0 ? prevDep.nextDep : sub._deps;
      if (nextDep !== void 0 && nextDep.dep === dep) {
        sub._depsTail = nextDep;
        return;
      }
    }
    const prevSub = dep._subsTail;
    if (prevSub !== void 0 && prevSub.sub === sub && (!recursedCheck || isValidLink(prevSub, sub))) {
      return;
    }
    const newLink = sub._depsTail = dep._subsTail = {
      dep,
      sub,
      prevDep,
      nextDep,
      prevSub,
      nextSub: void 0
    };
    if (nextDep !== void 0) {
      nextDep.prevDep = newLink;
    }
    if (prevDep !== void 0) {
      prevDep.nextDep = newLink;
    } else {
      sub._deps = newLink;
    }
    if (prevSub !== void 0) {
      prevSub.nextSub = newLink;
    } else {
      dep._subs = newLink;
    }
  }
  function unlink2(link3, sub = link3.sub) {
    const dep = link3.dep;
    const prevDep = link3.prevDep;
    const nextDep = link3.nextDep;
    const nextSub = link3.nextSub;
    const prevSub = link3.prevSub;
    if (nextDep !== void 0) {
      nextDep.prevDep = prevDep;
    } else {
      sub._depsTail = prevDep;
    }
    if (prevDep !== void 0) {
      prevDep.nextDep = nextDep;
    } else {
      sub._deps = nextDep;
    }
    if (nextSub !== void 0) {
      nextSub.prevSub = prevSub;
    } else {
      dep._subsTail = prevSub;
    }
    if (prevSub !== void 0) {
      prevSub.nextSub = nextSub;
    } else if ((dep._subs = nextSub) === void 0) {
      unwatched(dep);
    }
    return nextDep;
  }
  function propagate2(link3) {
    let next = link3.nextSub;
    let stack;
    top: do {
      const sub = link3.sub;
      let flags = sub._flags;
      if (flags & 3) {
        if (!(flags & 60)) {
          sub._flags = flags | 32;
        } else if (!(flags & 12)) {
          flags = 0;
        } else if (!(flags & 4)) {
          sub._flags = flags & ~8 | 32;
        } else if (!(flags & 48) && isValidLink(link3, sub)) {
          sub._flags = flags | 40;
          flags &= 1;
        } else {
          flags = 0;
        }
        if (flags & 2) {
          notify(sub);
        }
        if (flags & 1) {
          const subSubs = sub._subs;
          if (subSubs !== void 0) {
            link3 = subSubs;
            if (subSubs.nextSub !== void 0) {
              stack = {
                value: next,
                prev: stack
              };
              next = link3.nextSub;
            }
            continue;
          }
        }
      }
      if ((link3 = next) !== void 0) {
        next = link3.nextSub;
        continue;
      }
      while (stack !== void 0) {
        link3 = stack.value;
        stack = stack.prev;
        if (link3 !== void 0) {
          next = link3.nextSub;
          continue top;
        }
      }
      break;
    } while (true);
  }
  function startTracking2(sub) {
    sub._depsTail = void 0;
    sub._flags = sub._flags & ~56 | 4;
  }
  function endTracking2(sub) {
    const depsTail = sub._depsTail;
    let toRemove = depsTail !== void 0 ? depsTail.nextDep : sub._deps;
    while (toRemove !== void 0) {
      toRemove = unlink2(toRemove, sub);
    }
    sub._flags &= ~4;
  }
  function checkDirty2(link3, sub) {
    let stack;
    let checkDepth = 0;
    top: do {
      const dep = link3.dep;
      const depFlags = dep._flags;
      let dirty = false;
      if (sub._flags & 16) {
        dirty = true;
      } else if ((depFlags & 17) === 17) {
        if (update2(dep)) {
          const subs = dep._subs;
          if (subs.nextSub !== void 0) {
            shallowPropagate2(subs);
          }
          dirty = true;
        }
      } else if ((depFlags & 33) === 33) {
        if (link3.nextSub !== void 0 || link3.prevSub !== void 0) {
          stack = {
            value: link3,
            prev: stack
          };
        }
        link3 = dep._deps;
        sub = dep;
        ++checkDepth;
        continue;
      }
      if (!dirty && link3.nextDep !== void 0) {
        link3 = link3.nextDep;
        continue;
      }
      while (checkDepth) {
        --checkDepth;
        const firstSub = sub._subs;
        const hasMultipleSubs = firstSub.nextSub !== void 0;
        if (hasMultipleSubs) {
          link3 = stack.value;
          stack = stack.prev;
        } else {
          link3 = firstSub;
        }
        if (dirty) {
          if (update2(sub)) {
            if (hasMultipleSubs) {
              shallowPropagate2(firstSub);
            }
            sub = link3.sub;
            continue;
          }
        } else {
          sub._flags &= ~32;
        }
        sub = link3.sub;
        if (link3.nextDep !== void 0) {
          link3 = link3.nextDep;
          continue top;
        }
        dirty = false;
      }
      return dirty;
    } while (true);
  }
  function shallowPropagate2(link3) {
    do {
      const sub = link3.sub;
      const nextSub = link3.nextSub;
      const subFlags = sub._flags;
      if ((subFlags & 48) === 32) {
        sub._flags = subFlags | 16;
        if (subFlags & 2) {
          notify(sub);
        }
      }
      link3 = nextSub;
    } while (link3 !== void 0);
  }
  function isValidLink(checkLink, sub) {
    const depsTail = sub._depsTail;
    if (depsTail !== void 0) {
      let link3 = sub._deps;
      do {
        if (link3 === checkLink) {
          return true;
        }
        if (link3 === depsTail) {
          break;
        }
        link3 = link3.nextDep;
      } while (link3 !== void 0);
    }
    return false;
  }
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  var _a, _b2, _c;
  const isObserver = typeof nextHandler === "object";
  const self = isObserver ? nextHandler : void 0;
  return {
    next: (_a = isObserver ? nextHandler.next : nextHandler) == null ? void 0 : _a.bind(self),
    error: (_b2 = isObserver ? nextHandler.error : errorHandler) == null ? void 0 : _b2.bind(self),
    complete: (_c = isObserver ? nextHandler.complete : completionHandler) == null ? void 0 : _c.bind(self)
  };
}
var queuedEffects = [];
var {
  link,
  unlink,
  propagate,
  checkDirty,
  endTracking,
  startTracking,
  shallowPropagate
} = createReactiveSystem({
  update(atom) {
    return atom._update();
  },
  notify(effect2) {
    queuedEffects[queuedEffectsLength++] = effect2;
  },
  unwatched(atom) {
    let toRemove = atom._deps;
    if (toRemove !== void 0) {
      atom._flags = 17;
      do {
        toRemove = unlink(toRemove, atom);
      } while (toRemove !== void 0);
    }
  }
});
var notifyIndex = 0;
var queuedEffectsLength = 0;
var activeSub;
function flush() {
  while (notifyIndex < queuedEffectsLength) {
    const effect2 = queuedEffects[notifyIndex];
    queuedEffects[notifyIndex++] = void 0;
    effect2.notify();
  }
  notifyIndex = 0;
  queuedEffectsLength = 0;
}
function createAtom(valueOrFn, options) {
  const isComputed = typeof valueOrFn === "function";
  const getter = valueOrFn;
  const atom = {
    _snapshot: isComputed ? void 0 : valueOrFn,
    _subs: void 0,
    _subsTail: void 0,
    _flags: 0,
    get() {
      if (activeSub !== void 0) {
        link(atom, activeSub);
      }
      return atom._snapshot;
    },
    subscribe(observerOrFn) {
      const obs = toObserver(observerOrFn);
      const observed = {
        current: false
      };
      const e = effect(() => {
        var _a;
        atom.get();
        if (!observed.current) {
          observed.current = true;
        } else {
          (_a = obs.next) == null ? void 0 : _a.call(obs, atom._snapshot);
        }
      });
      return {
        unsubscribe: () => {
          e.stop();
        }
      };
    },
    _update(getValue) {
      const prevSub = activeSub;
      const compare = (options == null ? void 0 : options.compare) ?? Object.is;
      activeSub = atom;
      startTracking(atom);
      try {
        const oldValue = atom._snapshot;
        const read = (atom2) => atom2.get();
        const newValue = typeof getValue === "function" ? getValue(oldValue) : getValue === void 0 && isComputed ? getter(read) : getValue;
        if (oldValue === void 0 || !compare(oldValue, newValue)) {
          atom._snapshot = newValue;
          return true;
        }
        return false;
      } finally {
        activeSub = prevSub;
        endTracking(atom);
      }
    }
  };
  if (isComputed) {
    Object.assign(atom, {
      _deps: void 0,
      _depsTail: void 0,
      _flags: 17,
      get() {
        const flags = this._flags;
        if (flags & 16 || flags & 32 && checkDirty(atom._deps, atom)) {
          if (atom._update()) {
            const subs = atom._subs;
            if (subs !== void 0) {
              shallowPropagate(subs);
            }
          }
        } else if (flags & 32) {
          atom._flags = flags & ~32;
        }
        if (activeSub !== void 0) {
          link(atom, activeSub);
        }
        return atom._snapshot;
      }
    });
  } else {
    Object.assign(atom, {
      set(valueOrFn2) {
        if (atom._update(valueOrFn2)) {
          const subs = atom._subs;
          if (subs !== void 0) {
            propagate(subs);
            shallowPropagate(subs);
            flush();
          }
        }
      }
    });
  }
  return atom;
}
function effect(fn) {
  const run = () => {
    const prevSub = activeSub;
    activeSub = effectObj;
    startTracking(effectObj);
    try {
      return fn();
    } finally {
      activeSub = prevSub;
      endTracking(effectObj);
    }
  };
  const effectObj = {
    _deps: void 0,
    _depsTail: void 0,
    _flags: 2,
    notify() {
      const flags = this._flags;
      if (flags & 16 || flags & 32 && checkDirty(this._deps, this)) {
        run();
      } else if (flags & 32) {
        this._flags = flags & ~32;
      }
    },
    stop() {
      startTracking(this);
      endTracking(this);
    }
  };
  run();
  return effectObj;
}
var symbolObservable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
function setter(context, recipe) {
  return recipe(context);
}
var inspectionObservers = /* @__PURE__ */ new WeakMap();
function createStoreCore(logic, emits) {
  let listeners;
  const initialSnapshot = logic.getInitialSnapshot();
  let currentSnapshot = initialSnapshot;
  const atom = createAtom(currentSnapshot);
  const emit = (ev) => {
    if (!listeners) {
      return;
    }
    const type = ev.type;
    const typeListeners = listeners.get(type);
    if (typeListeners) {
      typeListeners.forEach((listener) => listener(ev));
    }
  };
  const transition = logic.transition;
  function receive(event) {
    var _a, _b2;
    let effects;
    [currentSnapshot, effects] = transition(currentSnapshot, event);
    (_a = inspectionObservers.get(store3)) == null ? void 0 : _a.forEach((observer) => {
      var _a2;
      (_a2 = observer.next) == null ? void 0 : _a2.call(observer, {
        type: "@xstate.snapshot",
        event,
        snapshot: currentSnapshot,
        actorRef: store3,
        rootId: store3.sessionId
      });
    });
    atom.set(currentSnapshot);
    for (const effect2 of effects) {
      if (typeof effect2 === "function") {
        effect2();
      } else {
        (_b2 = emits == null ? void 0 : emits[effect2.type]) == null ? void 0 : _b2.call(emits, effect2);
        emit(effect2);
      }
    }
  }
  const store3 = {
    get _snapshot() {
      return atom._snapshot;
    },
    on(emittedEventType, handler) {
      if (!listeners) {
        listeners = /* @__PURE__ */ new Map();
      }
      let eventListeners = listeners.get(emittedEventType);
      if (!eventListeners) {
        eventListeners = /* @__PURE__ */ new Set();
        listeners.set(emittedEventType, eventListeners);
      }
      const wrappedHandler = handler.bind(void 0);
      eventListeners.add(wrappedHandler);
      return {
        unsubscribe() {
          eventListeners.delete(wrappedHandler);
        }
      };
    },
    transition: logic.transition,
    // TODO: fix this
    sessionId: uniqueId(),
    send(event) {
      var _a;
      (_a = inspectionObservers.get(store3)) == null ? void 0 : _a.forEach((observer) => {
        var _a2;
        (_a2 = observer.next) == null ? void 0 : _a2.call(observer, {
          type: "@xstate.event",
          event,
          sourceRef: void 0,
          actorRef: store3,
          rootId: store3.sessionId
        });
      });
      receive(event);
    },
    getSnapshot() {
      return currentSnapshot;
    },
    get() {
      return atom.get();
    },
    getInitialSnapshot() {
      return initialSnapshot;
    },
    subscribe: atom.subscribe.bind(atom),
    [symbolObservable]() {
      return this;
    },
    inspect: (observerOrFn) => {
      var _a, _b2;
      const observer = toObserver(observerOrFn);
      inspectionObservers.set(store3, inspectionObservers.get(store3) ?? /* @__PURE__ */ new Set());
      inspectionObservers.get(store3).add(observer);
      (_a = observer.next) == null ? void 0 : _a.call(observer, {
        type: "@xstate.actor",
        actorRef: store3,
        rootId: store3.sessionId
      });
      (_b2 = observer.next) == null ? void 0 : _b2.call(observer, {
        type: "@xstate.snapshot",
        snapshot: initialSnapshot,
        event: {
          type: "@xstate.init"
        },
        actorRef: store3,
        rootId: store3.sessionId
      });
      return {
        unsubscribe() {
          var _a2;
          return (_a2 = inspectionObservers.get(store3)) == null ? void 0 : _a2.delete(observer);
        }
      };
    },
    trigger: new Proxy({}, {
      get: (_, eventType) => {
        return (payload) => {
          store3.send({
            type: eventType,
            ...payload
          });
        };
      }
    }),
    select(selector, equalityFn = Object.is) {
      return createAtom(() => selector(store3.get().context), {
        compare: equalityFn
      });
    }
  };
  return store3;
}
function createStore(definitionOrLogic) {
  if ("transition" in definitionOrLogic) {
    return createStoreCore(definitionOrLogic);
  }
  const transition = createStoreTransition(definitionOrLogic.on);
  const logic = {
    getInitialSnapshot: () => ({
      status: "active",
      context: definitionOrLogic.context,
      output: void 0,
      error: void 0
    }),
    transition
  };
  return createStoreCore(logic, definitionOrLogic.emits);
}
function createStoreTransition(transitions, producer) {
  return (snapshot, event) => {
    let currentContext = snapshot.context;
    const assigner = transitions == null ? void 0 : transitions[event.type];
    const effects = [];
    const enqueue = {
      emit: new Proxy({}, {
        get: (_, eventType) => {
          return (payload) => {
            effects.push({
              ...payload,
              type: eventType
            });
          };
        }
      }),
      effect: (fn) => {
        effects.push(fn);
      }
    };
    if (!assigner) {
      return [snapshot, effects];
    }
    if (typeof assigner === "function") {
      currentContext = producer ? producer(currentContext, (draftContext) => assigner(draftContext, event, enqueue)) : setter(currentContext, (draftContext) => Object.assign({}, currentContext, assigner == null ? void 0 : assigner(
        draftContext,
        event,
        // TODO: help me
        enqueue
      )));
    } else {
      const partialUpdate = {};
      for (const key of Object.keys(assigner)) {
        const propAssignment = assigner[key];
        partialUpdate[key] = typeof propAssignment === "function" ? propAssignment(currentContext, event, enqueue) : propAssignment;
      }
      currentContext = Object.assign({}, currentContext, partialUpdate);
    }
    return [{
      ...snapshot,
      context: currentContext
    }, effects];
  };
}
function uniqueId() {
  return Math.random().toString(36).slice(6);
}

// node_modules/@graphprotocol/hypergraph/dist/inboxes/merge-messages.js
function mergeMessages(existingMessages, existingSeenIds, newMessages) {
  const messages = [...existingMessages];
  const seenMessageIds = new Set(existingSeenIds);
  const newFilteredMessages = newMessages.filter((msg) => !seenMessageIds.has(msg.id));
  for (const msg of newFilteredMessages) {
    seenMessageIds.add(msg.id);
  }
  if (newFilteredMessages.length > 0) {
    if (messages.length > 0 && newFilteredMessages[0].createdAt < messages[messages.length - 1].createdAt) {
      messages.push(...newFilteredMessages);
      messages.sort((a, b) => a.createdAt < b.createdAt ? -1 : 1);
    } else {
      messages.push(...newFilteredMessages);
    }
  }
  return {
    messages,
    seenMessageIds
  };
}

// node_modules/@graphprotocol/hypergraph/dist/store-connect.js
var initialStoreContext = {
  spaces: [],
  updatesInFlight: [],
  invitations: [],
  repo: null,
  identities: {},
  authenticated: false,
  accountAddress: null,
  sessionToken: null,
  keys: null,
  lastUpdateClock: {},
  accountInboxes: []
};
var store = createStore({
  context: initialStoreContext,
  on: {
    setInvitations: (context, event) => {
      return {
        ...context,
        invitations: event.invitations
      };
    },
    reset: (context) => {
      return {
        ...initialStoreContext,
        repo: context.repo
      };
    },
    addUpdateInFlight: (context, event) => {
      return {
        ...context,
        updatesInFlight: [...context.updatesInFlight, event.updateId]
      };
    },
    removeUpdateInFlight: (context, event) => {
      return {
        ...context,
        updatesInFlight: context.updatesInFlight.filter((id) => id !== event.updateId)
      };
    },
    applyEvent: (context, event) => {
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            return {
              ...space,
              events: [...space.events, event.event],
              state: event.state
            };
          }
          return space;
        })
      };
    },
    updateConfirmed: (context, event) => {
      return {
        ...context,
        lastUpdateClock: {
          ...context.lastUpdateClock,
          [event.spaceId]: event.clock
        }
      };
    },
    applyUpdate: (context, event) => {
      const lastUpdateClock = context.lastUpdateClock[event.spaceId] ?? -1;
      if (event.firstUpdateClock === lastUpdateClock + 1) {
        return {
          ...context,
          lastUpdateClock: {
            ...context.lastUpdateClock,
            [event.spaceId]: event.lastUpdateClock
          }
        };
      }
      return context;
    },
    addVerifiedIdentity: (context, event) => {
      return {
        ...context,
        identities: {
          ...context.identities,
          [event.accountAddress]: {
            encryptionPublicKey: event.encryptionPublicKey,
            signaturePublicKey: event.signaturePublicKey,
            accountProof: event.accountProof,
            keyProof: event.keyProof
          }
        }
      };
    },
    setSpaceInbox: (context, event) => {
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            const existingInbox = space.inboxes.find((inbox) => inbox.inboxId === event.inbox.inboxId);
            if (existingInbox) {
              return {
                ...space,
                inboxes: space.inboxes.map((inbox) => {
                  if (inbox.inboxId === event.inbox.inboxId) {
                    const {
                      messages,
                      seenMessageIds
                    } = mergeMessages(existingInbox.messages, existingInbox.seenMessageIds, event.inbox.messages);
                    return {
                      ...event.inbox,
                      messages,
                      seenMessageIds
                    };
                  }
                  return inbox;
                })
              };
            }
            return {
              ...space,
              inboxes: [...space.inboxes, event.inbox]
            };
          }
          return space;
        })
      };
    },
    setSpaceInboxMessages: (context, event) => {
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            return {
              ...space,
              inboxes: space.inboxes.map((inbox) => {
                if (inbox.inboxId === event.inboxId) {
                  const {
                    messages,
                    seenMessageIds
                  } = mergeMessages(inbox.messages, inbox.seenMessageIds, event.messages);
                  return {
                    ...inbox,
                    messages,
                    seenMessageIds,
                    lastMessageClock: new Date(Math.max(new Date(inbox.lastMessageClock).getTime(), new Date(event.lastMessageClock).getTime())).toISOString()
                  };
                }
                return inbox;
              })
            };
          }
          return space;
        })
      };
    },
    setAccountInbox: (context, event) => {
      const existingInbox = context.accountInboxes.find((inbox) => inbox.inboxId === event.inbox.inboxId);
      if (existingInbox) {
        return {
          ...context,
          accountInboxes: context.accountInboxes.map((inbox) => {
            if (inbox.inboxId === event.inbox.inboxId) {
              const {
                messages,
                seenMessageIds
              } = mergeMessages(existingInbox.messages, existingInbox.seenMessageIds, event.inbox.messages);
              return {
                ...event.inbox,
                messages,
                seenMessageIds
              };
            }
            return inbox;
          })
        };
      }
      return {
        ...context,
        accountInboxes: [...context.accountInboxes, event.inbox]
      };
    },
    setAccountInboxMessages: (context, event) => {
      return {
        ...context,
        accountInboxes: context.accountInboxes.map((inbox) => {
          if (inbox.inboxId === event.inboxId) {
            const {
              messages,
              seenMessageIds
            } = mergeMessages(inbox.messages, inbox.seenMessageIds, event.messages);
            return {
              ...inbox,
              messages,
              seenMessageIds,
              lastMessageClock: new Date(Math.max(new Date(inbox.lastMessageClock).getTime(), new Date(event.lastMessageClock).getTime())).toISOString()
            };
          }
          return inbox;
        })
      };
    },
    setSpace: (context, event) => {
      var _a;
      const existingSpace = context.spaces.find((s) => s.id === event.spaceId);
      if (!existingSpace && context.repo) {
        const result = context.repo.findWithProgress(idToAutomergeId(event.spaceId));
        result.handle.doneLoading();
        const newSpace = {
          id: event.spaceId,
          events: event.events,
          state: event.spaceState,
          keys: event.keys,
          automergeDocHandle: result.handle,
          inboxes: event.inboxes ?? []
        };
        return {
          ...context,
          spaces: [...context.spaces, newSpace],
          lastUpdateClock: {
            ...context.lastUpdateClock,
            [event.spaceId]: -1
          }
        };
      }
      let lastUpdateClock = context.lastUpdateClock[event.spaceId] ?? -1;
      if (((_a = event.updates) == null ? void 0 : _a.firstUpdateClock) === lastUpdateClock + 1) {
        lastUpdateClock = event.updates.lastUpdateClock;
      } else {
      }
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            const mergedInboxes = [...space.inboxes];
            for (const newInbox of event.inboxes ?? []) {
              const existingInboxIndex = mergedInboxes.findIndex((inbox) => inbox.inboxId === newInbox.inboxId);
              if (existingInboxIndex === -1) {
                mergedInboxes.push(newInbox);
              }
            }
            return {
              ...space,
              events: event.events,
              state: event.spaceState,
              keys: event.keys,
              inboxes: mergedInboxes
            };
          }
          return space;
        }),
        lastUpdateClock: {
          ...context.lastUpdateClock,
          [event.spaceId]: lastUpdateClock
        }
      };
    },
    setAuth: (context, event) => {
      return {
        ...context,
        authenticated: true,
        accountAddress: event.accountAddress,
        sessionToken: event.sessionToken,
        keys: event.keys
      };
    },
    resetAuth: (context) => {
      return {
        ...context,
        authenticated: false,
        accountAddress: null,
        sessionToken: null,
        keys: null
      };
    },
    setRepo: (context, event) => {
      return {
        ...context,
        repo: event.repo
      };
    }
  }
});

// node_modules/@graphprotocol/grc-20/dist/contracts.js
var MAINNET = {
  SPACE_PLUGIN_REPO_ADDRESS: "0xd9559df98e4103CDf0A119d4bff1537B383E462c",
  PERSONAL_SPACE_ADMIN_PLUGIN_REPO_ADDRESS: "0xa00870c6501349E126E71Dc1705fBaa2B5aeac0d",
  GOVERNANCE_PLUGIN_REPO_ADDRESS: "0x81A45db7E303eED5D8e0B84b39d96DBa23192Eab",
  DAO_FACTORY_ADDRESS: "0x9012fcc278a860B66e644cE491a1CbabFBb34a72",
  ENS_REGISTRY_ADDRESS: "0x81C575f78903F8aC1FD73dEC06d20ffdC51c9b4E",
  PLUGIN_SETUP_PROCESSOR_ADDRESS: "0xfcC0Aba63c1F1f887099EAB0d1A624A5B7A82Fc2"
};
var TESTNET = {
  SPACE_PLUGIN_REPO_ADDRESS: "0x0701454b0e80C53Ee8c3e0805616424758D7E7Fd",
  PERSONAL_SPACE_ADMIN_PLUGIN_REPO_ADDRESS: "0xAe8Ac47e5f3bDa62F6D1BD140AB8e1926D867355",
  GOVERNANCE_PLUGIN_REPO_ADDRESS: "0x70E786A75c7ef46C09665e25E1a683A936057087",
  DAO_FACTORY_ADDRESS: "0xb138AE700C352BB1aC75688e8ceCB98CDDaa7F09",
  ENS_REGISTRY_ADDRESS: "0xD065A680075d0e27777bAa63CFFf17e1713a19Df",
  PLUGIN_SETUP_PROCESSOR_ADDRESS: "0x3C9be4b42B313318091344A261DCDCd02DCd5736"
};

// node_modules/@rhinestone/module-sdk/_esm/account/api/getAccount.js
var getAccount = ({ address, initCode, type, deployedOnChains = [] }) => {
  return {
    address,
    initCode,
    type,
    deployedOnChains
  };
};

// node_modules/@rhinestone/module-sdk/_esm/constants.js
var ACCOUNT_LOCKER_HOOK = "0x0000000000f6Ed8Be424d673c63eeFF8b9267420";
var ACCOUNT_LOCKER_SOURCE_EXECUTOR = "0x000000000043ff16d5776c7F0f65Ec485C17Ca04";
var ACCOUNT_LOCKER_TARGET_EXECUTOR = "0x0000000000E5a37279A001301A837a91b5de1D5E";
var AUTO_SAVINGS_ADDRESS = "0x6AE48bD83B6bdc8489584Ea0814086f963d1BD95";
var COLD_STORAGE_FLASHLOAN_ADDRESS = "0x4422dbC3D055D59ee08F4A4D60E1046A9aFb287f";
var COLD_STORAGE_HOOK_ADDRESS = "0x7E31543b269632ddc55a23553f902f84C9DD8454";
var DEADMAN_SWITCH_ADDRESS = "0x8bAdE54bca47199B6732EB2F92318DD666bdE413";
var SMART_SESSIONS_FALLBACK_TARGET_FLAG = "0x0000000000000000000000000000000000000001";
var SMART_SESSIONS_FALLBACK_TARGET_SELECTOR_FLAG = "0x00000001";
var HOOK_MULTI_PLEXER_ADDRESS = "0xF6782ed057F95f334D04F0Af1Af4D14fb84DE549";
var INDEXER_URL = "https://indexer.bigdevenergy.link/c03b38d/v1/graphql";
var MULTI_FACTOR_VALIDATOR_ADDRESS = "0xf6bDf42c9BE18cEcA5C06c42A43DAf7FBbe7896b";
var OWNABLE_EXECUTOR_ADDRESS = "0x4Fd8d57b94966982B62e9588C27B4171B55E8354";
var OWNABLE_VALIDATOR_ADDRESS = "0x2483DA3A338895199E5e538530213157e931Bf06";
var REGISTRY_ADDRESS = "0x000000000069E2a187AEFFb852bF3cCdC95151B2";
var REGISTRY_HOOK_ADDRESS = "0x0ac6160DBA30d665cCA6e6b6a2CDf147DC3dED22";
var SCHEDULED_ORDERS_EXECUTOR_ADDRESS = "0x40dc90D670C89F322fa8b9f685770296428DCb6b";
var SCHEDULED_TRANSFERS_EXECUTOR_ADDRESS = "0xA8E374779aeE60413c974b484d6509c7E4DDb6bA";
var SMART_SESSIONS_ADDRESS = "0x00000000002B0eCfbD0496EE71e01257dA0E37DE";
var SMART_SESSIONS_COMPATIBILITY_FALLBACK_ADDRESS = "0xBad7E91C4F2803978cd6c7C3Fe80B5Fd7f7B0b50";
var SOCIAL_RECOVERY_ADDRESS = "0xA04D053b3C8021e8D5bF641816c42dAA75D8b597";
var SPENDING_LIMITS_POLICY_ADDRESS = "0x00000088D48cF102A8Cdb0137A9b173f957c6343";
var TIME_FRAME_POLICY_ADDRESS = "0x8177451511dE0577b911C254E9551D981C26dc72";
var SUDO_POLICY_ADDRESS = "0x0000003111cD8e92337C100F22B7A9dbf8DEE301";
var UNIVERSAL_ACTION_POLICY_ADDRESS = "0x0000006DDA6c463511C4e9B05CFc34C1247fCF1F";
var UNIVERSAL_EMAIL_RECOVERY_ADDRESS = "0x636632FA22052d2a4Fb6e3Bab84551B620b9C1F9";
var USAGE_LIMIT_POLICY_ADDRESS = "0x1F34eF8311345A3A4a4566aF321b313052F51493";
var VALUE_LIMIT_POLICY_ADDRESS = "0x730DA93267E7E513e932301B47F2ac7D062abC83";
var WEBAUTHN_VALIDATOR_ADDRESS = "0x2f167e55d42584f65e2e30a748f41ee75a311414";
var DEFAULT_CONSTANTS = {
  ACCOUNT_LOCKER_HOOK,
  ACCOUNT_LOCKER_SOURCE_EXECUTOR,
  ACCOUNT_LOCKER_TARGET_EXECUTOR,
  AUTO_SAVINGS_ADDRESS,
  COLD_STORAGE_FLASHLOAN_ADDRESS,
  COLD_STORAGE_HOOK_ADDRESS,
  DEADMAN_SWITCH_ADDRESS,
  SMART_SESSIONS_FALLBACK_TARGET_FLAG,
  SMART_SESSIONS_FALLBACK_TARGET_SELECTOR_FLAG,
  HOOK_MULTI_PLEXER_ADDRESS,
  INDEXER_URL,
  MULTI_FACTOR_VALIDATOR_ADDRESS,
  OWNABLE_EXECUTOR_ADDRESS,
  OWNABLE_VALIDATOR_ADDRESS,
  REGISTRY_ADDRESS,
  REGISTRY_HOOK_ADDRESS,
  SCHEDULED_ORDERS_EXECUTOR_ADDRESS,
  SCHEDULED_TRANSFERS_EXECUTOR_ADDRESS,
  SMART_SESSIONS_ADDRESS,
  SMART_SESSIONS_COMPATIBILITY_FALLBACK_ADDRESS,
  SOCIAL_RECOVERY_ADDRESS,
  SPENDING_LIMITS_POLICY_ADDRESS,
  TIME_FRAME_POLICY_ADDRESS,
  UNIVERSAL_ACTION_POLICY_ADDRESS,
  SUDO_POLICY_ADDRESS,
  UNIVERSAL_EMAIL_RECOVERY_ADDRESS,
  USAGE_LIMIT_POLICY_ADDRESS,
  VALUE_LIMIT_POLICY_ADDRESS,
  WEBAUTHN_VALIDATOR_ADDRESS
};
var GLOBAL_CONSTANTS = {
  ...DEFAULT_CONSTANTS
};

// node_modules/@rhinestone/module-sdk/_esm/common/queries/account.js
var query = `
    query ($smartAccount: String, $chainId: Int) {
       SmartAccount_ModuleQuery (where: { smartAccount: { _eq: $smartAccount }, isInstalled: { _eq: true }, chainId: { _eq: $chainId }}) {
        moduleAddress,
        moduleTypeId
      }
    }
  `;
var getInstalledModules = async ({ account, client }) => {
  const variables = {
    smartAccount: account.address,
    chainId: await client.getChainId()
  };
  const response = await fetch(GLOBAL_CONSTANTS.INDEXER_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      query,
      variables
    })
  });
  const responseBody = await response.json();
  if (response.ok) {
    return responseBody.data.SmartAccount_ModuleQuery.map((module) => module.module);
  } else {
    throw new Error(`Error: ${responseBody.errors.map((error) => error.message).join(", ")}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/constants/abis.js
var accountAbi = [
  "function getActiveHook() external view returns (address hook)",
  "function getValidatorsPaginated(address cursor,uint256 size) returns (address[] memory, address)",
  "function getExecutorsPaginated(address cursor,uint256 size) returns (address[] memory, address)",
  "function installModule(uint256 moduleTypeId,address module,bytes calldata initData)",
  "function uninstallModule(uint256 moduleTypeId,address module,bytes calldata deInitData)",
  "function isModuleInstalled(uint256 moduleTypeId,address module,bytes calldata additionalContext) returns (bool)"
];

// node_modules/@rhinestone/module-sdk/_esm/common/constants.js
var SENTINEL_ADDRESS = "0x0000000000000000000000000000000000000001";

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/getInstalledModules.js
var getInstalledModules2 = async ({ account, client }) => {
  let installedModules = [];
  try {
    installedModules = await getInstalledModules({
      account,
      client
    });
  } catch (e) {
  }
  if (installedModules.length === 0) {
    const installedValidators = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi),
      functionName: "getValidatorsPaginated",
      args: [SENTINEL_ADDRESS, 100]
    });
    for (const validator of installedValidators) {
      installedModules.push(validator);
    }
    const installedExecutors = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi),
      functionName: "getExecutorsPaginated",
      args: [SENTINEL_ADDRESS, 100]
    });
    for (const executor of installedExecutors) {
      installedModules.push(executor);
    }
    const installedHook = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi),
      functionName: "getActiveHook"
    });
    if (installedHook != zeroAddress) {
      installedModules.push(installedHook);
    }
  }
  return installedModules;
};

// node_modules/@rhinestone/module-sdk/_esm/module/types.js
var moduleTypeIds = {
  validator: 1,
  executor: 2,
  fallback: 3,
  hook: 4
};
var CallType;
(function(CallType2) {
  CallType2["CALLTYPE_SINGLE"] = "0x00";
  CallType2["CALLTYPE_BATCH"] = "0x01";
  CallType2["CALLTYPE_STATIC"] = "0xFE";
  CallType2["CALLTYPE_DELEGATECALL"] = "0xFF";
})(CallType || (CallType = {}));

// node_modules/@rhinestone/module-sdk/_esm/common/utils.js
var isContract = async ({ client, address }) => {
  const bytecode = await client.getBytecode({
    address
  });
  return bytecode && bytecode !== "0x";
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/isModuleInstalled.js
var isModuleInstalled = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return await _isModuleInstalled({ client, account, module });
    case "fallback":
      if (!module.selector) {
        throw new Error(`Selector param is required for module type ${module.type}`);
      }
      return await _isModuleInstalled({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _isModuleInstalled = async ({ client, account, module }) => {
  try {
    if (await isContract({ client, address: account.address })) {
      return await client.readContract({
        address: account.address,
        abi: parseAbi(accountAbi),
        functionName: "isModuleInstalled",
        args: [
          moduleTypeIds[module.type],
          module.module,
          module.selector ? encodeAbiParameters([{ name: "functionSignature", type: "bytes4" }], [module.selector]) : "0x"
        ]
      });
    }
    return false;
  } catch (e) {
    return false;
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/installModule.js
var installModule = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return _installModule({ client, account, module });
    case "fallback":
      if (!module.selector || !module.callType) {
        throw new Error(`Selector and callType params are required for module type ${module.type}`);
      }
      return installFallback({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _installModule = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled({ client, account, module });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        module.initData || "0x"
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
async function installFallback({ client, account, module }) {
  const executions = [];
  const isInstalled = await isModuleInstalled({
    client,
    account,
    module
  });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        encodePacked(["bytes4", "bytes1", "bytes"], [module.selector, module.callType, module.initData ?? "0x"])
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
}

// node_modules/@rhinestone/module-sdk/_esm/common/getPrevModule.js
var getPreviousModule = async ({ account, module, client }) => {
  let installedModules = await getInstalledModules({
    client,
    account
  });
  const index = installedModules.indexOf(getAddress(module.module));
  if (index === 0) {
    return SENTINEL_ADDRESS;
  } else if (index > 0) {
    return installedModules[index - 1];
  } else {
    throw new Error(`Module ${module.module} not found in installed modules`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/uninstallModule.js
var uninstallModule = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return _uninstallModule({ client, account, module });
    case "fallback":
      if (!module.selector) {
        throw new Error(`Selector param is required for module type ${module.type}`);
      }
      return _uninstallFallback({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _uninstallModule = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled({ client, account, module });
  if (isInstalled) {
    let moduleData = module.deInitData || "0x";
    if (module.type === "validator" || module.type === "executor") {
      const prev = await getPreviousModule({ client, account, module });
      moduleData = encodeAbiParameters([
        { name: "prev", type: "address" },
        { name: "disableModuleData", type: "bytes" }
      ], [prev, moduleData]);
    }
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi),
      args: [BigInt(moduleTypeIds[module.type]), module.module, moduleData]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
var _uninstallFallback = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled({
    client,
    account,
    module: {
      ...module,
      additionalContext: encodeAbiParameters([{ name: "functionSignature", type: "bytes4" }], [module.selector])
    }
  });
  if (isInstalled) {
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        encodePacked(["bytes4", "bytes"], [module.selector, module.deInitData])
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/encode1271Signature.js
var encode1271Signature = ({ account, validator, signature }) => {
  return encodePacked(["address", "bytes"], [validator, signature]);
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/encode1271Hash.js
var encode1271Hash = ({ account, chainId, validator, hash }) => {
  return hash;
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/encodeModuleInstallationData.js
var encodeModuleInstallationData = ({ account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return module.initData;
    case "fallback":
      return encodePacked(["bytes4", "bytes1", "bytes"], [
        module.selector,
        module.callType ?? CallType.CALLTYPE_SINGLE,
        module.initData
      ]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/encodeModuleUninstallationData.js
var encodeModuleUninstallationData = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      const prev = await getPreviousModule({ client, account, module });
      return encodeAbiParameters([
        { name: "prev", type: "address" },
        { name: "disableModuleData", type: "bytes" }
      ], [prev, module.deInitData]);
    case "hook":
      return module.deInitData;
    case "fallback":
      return encodePacked(["bytes4", "bytes"], [module.selector, module.deInitData]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/utils.js
function isAccount(obj) {
  const account = obj;
  return typeof obj === "object" && obj !== null && isAddress(account.address, { strict: false }) && (account.initCode === void 0 || account.initCode !== void 0 && typeof account.initCode === "string" && account.initCode.startsWith("0x")) && typeof account.type === "string" && isAccountType(account.type) && Array.isArray(account.deployedOnChains) && account.deployedOnChains.every((chainId) => typeof chainId === "number");
}
function isAccountType(value) {
  const validTypes = [
    "erc7579-implementation",
    "kernel",
    "safe",
    "nexus"
  ];
  return typeof value === "string" && validTypes.includes(value);
}
function isModule(object) {
  const module = object;
  return typeof object === "object" && object !== null && isAddress(module.address, { strict: false }) && typeof module.initData === "string" && module.initData.startsWith("0x") && typeof module.deInitData === "string" && module.deInitData.startsWith("0x") && typeof module.additionalContext === "string" && module.additionalContext.startsWith("0x") && isModuleType(module.type);
}
var isModuleType = (value) => {
  const validTypes = ["validator", "executor", "fallback", "hook"];
  return typeof value === "string" && validTypes.includes(value);
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/api/encodeValidatorNonce.js
var encodeValidatorNonce = ({ validator }) => {
  return BigInt(pad(isModule(validator) ? validator.address : validator, {
    dir: "right",
    size: 24
  }));
};

// node_modules/@rhinestone/module-sdk/_esm/account/erc7579-implementation/index.js
var ERC7579Implementation = class {
  constructor() {
    Object.defineProperty(this, "getInstalledModules", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ account, client }) => {
        return getInstalledModules2({ account, client });
      }
    });
    Object.defineProperty(this, "installModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return installModule({ client, account, module });
      }
    });
    Object.defineProperty(this, "isModuleInstalled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return isModuleInstalled({ client, account, module });
      }
    });
    Object.defineProperty(this, "uninstallModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return uninstallModule({ client, account, module });
      }
    });
    Object.defineProperty(this, "encode1271Signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, validator, signature }) => {
        return encode1271Signature({ account, validator, signature });
      }
    });
    Object.defineProperty(this, "encode1271Hash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, chainId, validator, hash }) => {
        return encode1271Hash({ account, chainId, validator, hash });
      }
    });
    Object.defineProperty(this, "encodeModuleInstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, module }) => {
        return encodeModuleInstallationData({ account, module });
      }
    });
    Object.defineProperty(this, "encodeModuleUninstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ client, account, module }) => {
        return await encodeModuleUninstallationData({ client, account, module });
      }
    });
    Object.defineProperty(this, "encodeValidatorNonce", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ validator }) => {
        return encodeValidatorNonce({ validator });
      }
    });
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/getInstalledModules.js
var getInstalledModules3 = async ({ account, client }) => {
  return getInstalledModules({ account, client });
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/constants/abis.js
var accountAbi2 = [...accountAbi];

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/types.js
var kernelModuleTypeIds = {
  validator: 1,
  executor: 2,
  fallback: 3,
  hook: 4,
  policy: 5,
  signer: 6
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/isModuleInstalled.js
var isModuleInstalled2 = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
    case "policy":
    case "signer":
      return await _isModuleInstalled2({ client, account, module });
    case "fallback":
      return await _isFallbackInstalled({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _isModuleInstalled2 = async ({ client, account, module }) => {
  if (await isContract({ client, address: account.address })) {
    return await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi2),
      functionName: "isModuleInstalled",
      args: [kernelModuleTypeIds[module.type], module.module, module.initData]
    });
  }
  return false;
};
var _isFallbackInstalled = async ({ client, account, module }) => {
  if (!module.selector) {
    throw new Error(`Selector is required for module type ${module.type}`);
  }
  if (await isContract({ client, address: account.address })) {
    return await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi2),
      functionName: "isModuleInstalled",
      args: [
        kernelModuleTypeIds[module.type],
        module.module,
        encodePacked(["bytes4"], [module.selector])
      ]
    });
  }
  return false;
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/installModule.js
var installModule2 = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return _installModule2({ client, account, module, withHook: true });
    case "hook":
    case "policy":
    case "signer":
      return _installModule2({ client, account, module, withHook: false });
    case "fallback":
      return installFallback2({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _installModule2 = async ({ client, account, module, withHook = false }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled2({ client, account, module });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi2),
      args: [
        BigInt(kernelModuleTypeIds[module.type]),
        module.module,
        withHook ? encodePacked(["address", "bytes"], [
          module.hook ?? zeroAddress,
          encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [module.initData || "0x", "0x"])
        ]) : module.initData || "0x"
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
async function installFallback2({ client, account, module }) {
  if (!module.selector || !module.callType) {
    throw new Error(`Hook, selector and callType are required for module type ${module.type}`);
  }
  const executions = [];
  const isInstalled = await isModuleInstalled2({
    client,
    account,
    module
  });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi2),
      args: [
        BigInt(kernelModuleTypeIds[module.type]),
        module.module,
        encodePacked(["bytes4", "address", "bytes"], [
          module.selector,
          module.hook ?? zeroAddress,
          encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [
            encodePacked(["bytes1", "bytes"], [module.callType, module.initData || "0x"]),
            "0x"
          ])
        ])
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
}

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/uninstallModule.js
var uninstallModule2 = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
    case "policy":
    case "signer":
      return _uninstallModule2({ client, account, module });
    case "fallback":
      return _uninstallFallback2({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _uninstallModule2 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled2({ client, account, module });
  if (isInstalled) {
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi2),
      args: [
        BigInt(kernelModuleTypeIds[module.type]),
        module.module,
        module.deInitData
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
var _uninstallFallback2 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled2({
    client,
    account,
    module: {
      ...module,
      initData: encodeAbiParameters([{ name: "functionSignature", type: "bytes4" }], [module.selector]) || "0x"
    }
  });
  if (isInstalled) {
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi2),
      args: [
        BigInt(kernelModuleTypeIds[module.type]),
        module.module,
        encodePacked(["bytes4", "bytes"], [module.selector, module.deInitData])
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/encode1271Signature.js
var encode1271Signature2 = ({ account, validator, signature }) => {
  return encodePacked(["bytes1", "address", "bytes"], ["0x01", validator, signature]);
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/encode1271Hash.js
var encode1271Hash2 = ({ account, chainId, validator, hash }) => {
  return hash;
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/encodeModuleInstallationData.js
var encodeModuleInstallationData2 = ({ account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return encodePacked(["address", "bytes"], [
        module.hook ?? zeroAddress,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [module.initData, "0x"])
      ]);
    case "hook":
      return module.initData;
    case "fallback":
      return encodePacked(["bytes4", "address", "bytes"], [
        module.selector,
        module.hook ?? zeroAddress,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [
          encodePacked(["bytes1", "bytes"], [module.callType, module.initData]),
          "0x"
        ])
      ]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/encodeModuleUninstallationData.js
var encodeModuleUninstallationData2 = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return module.deInitData;
    case "fallback":
      return encodePacked(["bytes4", "bytes"], [module.selector, module.deInitData]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/utils.js
function isKernelModule(object) {
  const module = object;
  return typeof object === "object" && object !== null && isAddress(module.address, { strict: false }) && typeof module.initData === "string" && module.initData.startsWith("0x") && typeof module.deInitData === "string" && module.deInitData.startsWith("0x") && typeof module.additionalContext === "string" && module.additionalContext.startsWith("0x") && isKernelModuleType(module.type);
}
var isKernelModuleType = (value) => {
  const validTypes = [
    "validator",
    "executor",
    "fallback",
    "hook",
    "policy",
    "signer"
  ];
  return typeof value === "string" && validTypes.includes(value);
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/api/encodeValidatorNonce.js
var encodeValidatorNonce2 = ({ validator }) => {
  return BigInt(pad(encodePacked(["bytes1", "bytes1", "address"], [
    "0x00",
    "0x00",
    isKernelModule(validator) ? validator.address : validator
  ]), {
    dir: "right",
    size: 24
  }));
};

// node_modules/@rhinestone/module-sdk/_esm/account/kernel/index.js
var KernelImplementation = class {
  constructor() {
    Object.defineProperty(this, "getInstalledModules", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ account, client }) => {
        return getInstalledModules3({ account, client });
      }
    });
    Object.defineProperty(this, "installModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return installModule2({ client, account, module });
      }
    });
    Object.defineProperty(this, "isModuleInstalled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return isModuleInstalled2({ client, account, module });
      }
    });
    Object.defineProperty(this, "uninstallModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return uninstallModule2({ client, account, module });
      }
    });
    Object.defineProperty(this, "encode1271Signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, validator, signature }) => {
        return encode1271Signature2({ account, validator, signature });
      }
    });
    Object.defineProperty(this, "encode1271Hash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, chainId, validator, hash }) => {
        return encode1271Hash2({ account, chainId, validator, hash });
      }
    });
    Object.defineProperty(this, "encodeModuleInstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, module }) => {
        return encodeModuleInstallationData2({ account, module });
      }
    });
    Object.defineProperty(this, "encodeModuleUninstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ client, account, module }) => {
        return await encodeModuleUninstallationData2({ client, account, module });
      }
    });
    Object.defineProperty(this, "encodeValidatorNonce", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ validator }) => {
        return encodeValidatorNonce2({ validator });
      }
    });
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/constants/abis.js
var accountAbi3 = [
  "function getActiveHook() external view returns (address hook)",
  "function getValidatorsPaginated(address cursor,uint256 size) returns (address[] memory, address)",
  "function getExecutorsPaginated(address cursor,uint256 size) returns (address[] memory, address)",
  "function installModule(uint256 moduleTypeId,address module,bytes calldata initData)",
  "function uninstallModule(uint256 moduleTypeId,address module,bytes calldata deInitData)",
  "function isModuleInstalled(uint256 moduleTypeId,address module,bytes calldata additionalContext) returns (bool)"
];

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/getInstalledModules.js
var getInstalledModules4 = async ({ account, client }) => {
  let installedModules = [];
  try {
    installedModules = await getInstalledModules({
      account,
      client
    });
  } catch (e) {
  }
  if (installedModules.length === 0) {
    const installedValidators = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi3),
      functionName: "getValidatorsPaginated",
      args: [SENTINEL_ADDRESS, 100]
    });
    for (const validator of installedValidators) {
      installedModules.push(validator);
    }
    const installedExecutors = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi3),
      functionName: "getExecutorsPaginated",
      args: [SENTINEL_ADDRESS, 100]
    });
    for (const executor of installedExecutors) {
      installedModules.push(executor);
    }
    const installedHook = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi3),
      functionName: "getActiveHook"
    });
    if (installedHook != zeroAddress) {
      installedModules.push(installedHook);
    }
  }
  return installedModules;
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/isModuleInstalled.js
var isModuleInstalled3 = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return await _isModuleInstalled3({ client, account, module });
    case "fallback":
      if (!module.selector) {
        throw new Error(`Selector param is required for module type ${module.type}`);
      }
      return await _isModuleInstalled3({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _isModuleInstalled3 = async ({ client, account, module }) => {
  try {
    if (await isContract({ client, address: account.address })) {
      return await client.readContract({
        address: account.address,
        abi: parseAbi(accountAbi3),
        functionName: "isModuleInstalled",
        args: [
          moduleTypeIds[module.type],
          module.module,
          module.selector ? encodeAbiParameters([{ name: "functionSignature", type: "bytes4" }], [module.selector]) : "0x"
        ]
      });
    }
    return false;
  } catch (e) {
    return false;
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/installModule.js
var installModule3 = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return _installModule3({ client, account, module });
    case "fallback":
      if (!module.selector || !module.callType) {
        throw new Error(`Selector and callType params are required for module type ${module.type}`);
      }
      return installFallback3({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _installModule3 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled3({ client, account, module });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi3),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        module.initData || "0x"
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
async function installFallback3({ client, account, module }) {
  const executions = [];
  const isInstalled = await isModuleInstalled3({
    client,
    account,
    module
  });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi3),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        encodePacked(["bytes4", "bytes1", "bytes"], [module.selector, module.callType, module.initData ?? "0x"])
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
}

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/uninstallModule.js
var uninstallModule3 = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return _uninstallModule3({ client, account, module });
    case "fallback":
      if (!module.selector) {
        throw new Error(`Selector param is required for module type ${module.type}`);
      }
      return _uninstallFallback3({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _uninstallModule3 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled3({ client, account, module });
  if (isInstalled) {
    let moduleData = module.deInitData;
    if (module.type === "validator" || module.type === "executor") {
      const prev = await getPreviousModule({ client, account, module });
      moduleData = encodeAbiParameters([
        { name: "prev", type: "address" },
        { name: "disableModuleData", type: "bytes" }
      ], [prev, moduleData]);
    }
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi3),
      args: [BigInt(moduleTypeIds[module.type]), module.module, moduleData]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
var _uninstallFallback3 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled3({
    client,
    account,
    module: {
      ...module,
      additionalContext: encodeAbiParameters([{ name: "functionSignature", type: "bytes4" }], [module.selector])
    }
  });
  if (isInstalled) {
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi3),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        encodePacked(["bytes4", "bytes"], [module.selector, module.deInitData])
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/encode1271Signature.js
var encode1271Signature3 = ({ account, validator, signature }) => {
  return encodePacked(["address", "bytes"], [validator, signature]);
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/encode1271Hash.js
var encode1271Hash3 = ({ account, chainId, validator, hash }) => {
  return hash;
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/encodeModuleInstallationData.js
var encodeModuleInstallationData3 = ({ account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
    case "hook":
      return module.initData;
    case "fallback":
      return encodePacked(["bytes4", "bytes1", "bytes"], [
        module.selector,
        module.callType ?? CallType.CALLTYPE_SINGLE,
        module.initData
      ]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/encodeModuleUninstallationData.js
var encodeModuleUninstallationData3 = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      const prev = await getPreviousModule({ client, account, module });
      return encodeAbiParameters([
        { name: "prev", type: "address" },
        { name: "disableModuleData", type: "bytes" }
      ], [prev, module.deInitData]);
    case "hook":
      return module.deInitData;
    case "fallback":
      return encodePacked(["bytes4", "bytes"], [module.selector, module.deInitData]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/api/encodeValidatorNonce.js
var encodeValidatorNonce3 = ({ validator }) => {
  return BigInt(pad(isModule(validator) ? validator.address : validator, {
    dir: "right",
    size: 24
  }));
};

// node_modules/@rhinestone/module-sdk/_esm/account/nexus/index.js
var NexusImplementation = class {
  constructor() {
    Object.defineProperty(this, "getInstalledModules", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ account, client }) => {
        return getInstalledModules4({ account, client });
      }
    });
    Object.defineProperty(this, "installModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return installModule3({ client, account, module });
      }
    });
    Object.defineProperty(this, "isModuleInstalled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return isModuleInstalled3({ client, account, module });
      }
    });
    Object.defineProperty(this, "uninstallModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return uninstallModule3({ client, account, module });
      }
    });
    Object.defineProperty(this, "encode1271Signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, validator, signature }) => {
        return encode1271Signature3({ account, validator, signature });
      }
    });
    Object.defineProperty(this, "encode1271Hash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, chainId, validator, hash }) => {
        return encode1271Hash3({ account, chainId, validator, hash });
      }
    });
    Object.defineProperty(this, "encodeModuleInstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, module }) => {
        return encodeModuleInstallationData3({ account, module });
      }
    });
    Object.defineProperty(this, "encodeModuleUninstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ client, account, module }) => {
        return await encodeModuleUninstallationData3({ client, account, module });
      }
    });
    Object.defineProperty(this, "encodeValidatorNonce", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ validator }) => {
        return encodeValidatorNonce3({ validator });
      }
    });
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/constants/abis.js
var accountAbi4 = [...accountAbi];

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/getInstalledModules.js
var getInstalledModules5 = async ({ account, client }) => {
  let installedModules = [];
  try {
    installedModules = await getInstalledModules({
      account,
      client
    });
  } catch (e) {
  }
  if (installedModules.length === 0) {
    const installedValidators = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi4),
      functionName: "getValidatorsPaginated",
      args: [SENTINEL_ADDRESS, 100]
    });
    for (const validator of installedValidators) {
      installedModules.push(validator);
    }
    const installedExecutors = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi4),
      functionName: "getExecutorsPaginated",
      args: [SENTINEL_ADDRESS, 100]
    });
    for (const executor of installedExecutors) {
      installedModules.push(executor);
    }
    const installedHook = await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi4),
      functionName: "getActiveHook"
    });
    if (installedHook != zeroAddress) {
      installedModules.push(installedHook);
    }
  }
  return installedModules;
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/isModuleInstalled.js
var isModuleInstalled4 = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return await _isModuleInstalled4({ client, account, module });
    case "hook":
      if (!module.selector || module.hookType === void 0) {
        throw new Error(`hookType and selector params are required for module type ${module.type}`);
      }
      return await _isModuleInstalled4({ client, account, module });
    case "fallback":
      if (!module.functionSig) {
        throw new Error(`functionSig param is required for module type ${module.type}`);
      }
      return await _isModuleInstalled4({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _isModuleInstalled4 = async ({ client, account, module }) => {
  if (await isContract({ client, address: account.address })) {
    return await client.readContract({
      address: account.address,
      abi: parseAbi(accountAbi4),
      functionName: "isModuleInstalled",
      args: [
        moduleTypeIds[module.type],
        module.module,
        getModuleAdditionalContext(module)
      ]
    });
  }
  return false;
};
var getModuleAdditionalContext = (module) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return "0x";
    case "hook":
      return encodeAbiParameters(parseAbiParameters("uint8 hookType, bytes4 selector"), [module.hookType, module.selector]);
    case "fallback":
      return encodeAbiParameters(parseAbiParameters("bytes4 functionSig"), [
        module.functionSig
      ]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/installModule.js
var installModule4 = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return _installModule4({ client, account, module });
    case "hook":
      if (!module.selector || module.hookType === void 0) {
        throw new Error(`hookType and selector params are required for module type ${module.type}`);
      }
      return _installModule4({ client, account, module });
    case "fallback":
      if (!module.functionSig || !module.callType) {
        throw new Error(`functionSig and callType params are required for module type ${module.type}`);
      }
      return _installModule4({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _installModule4 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled4({ client, account, module });
  if (!isInstalled) {
    const data = encodeFunctionData({
      functionName: "installModule",
      abi: parseAbi(accountAbi4),
      args: [
        BigInt(moduleTypeIds[module.type]),
        module.module,
        getModuleCalldata(module)
      ]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
var getModuleCalldata = (module) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return module.initData || "0x";
    case "hook":
      return encodeAbiParameters(parseAbiParameters("uint8 hookType, bytes4 selector, bytes memory initData"), [module.hookType, module.selector, module.initData || "0x"]);
    case "fallback":
      return encodeAbiParameters(parseAbiParameters("bytes4 functionSig, bytes1 calltype, bytes memory initData"), [module.functionSig, module.callType, module.initData || "0x"]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/uninstallModule.js
var uninstallModule4 = ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return _uninstallModule4({ client, account, module });
    case "hook":
      if (!module.selector || module.hookType === void 0) {
        throw new Error(`hookType and selector params are required for module type ${module.type}`);
      }
      return _uninstallModule4({ client, account, module });
    case "fallback":
      if (!module.functionSig) {
        throw new Error(`functionSig param is required for module type ${module.type}`);
      }
      return _uninstallModule4({ client, account, module });
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};
var _uninstallModule4 = async ({ client, account, module }) => {
  const executions = [];
  const isInstalled = await isModuleInstalled4({ client, account, module });
  if (isInstalled) {
    let moduleData = getModuleCalldata2(module);
    if (module.type === "validator" || module.type === "executor") {
      const prev = await getPreviousModule({ client, account, module });
      moduleData = encodeAbiParameters([
        { name: "prev", type: "address" },
        { name: "moduleInitData", type: "bytes" }
      ], [prev, moduleData]);
    }
    const data = encodeFunctionData({
      functionName: "uninstallModule",
      abi: parseAbi(accountAbi4),
      args: [BigInt(moduleTypeIds[module.type]), module.module, moduleData]
    });
    executions.push({
      to: account.address,
      target: account.address,
      value: BigInt(0),
      callData: data,
      data
    });
  }
  return executions;
};
var getModuleCalldata2 = (module) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return module.deInitData;
    case "hook":
      return encodeAbiParameters(parseAbiParameters("uint8 hookType, bytes4 selector, bytes memory deInitData"), [module.hookType, module.selector, module.deInitData]);
    case "fallback":
      return encodeAbiParameters(parseAbiParameters("bytes4 functionSig, bytes memory moduleDeInitData"), [module.functionSig, module.deInitData]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/encode1271Signature.js
var encode1271Signature4 = ({ account, validator, signature }) => {
  let formattedSignature = signature;
  if (account == validator) {
    const v = fromHex(slice(signature, 64, 65), "number");
    if (v < 30) {
      formattedSignature = concat([slice(signature, 0, 64), toHex(v + 4)]);
    }
  }
  return encodePacked(["address", "bytes"], [validator, formattedSignature]);
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/encode1271Hash.js
var encode1271Hash4 = ({ account, chainId, validator, hash }) => {
  if (validator == account) {
    return hashTypedData({
      domain: {
        chainId,
        verifyingContract: account
      },
      types: {
        SafeMessage: [{ name: "message", type: "bytes" }]
      },
      primaryType: "SafeMessage",
      message: {
        message: hash
      }
    });
  }
  return hash;
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/types.js
var SafeHookType;
(function(SafeHookType2) {
  SafeHookType2[SafeHookType2["GLOBAL"] = 0] = "GLOBAL";
  SafeHookType2[SafeHookType2["SIG"] = 1] = "SIG";
})(SafeHookType || (SafeHookType = {}));
var SafeCallType;
(function(SafeCallType2) {
  SafeCallType2["CALLTYPE_SINGLE"] = "0x00";
  SafeCallType2["CALLTYPE_BATCH"] = "0x01";
})(SafeCallType || (SafeCallType = {}));

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/encodeModuleInstallationData.js
var encodeModuleInstallationData4 = ({ account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      return module.initData;
    case "hook":
      return encodeAbiParameters(parseAbiParameters("uint8 hookType, bytes4 selector, bytes memory initData"), [
        module.hookType ?? SafeHookType.GLOBAL,
        module.hookType == SafeHookType.SIG ? module.selector : "0x00000000",
        module.initData
      ]);
    case "fallback":
      return encodeAbiParameters(parseAbiParameters("bytes4 functionSig, bytes1 calltype, bytes memory initData"), [
        module.functionSig,
        module.callType ?? CallType.CALLTYPE_SINGLE,
        module.initData
      ]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/encodeModuleUninstallationData.js
var encodeModuleUninstallationData4 = async ({ client, account, module }) => {
  switch (module.type) {
    case "validator":
    case "executor":
      const prev = await getPreviousModule({ client, account, module });
      return encodeAbiParameters([
        { name: "prev", type: "address" },
        { name: "disableModuleData", type: "bytes" }
      ], [prev, module.deInitData]);
    case "hook":
      return encodeAbiParameters(parseAbiParameters("uint8 hookType, bytes4 selector, bytes memory deInitData"), [
        module.hookType ?? SafeHookType.GLOBAL,
        module.hookType == SafeHookType.SIG ? module.selector : "0x00000000",
        module.deInitData
      ]);
    case "fallback":
      return encodeAbiParameters(parseAbiParameters("bytes4 functionSig, bytes memory moduleDeInitData"), [module.functionSig, module.deInitData]);
    default:
      throw new Error(`Unknown module type ${module.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/api/encodeValidatorNonce.js
var encodeValidatorNonce4 = ({ validator }) => {
  return BigInt(pad(isModule(validator) ? validator.address : validator, {
    dir: "right",
    size: 24
  }));
};

// node_modules/@rhinestone/module-sdk/_esm/account/safe/index.js
var SafeImplementation = class {
  constructor() {
    Object.defineProperty(this, "getInstalledModules", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ account, client }) => {
        return getInstalledModules5({ account, client });
      }
    });
    Object.defineProperty(this, "installModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return installModule4({ client, account, module });
      }
    });
    Object.defineProperty(this, "isModuleInstalled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return isModuleInstalled4({ client, account, module });
      }
    });
    Object.defineProperty(this, "uninstallModule", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ client, account, module }) => {
        return uninstallModule4({ client, account, module });
      }
    });
    Object.defineProperty(this, "encode1271Signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, validator, signature }) => {
        return encode1271Signature4({ account, validator, signature });
      }
    });
    Object.defineProperty(this, "encode1271Hash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, chainId, validator, hash }) => {
        return encode1271Hash4({ account, chainId, validator, hash });
      }
    });
    Object.defineProperty(this, "encodeModuleInstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ account, module }) => {
        return encodeModuleInstallationData4({ account, module });
      }
    });
    Object.defineProperty(this, "encodeModuleUninstallationData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: async ({ client, account, module }) => {
        return await encodeModuleUninstallationData4({ client, account, module });
      }
    });
    Object.defineProperty(this, "encodeValidatorNonce", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ({ validator }) => {
        return encodeValidatorNonce4({ validator });
      }
    });
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/api/getAccountImplementation.js
var getAccountImplementation = ({ account }) => {
  switch (account.type) {
    case "erc7579-implementation":
      return new ERC7579Implementation();
    case "kernel":
      return new KernelImplementation();
    case "safe":
      return new SafeImplementation();
    case "nexus":
      return new NexusImplementation();
    default:
      throw new Error(`Unsupported account type: ${account.type}`);
  }
};

// node_modules/@rhinestone/module-sdk/_esm/account/api/encodeValidatorNonce.js
var encodeValidatorNonce5 = ({ account, validator }) => {
  const accountImplementation = getAccountImplementation({ account });
  return accountImplementation.encodeValidatorNonce({
    validator
  });
};

// node_modules/@rhinestone/module-sdk/_esm/module/ownable-validator/constants.js
var OWNABLE_VALIDATOR_ADDRESS2 = "0x2483DA3A338895199E5e538530213157e931Bf06";

// node_modules/@rhinestone/module-sdk/_esm/module/ownable-validator/installation.js
var getOwnableValidator = ({ threshold, owners, hook }) => {
  return {
    address: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    module: GLOBAL_CONSTANTS.OWNABLE_VALIDATOR_ADDRESS,
    initData: encodeAbiParameters([
      { name: "threshold", type: "uint256" },
      { name: "owners", type: "address[]" }
    ], [
      BigInt(threshold),
      owners.map((owner) => owner.toLowerCase()).sort()
    ]),
    deInitData: "0x",
    additionalContext: "0x",
    hook,
    type: "validator"
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/ownable-validator/usage.js
var encodeValidationData = ({ threshold, owners }) => {
  return encodeAbiParameters([
    {
      type: "uint256"
    },
    {
      type: "address[]"
    }
  ], [BigInt(threshold), owners.sort()]);
};
var getOwnableValidatorSignature = ({ signatures }) => {
  let signature = signatures[0];
  for (let i = 1; i < signatures.length; i++) {
    signature = encodePacked(["bytes", "bytes"], [signature, signatures[i]]);
  }
  return signature;
};
var getOwnableValidatorMockSignature = ({ threshold }) => {
  const mockSignature = "0xe8b94748580ca0b4993c9a1b86b5be851bfc076ff5ce3a1ff65bf16392acfcb800f9b4f1aef1555c7fce5599fffb17e7c635502154a0333ba21f3ae491839af51c";
  return getOwnableValidatorSignature({
    signatures: Array(threshold).fill(mockSignature)
  });
};

// node_modules/@rhinestone/module-sdk/_esm/module/hook-multi-plexer/types.js
var HookType;
(function(HookType2) {
  HookType2[HookType2["GLOBAL"] = 0] = "GLOBAL";
  HookType2[HookType2["DELEGATECALL"] = 1] = "DELEGATECALL";
  HookType2[HookType2["VALUE"] = 2] = "VALUE";
  HookType2[HookType2["SIG"] = 3] = "SIG";
  HookType2[HookType2["TARGET"] = 4] = "TARGET";
})(HookType || (HookType = {}));

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/abi.js
var installSmartSessionsAbi = [
  {
    components: [
      {
        internalType: "contract ISessionValidator",
        name: "sessionValidator",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "sessionValidatorInitData",
        type: "bytes"
      },
      { internalType: "bytes32", name: "salt", type: "bytes32" },
      {
        components: [
          { internalType: "address", name: "policy", type: "address" },
          { internalType: "bytes", name: "initData", type: "bytes" }
        ],
        internalType: "struct PolicyData[]",
        name: "userOpPolicies",
        type: "tuple[]"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "appDomainSeparator",
                type: "bytes32"
              },
              {
                internalType: "string[]",
                name: "contentName",
                type: "string[]"
              }
            ],
            internalType: "struct ERC7739Context[]",
            name: "allowedERC7739Content",
            type: "tuple[]"
          },
          {
            components: [
              { internalType: "address", name: "policy", type: "address" },
              { internalType: "bytes", name: "initData", type: "bytes" }
            ],
            internalType: "struct PolicyData[]",
            name: "erc1271Policies",
            type: "tuple[]"
          }
        ],
        internalType: "struct ERC7739Data",
        name: "erc7739Policies",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "bytes4",
            name: "actionTargetSelector",
            type: "bytes4"
          },
          {
            internalType: "address",
            name: "actionTarget",
            type: "address"
          },
          {
            components: [
              { internalType: "address", name: "policy", type: "address" },
              { internalType: "bytes", name: "initData", type: "bytes" }
            ],
            internalType: "struct PolicyData[]",
            name: "actionPolicies",
            type: "tuple[]"
          }
        ],
        internalType: "struct ActionData[]",
        name: "actions",
        type: "tuple[]"
      },
      { internalType: "bool", name: "permitERC4337Paymaster", type: "bool" }
    ],
    internalType: "struct Session[]",
    name: "sessions",
    type: "tuple[]"
  }
];
var enableSessionAbi = {
  components: [
    {
      type: "uint8",
      name: "chainDigestIndex"
    },
    {
      type: "tuple[]",
      components: [
        {
          internalType: "uint64",
          name: "chainId",
          type: "uint64"
        },
        {
          internalType: "bytes32",
          name: "sessionDigest",
          type: "bytes32"
        }
      ],
      name: "hashesAndChainIds"
    },
    {
      components: [
        {
          internalType: "contract ISessionValidator",
          name: "sessionValidator",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "sessionValidatorInitData",
          type: "bytes"
        },
        { internalType: "bytes32", name: "salt", type: "bytes32" },
        {
          components: [
            { internalType: "address", name: "policy", type: "address" },
            { internalType: "bytes", name: "initData", type: "bytes" }
          ],
          internalType: "struct PolicyData[]",
          name: "userOpPolicies",
          type: "tuple[]"
        },
        {
          components: [
            {
              components: [
                {
                  internalType: "bytes32",
                  name: "appDomainSeparator",
                  type: "bytes32"
                },
                {
                  internalType: "string[]",
                  name: "contentName",
                  type: "string[]"
                }
              ],
              internalType: "struct ERC7739Context[]",
              name: "allowedERC7739Content",
              type: "tuple[]"
            },
            {
              components: [
                { internalType: "address", name: "policy", type: "address" },
                { internalType: "bytes", name: "initData", type: "bytes" }
              ],
              internalType: "struct PolicyData[]",
              name: "erc1271Policies",
              type: "tuple[]"
            }
          ],
          internalType: "struct ERC7739Data",
          name: "erc7739Policies",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "bytes4",
              name: "actionTargetSelector",
              type: "bytes4"
            },
            {
              internalType: "address",
              name: "actionTarget",
              type: "address"
            },
            {
              components: [
                { internalType: "address", name: "policy", type: "address" },
                { internalType: "bytes", name: "initData", type: "bytes" }
              ],
              internalType: "struct PolicyData[]",
              name: "actionPolicies",
              type: "tuple[]"
            }
          ],
          internalType: "struct ActionData[]",
          name: "actions",
          type: "tuple[]"
        },
        { internalType: "bool", name: "permitERC4337Paymaster", type: "bool" }
      ],
      internalType: "struct Session",
      name: "sessionToEnable",
      type: "tuple"
    },
    {
      type: "bytes",
      name: "permissionEnableSig"
    }
  ],
  internalType: "struct EnableSession",
  name: "enableSession",
  type: "tuple"
};
var encodeEnableSessionSignatureAbi = [
  enableSessionAbi,
  { type: "bytes" }
];
var abi13 = [
  {
    type: "function",
    name: "areActionsEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "actions",
        type: "tuple[]",
        internalType: "struct ActionData[]",
        components: [
          {
            name: "actionTargetSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "actionTarget",
            type: "address",
            internalType: "address"
          },
          {
            name: "actionPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "areERC1271PoliciesEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "erc1271Policies",
        type: "tuple[]",
        internalType: "struct PolicyData[]",
        components: [
          { name: "policy", type: "address", internalType: "address" },
          { name: "initData", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "areUserOpPoliciesEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "userOpPolicies",
        type: "tuple[]",
        internalType: "struct PolicyData[]",
        components: [
          { name: "policy", type: "address", internalType: "address" },
          { name: "initData", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "disableActionId",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "disableActionPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" },
      { name: "policies", type: "address[]", internalType: "address[]" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "disableERC1271Policies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "policies",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "contexts",
        type: "tuple[]",
        internalType: "struct ERC7739Context[]",
        components: [
          {
            name: "appDomainSeparator",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "contentName",
            type: "string[]",
            internalType: "string[]"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "disableUserOpPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policies", type: "address[]", internalType: "address[]" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableActionPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "actionPolicies",
        type: "tuple[]",
        internalType: "struct ActionData[]",
        components: [
          {
            name: "actionTargetSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "actionTarget",
            type: "address",
            internalType: "address"
          },
          {
            name: "actionPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableERC1271Policies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "erc1271Policies",
        type: "tuple",
        internalType: "struct ERC7739Data",
        components: [
          {
            name: "allowedERC7739Content",
            type: "tuple[]",
            internalType: "struct ERC7739Context[]",
            components: [
              {
                name: "appDomainSeparator",
                type: "bytes32",
                internalType: "bytes32"
              },
              {
                name: "contentName",
                type: "string[]",
                internalType: "string[]"
              }
            ]
          },
          {
            name: "erc1271Policies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableSessions",
    inputs: [
      {
        name: "sessions",
        type: "tuple[]",
        internalType: "struct Session[]",
        components: [
          {
            name: "sessionValidator",
            type: "address",
            internalType: "contract ISessionValidator"
          },
          {
            name: "sessionValidatorInitData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "salt", type: "bytes32", internalType: "bytes32" },
          {
            name: "userOpPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          },
          {
            name: "erc7739Policies",
            type: "tuple",
            internalType: "struct ERC7739Data",
            components: [
              {
                name: "allowedERC7739Content",
                type: "tuple[]",
                internalType: "struct ERC7739Context[]",
                components: [
                  {
                    name: "appDomainSeparator",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "contentName",
                    type: "string[]",
                    internalType: "string[]"
                  }
                ]
              },
              {
                name: "erc1271Policies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct ActionData[]",
            components: [
              {
                name: "actionTargetSelector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "actionTarget",
                type: "address",
                internalType: "address"
              },
              {
                name: "actionPolicies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "permitERC4337Paymaster",
            type: "bool",
            internalType: "bool"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "permissionIds",
        type: "bytes32[]",
        internalType: "PermissionId[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "enableUserOpPolicies",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "userOpPolicies",
        type: "tuple[]",
        internalType: "struct PolicyData[]",
        components: [
          { name: "policy", type: "address", internalType: "address" },
          { name: "initData", type: "bytes", internalType: "bytes" }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getActionPolicies",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" }
    ],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getERC1271Policies",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getEnabledActions",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [{ name: "", type: "bytes32[]", internalType: "bytes32[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getEnabledERC7739Content",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [
      {
        name: "enabledERC7739ContentHashes",
        type: "tuple[]",
        internalType: "struct ERC7739ContextHashes[]",
        components: [
          {
            name: "appDomainSeparator",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "contentNameHashes",
            type: "bytes32[]",
            internalType: "bytes32[]"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getNonce",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "uint256", internalType: "uint256" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPermissionIDs",
    inputs: [{ name: "account", type: "address", internalType: "address" }],
    outputs: [
      {
        name: "permissionIds",
        type: "bytes32[]",
        internalType: "PermissionId[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPermissionId",
    inputs: [
      {
        name: "session",
        type: "tuple",
        internalType: "struct Session",
        components: [
          {
            name: "sessionValidator",
            type: "address",
            internalType: "contract ISessionValidator"
          },
          {
            name: "sessionValidatorInitData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "salt", type: "bytes32", internalType: "bytes32" },
          {
            name: "userOpPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          },
          {
            name: "erc7739Policies",
            type: "tuple",
            internalType: "struct ERC7739Data",
            components: [
              {
                name: "allowedERC7739Content",
                type: "tuple[]",
                internalType: "struct ERC7739Context[]",
                components: [
                  {
                    name: "appDomainSeparator",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "contentName",
                    type: "string[]",
                    internalType: "string[]"
                  }
                ]
              },
              {
                name: "erc1271Policies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct ActionData[]",
            components: [
              {
                name: "actionTargetSelector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "actionTarget",
                type: "address",
                internalType: "address"
              },
              {
                name: "actionPolicies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "permitERC4337Paymaster",
            type: "bool",
            internalType: "bool"
          }
        ]
      }
    ],
    outputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "getSessionDigest",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" },
      {
        name: "data",
        type: "tuple",
        internalType: "struct Session",
        components: [
          {
            name: "sessionValidator",
            type: "address",
            internalType: "contract ISessionValidator"
          },
          {
            name: "sessionValidatorInitData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "salt", type: "bytes32", internalType: "bytes32" },
          {
            name: "userOpPolicies",
            type: "tuple[]",
            internalType: "struct PolicyData[]",
            components: [
              {
                name: "policy",
                type: "address",
                internalType: "address"
              },
              { name: "initData", type: "bytes", internalType: "bytes" }
            ]
          },
          {
            name: "erc7739Policies",
            type: "tuple",
            internalType: "struct ERC7739Data",
            components: [
              {
                name: "allowedERC7739Content",
                type: "tuple[]",
                internalType: "struct ERC7739Context[]",
                components: [
                  {
                    name: "appDomainSeparator",
                    type: "bytes32",
                    internalType: "bytes32"
                  },
                  {
                    name: "contentName",
                    type: "string[]",
                    internalType: "string[]"
                  }
                ]
              },
              {
                name: "erc1271Policies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "actions",
            type: "tuple[]",
            internalType: "struct ActionData[]",
            components: [
              {
                name: "actionTargetSelector",
                type: "bytes4",
                internalType: "bytes4"
              },
              {
                name: "actionTarget",
                type: "address",
                internalType: "address"
              },
              {
                name: "actionPolicies",
                type: "tuple[]",
                internalType: "struct PolicyData[]",
                components: [
                  {
                    name: "policy",
                    type: "address",
                    internalType: "address"
                  },
                  {
                    name: "initData",
                    type: "bytes",
                    internalType: "bytes"
                  }
                ]
              }
            ]
          },
          {
            name: "permitERC4337Paymaster",
            type: "bool",
            internalType: "bool"
          }
        ]
      },
      {
        name: "mode",
        type: "uint8",
        internalType: "enum SmartSessionMode"
      }
    ],
    outputs: [{ name: "", type: "bytes32", internalType: "bytes32" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getSessionValidatorAndConfig",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [
      {
        name: "sessionValidator",
        type: "address",
        internalType: "address"
      },
      {
        name: "sessionValidatorData",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getUserOpPolicies",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [{ name: "", type: "address[]", internalType: "address[]" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isActionIdEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isActionPolicyEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "actionId", type: "bytes32", internalType: "ActionId" },
      { name: "policy", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isERC1271PolicyEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policy", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isERC7739ContentEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "appDomainSeparator",
        type: "bytes32",
        internalType: "bytes32"
      },
      { name: "content", type: "string", internalType: "string" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isISessionValidatorSet",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isInitialized",
    inputs: [
      { name: "smartAccount", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isModuleType",
    inputs: [{ name: "typeID", type: "uint256", internalType: "uint256" }],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "pure"
  },
  {
    type: "function",
    name: "isPermissionEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isUserOpPolicyEnabled",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policy", type: "address", internalType: "address" }
    ],
    outputs: [{ name: "", type: "bool", internalType: "bool" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isValidSignatureWithSender",
    inputs: [
      { name: "sender", type: "address", internalType: "address" },
      { name: "hash", type: "bytes32", internalType: "bytes32" },
      { name: "signature", type: "bytes", internalType: "bytes" }
    ],
    outputs: [{ name: "result", type: "bytes4", internalType: "bytes4" }],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "onInstall",
    inputs: [{ name: "data", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "onUninstall",
    inputs: [{ name: "", type: "bytes", internalType: "bytes" }],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "removeSession",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeEnableSignature",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "setpermitERC4337Paymaster",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "enabled", type: "bool", internalType: "bool" }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "validateUserOp",
    inputs: [
      {
        name: "userOp",
        type: "tuple",
        internalType: "struct PackedUserOperation",
        components: [
          { name: "sender", type: "address", internalType: "address" },
          { name: "nonce", type: "uint256", internalType: "uint256" },
          { name: "initCode", type: "bytes", internalType: "bytes" },
          { name: "callData", type: "bytes", internalType: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32",
            internalType: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256",
            internalType: "uint256"
          },
          { name: "gasFees", type: "bytes32", internalType: "bytes32" },
          {
            name: "paymasterAndData",
            type: "bytes",
            internalType: "bytes"
          },
          { name: "signature", type: "bytes", internalType: "bytes" }
        ]
      },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" }
    ],
    outputs: [{ name: "vd", type: "uint256", internalType: "ValidationData" }],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "ActionIdDisabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "actionId",
        type: "bytes32",
        indexed: false,
        internalType: "ActionId"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "NonceIterated",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "account",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "newValue",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PermissionIdpermitERC4337Paymaster",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "enabled",
        type: "bool",
        indexed: false,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PolicyDisabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "policyType",
        type: "uint8",
        indexed: false,
        internalType: "enum PolicyType"
      },
      {
        name: "policy",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PolicyEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "policyType",
        type: "uint8",
        indexed: false,
        internalType: "enum PolicyType"
      },
      {
        name: "policy",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionCreated",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "account",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionRemoved",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionValidatorDisabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "sessionValidator",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "SessionValidatorEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        indexed: false,
        internalType: "PermissionId"
      },
      {
        name: "sessionValidator",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "smartAccount",
        type: "address",
        indexed: false,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "error",
    name: "AssociatedArray_OutOfBounds",
    inputs: [{ name: "index", type: "uint256", internalType: "uint256" }]
  },
  {
    type: "error",
    name: "ChainIdMismatch",
    inputs: [
      {
        name: "providedChainId",
        type: "uint64",
        internalType: "uint64"
      }
    ]
  },
  {
    type: "error",
    name: "ChainIdMismatch",
    inputs: [
      {
        name: "providedChainId",
        type: "uint64",
        internalType: "uint64"
      }
    ]
  },
  { type: "error", name: "ForbiddenValidationData", inputs: [] },
  {
    type: "error",
    name: "HashIndexOutOfBounds",
    inputs: [{ name: "index", type: "uint256", internalType: "uint256" }]
  },
  {
    type: "error",
    name: "HashMismatch",
    inputs: [
      {
        name: "providedHash",
        type: "bytes32",
        internalType: "bytes32"
      },
      { name: "computedHash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  {
    type: "error",
    name: "HashMismatch",
    inputs: [
      {
        name: "providedHash",
        type: "bytes32",
        internalType: "bytes32"
      },
      { name: "computedHash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  { type: "error", name: "InvalidActionId", inputs: [] },
  { type: "error", name: "InvalidCallTarget", inputs: [] },
  { type: "error", name: "InvalidData", inputs: [] },
  {
    type: "error",
    name: "InvalidEnableSignature",
    inputs: [
      { name: "account", type: "address", internalType: "address" },
      { name: "hash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  {
    type: "error",
    name: "InvalidISessionValidator",
    inputs: [
      {
        name: "sessionValidator",
        type: "address",
        internalType: "contract ISessionValidator"
      }
    ]
  },
  { type: "error", name: "InvalidMode", inputs: [] },
  {
    type: "error",
    name: "InvalidPermissionId",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  { type: "error", name: "InvalidSelfCall", inputs: [] },
  {
    type: "error",
    name: "InvalidSession",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  {
    type: "error",
    name: "InvalidSessionKeySignature",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      {
        name: "sessionValidator",
        type: "address",
        internalType: "address"
      },
      { name: "account", type: "address", internalType: "address" },
      { name: "userOpHash", type: "bytes32", internalType: "bytes32" }
    ]
  },
  { type: "error", name: "InvalidTarget", inputs: [] },
  {
    type: "error",
    name: "InvalidUserOpSender",
    inputs: [{ name: "sender", type: "address", internalType: "address" }]
  },
  { type: "error", name: "NoExecutionsInBatch", inputs: [] },
  {
    type: "error",
    name: "NoPoliciesSet",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  { type: "error", name: "PartlyEnabledActions", inputs: [] },
  { type: "error", name: "PartlyEnabledPolicies", inputs: [] },
  {
    type: "error",
    name: "PaymasterValidationNotEnabled",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      }
    ]
  },
  {
    type: "error",
    name: "PolicyViolation",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "policy", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "SignerNotFound",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "SignerNotFound",
    inputs: [
      {
        name: "permissionId",
        type: "bytes32",
        internalType: "PermissionId"
      },
      { name: "account", type: "address", internalType: "address" }
    ]
  },
  {
    type: "error",
    name: "SmartSessionModuleAlreadyInstalled",
    inputs: [{ name: "account", type: "address", internalType: "address" }]
  },
  { type: "error", name: "UnsupportedExecutionType", inputs: [] },
  {
    type: "error",
    name: "UnsupportedPolicy",
    inputs: [{ name: "policy", type: "address", internalType: "address" }]
  },
  {
    type: "error",
    name: "UnsupportedSmartSessionMode",
    inputs: [
      {
        name: "mode",
        type: "uint8",
        internalType: "enum SmartSessionMode"
      }
    ]
  }
];

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/types.js
var SmartSessionMode = {
  USE: "0x00",
  ENABLE: "0x01",
  UNSAFE_ENABLE: "0x02"
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/installation.js
var getSmartSessionsValidator = ({ sessions, useRegistry = true, hook }) => {
  return {
    address: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    module: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    initData: (sessions == null ? void 0 : sessions.length) ? encodePacked(["bytes1", "bytes"], [
      useRegistry ? SmartSessionMode.ENABLE : SmartSessionMode.UNSAFE_ENABLE,
      encodeAbiParameters(installSmartSessionsAbi, [sessions])
    ]) : "0x",
    deInitData: "0x",
    additionalContext: "0x",
    type: "validator",
    hook
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/usage.js
var import_solady = __toESM(require_solady(), 1);
var getPermissionId = ({ session }) => {
  return keccak256(encodeAbiParameters([
    {
      type: "address",
      name: "sessionValidator"
    },
    {
      type: "bytes",
      name: "sessionValidatorInitData"
    },
    {
      type: "bytes32",
      name: "salt"
    }
  ], [
    session.sessionValidator,
    session.sessionValidatorInitData,
    session.salt
  ]));
};
var getSessionNonce = async ({ client, account, permissionId }) => {
  return await client.readContract({
    address: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    abi: abi13,
    functionName: "getNonce",
    args: [permissionId, isAccount(account) ? account.address : account]
  });
};
var getSessionDigest = async ({ client, account, session, permissionId, mode: mode2 }) => {
  return await client.readContract({
    address: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
    abi: abi13,
    functionName: "getSessionDigest",
    args: [permissionId, account.address, session, Number(mode2)]
  });
};
var encodeSmartSessionSignature = ({ mode: mode2, permissionId, signature, enableSessionData }) => {
  switch (mode2) {
    case SmartSessionMode.USE:
      return encodePacked(["bytes1", "bytes32", "bytes"], [mode2, permissionId, signature]);
    case SmartSessionMode.ENABLE:
    case SmartSessionMode.UNSAFE_ENABLE:
      if (!enableSessionData) {
        throw new Error("enableSession is required for ENABLE mode");
      }
      return encodePacked(["bytes1", "bytes"], [
        mode2,
        import_solady.LibZip.flzCompress(encodeEnableSessionSignature({ enableSessionData, signature }))
      ]);
    default:
      throw new Error(`Unknown mode ${mode2}`);
  }
};
var hashChainSessions = (chainSessions) => {
  return hashTypedData({
    domain: {
      name: "SmartSession",
      version: "1"
    },
    types: {
      PolicyData: [
        { name: "policy", type: "address" },
        { name: "initData", type: "bytes" }
      ],
      ActionData: [
        { name: "actionTargetSelector", type: "bytes4" },
        { name: "actionTarget", type: "address" },
        { name: "actionPolicies", type: "PolicyData[]" }
      ],
      ERC7739Context: [
        { name: "appDomainSeparator", type: "bytes32" },
        { name: "contentName", type: "string[]" }
      ],
      ERC7739Data: [
        { name: "allowedERC7739Content", type: "ERC7739Context[]" },
        { name: "erc1271Policies", type: "PolicyData[]" }
      ],
      SignedPermissions: [
        { name: "permitGenericPolicy", type: "bool" },
        { name: "permitAdminAccess", type: "bool" },
        { name: "ignoreSecurityAttestations", type: "bool" },
        { name: "permitERC4337Paymaster", type: "bool" },
        { name: "userOpPolicies", type: "PolicyData[]" },
        { name: "erc7739Policies", type: "ERC7739Data" },
        { name: "actions", type: "ActionData[]" }
      ],
      SignedSession: [
        { name: "account", type: "address" },
        { name: "permissions", type: "SignedPermissions" },
        { name: "sessionValidator", type: "address" },
        { name: "sessionValidatorInitData", type: "bytes" },
        { name: "salt", type: "bytes32" },
        { name: "smartSession", type: "address" },
        { name: "nonce", type: "uint256" }
      ],
      ChainSession: [
        { name: "chainId", type: "uint64" },
        { name: "session", type: "SignedSession" }
      ],
      MultiChainSession: [
        { name: "sessionsAndChainIds", type: "ChainSession[]" }
      ]
    },
    primaryType: "MultiChainSession",
    message: {
      sessionsAndChainIds: chainSessions
    }
  });
};
var encodeEnableSessionSignature = ({ enableSessionData, signature }) => {
  return encodeAbiParameters(encodeEnableSessionSignatureAbi, [
    {
      chainDigestIndex: enableSessionData.enableSession.chainDigestIndex,
      hashesAndChainIds: enableSessionData.enableSession.hashesAndChainIds,
      sessionToEnable: enableSessionData.enableSession.sessionToEnable,
      permissionEnableSig: formatPermissionEnableSig({
        signature: enableSessionData.enableSession.permissionEnableSig,
        validator: enableSessionData.validator,
        accountType: enableSessionData.accountType
      })
    },
    signature
  ]);
};
var formatPermissionEnableSig = ({ signature, validator, accountType }) => {
  switch (accountType) {
    case "erc7579-implementation":
      return encodePacked(["address", "bytes"], [validator, signature]);
    case "nexus":
      return encodePacked(["address", "bytes"], [validator, signature]);
    case "safe":
      return encodePacked(["address", "bytes"], [validator, signature]);
    case "kernel":
      return encodePacked(["bytes1", "address", "bytes"], ["0x01", validator, signature]);
    default:
      throw new Error(`Unsupported account type: ${accountType}`);
  }
};
var getEnableSessionDetails = async ({ sessions, sessionIndex, enableMode, account, clients, enableValidatorAddress, permitGenericPolicy = false, permitAdminAccess = false, ignoreSecurityAttestations = false, sessionNonces }) => {
  const chainDigests = [];
  const chainSessions = [];
  for (const session of sessions) {
    const permissionId2 = getPermissionId({
      session
    });
    const client = clients.find((c) => {
      var _a;
      return BigInt(((_a = c.chain) == null ? void 0 : _a.id) ?? 0) === session.chainId;
    });
    if (!client) {
      throw new Error(`Client not found for chainId ${session.chainId}`);
    }
    const currentIndex = sessions.indexOf(session);
    const sessionNonce = (sessionNonces == null ? void 0 : sessionNonces[currentIndex]) ?? await getSessionNonce({
      client,
      account,
      permissionId: permissionId2
    });
    const sessionDigest = await getSessionDigest({
      client,
      account,
      session,
      mode: enableMode || SmartSessionMode.ENABLE,
      permissionId: permissionId2
    });
    chainDigests.push({
      chainId: session.chainId,
      sessionDigest
    });
    chainSessions.push({
      chainId: session.chainId,
      session: {
        ...session,
        permissions: {
          permitGenericPolicy,
          permitAdminAccess,
          ignoreSecurityAttestations,
          permitERC4337Paymaster: session.permitERC4337Paymaster,
          userOpPolicies: session.userOpPolicies,
          erc7739Policies: session.erc7739Policies,
          actions: session.actions
        },
        account: account.address,
        smartSession: GLOBAL_CONSTANTS.SMART_SESSIONS_ADDRESS,
        nonce: sessionNonce
      }
    });
  }
  const permissionEnableHash = hashChainSessions(chainSessions);
  const sessionToEnable = sessions[sessionIndex || 0];
  const permissionId = getPermissionId({
    session: sessionToEnable
  });
  return {
    permissionEnableHash,
    mode: enableMode || SmartSessionMode.ENABLE,
    permissionId,
    signature: "0x",
    enableSessionData: {
      enableSession: {
        chainDigestIndex: sessionIndex || 0,
        hashesAndChainIds: chainDigests,
        sessionToEnable,
        permissionEnableSig: "0x"
      },
      validator: enableValidatorAddress ?? sessionToEnable.sessionValidator,
      accountType: account.type
    }
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/spending-limits-policy/installation.js
var getSpendingLimitsPolicy = (params) => {
  return {
    policy: GLOBAL_CONSTANTS.SPENDING_LIMITS_POLICY_ADDRESS,
    address: GLOBAL_CONSTANTS.SPENDING_LIMITS_POLICY_ADDRESS,
    initData: encodeAbiParameters([{ type: "address[]" }, { type: "uint256[]" }], [params.map(({ token }) => token), params.map(({ limit }) => limit)])
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/sudo-policy/installation.js
var getSudoPolicy = () => {
  return {
    policy: GLOBAL_CONSTANTS.SUDO_POLICY_ADDRESS,
    address: GLOBAL_CONSTANTS.SUDO_POLICY_ADDRESS,
    initData: "0x"
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/universal-action-policy/constants.js
var MAX_RULES = 16;

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/universal-action-policy/installation.js
var getUniversalActionPolicy = (actionConfig) => {
  if (actionConfig.paramRules.rules.length > MAX_RULES) {
    throw new Error(`Max number of rules is ${MAX_RULES}`);
  }
  return {
    policy: GLOBAL_CONSTANTS.UNIVERSAL_ACTION_POLICY_ADDRESS,
    address: GLOBAL_CONSTANTS.UNIVERSAL_ACTION_POLICY_ADDRESS,
    initData: encodeAbiParameters([
      {
        components: [
          {
            name: "valueLimitPerUse",
            type: "uint256"
          },
          {
            components: [
              {
                name: "length",
                type: "uint256"
              },
              {
                components: [
                  {
                    name: "condition",
                    type: "uint8"
                  },
                  {
                    name: "offset",
                    type: "uint64"
                  },
                  {
                    name: "isLimited",
                    type: "bool"
                  },
                  {
                    name: "ref",
                    type: "bytes32"
                  },
                  {
                    components: [
                      {
                        name: "limit",
                        type: "uint256"
                      },
                      {
                        name: "used",
                        type: "uint256"
                      }
                    ],
                    name: "usage",
                    type: "tuple"
                  }
                ],
                name: "rules",
                type: "tuple[16]"
              }
            ],
            name: "paramRules",
            type: "tuple"
          }
        ],
        name: "ActionConfig",
        type: "tuple"
      }
    ], [actionConfig])
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/time-frame-policy/installation.js
var getTimeFramePolicy = (param) => {
  return {
    policy: GLOBAL_CONSTANTS.TIME_FRAME_POLICY_ADDRESS,
    address: GLOBAL_CONSTANTS.TIME_FRAME_POLICY_ADDRESS,
    initData: encodePacked(["uint128", "uint128"], [BigInt(param.validUntil), BigInt(param.validAfter)])
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/usage-limit-policy/installation.js
var getUsageLimitPolicy = (params) => {
  return {
    policy: GLOBAL_CONSTANTS.USAGE_LIMIT_POLICY_ADDRESS,
    address: GLOBAL_CONSTANTS.USAGE_LIMIT_POLICY_ADDRESS,
    initData: encodePacked(["uint128"], [params.limit])
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/value-limit-policy/installation.js
var getValueLimitPolicy = (params) => {
  return {
    policy: GLOBAL_CONSTANTS.VALUE_LIMIT_POLICY_ADDRESS,
    address: GLOBAL_CONSTANTS.VALUE_LIMIT_POLICY_ADDRESS,
    initData: encodeAbiParameters([{ type: "uint256" }], [params.limit])
  };
};

// node_modules/@rhinestone/module-sdk/_esm/module/smart-sessions/policies/universal-action-policy/types.js
var ParamCondition;
(function(ParamCondition2) {
  ParamCondition2[ParamCondition2["EQUAL"] = 0] = "EQUAL";
  ParamCondition2[ParamCondition2["GREATER_THAN"] = 1] = "GREATER_THAN";
  ParamCondition2[ParamCondition2["LESS_THAN"] = 2] = "LESS_THAN";
  ParamCondition2[ParamCondition2["GREATER_THAN_OR_EQUAL"] = 3] = "GREATER_THAN_OR_EQUAL";
  ParamCondition2[ParamCondition2["LESS_THAN_OR_EQUAL"] = 4] = "LESS_THAN_OR_EQUAL";
  ParamCondition2[ParamCondition2["NOT_EQUAL"] = 5] = "NOT_EQUAL";
  ParamCondition2[ParamCondition2["IN_RANGE"] = 6] = "IN_RANGE";
})(ParamCondition || (ParamCondition = {}));

// node_modules/@rhinestone/module-sdk/_esm/module/registry/constants.js
var RHINESTONE_ATTESTER_ADDRESS = "0x000000333034E9f539ce08819E12c1b8Cb29084d";

// node_modules/@rhinestone/module-sdk/_esm/module/zk-email-recovery/universal-email-recovery/constants.js
var MINIMUM_RECOVERY_WINDOW = 2 * 24 * 60 * 60;
var CANCEL_EXPIRED_RECOVERY_COOLDOWN = 24 * 60 * 60;

// node_modules/permissionless/_esm/actions/erc7579/accountId.js
async function accountId(client, args) {
  let account_ = client.account;
  if (args) {
    account_ = args.account;
  }
  if (!account_) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = account_;
  const publicClient = account.client;
  const abi16 = [
    {
      name: "accountId",
      type: "function",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          type: "string",
          name: "accountImplementationId"
        }
      ]
    }
  ];
  try {
    return await getAction(publicClient, readContract, "readContract")({
      abi: abi16,
      functionName: "accountId",
      address: await account.getAddress()
    });
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError) {
      const { factory, factoryData } = await account.getFactoryArgs();
      const result = await getAction(publicClient, call, "call")({
        factory,
        factoryData,
        to: account.address,
        data: encodeFunctionData({
          abi: abi16,
          functionName: "accountId"
        })
      });
      if (!result || !result.data) {
        throw new Error("accountId result is empty");
      }
      return decodeFunctionResult({
        abi: abi16,
        functionName: "accountId",
        data: result.data
      });
    }
    throw error;
  }
}

// node_modules/permissionless/_esm/actions/erc7579/installModule.js
function installModule6(client, parameters) {
  const { account: account_ = client.account, maxFeePerGas, maxPriorityFeePerGas, nonce, address, context, initData, type, calls, paymaster, authorization, paymasterContext } = parameters;
  if (!account_) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  return getAction(client, sendUserOperation, "sendUserOperation")({
    calls: [
      ...encodeInstallModule({
        account,
        modules: [{ address, context: context ?? initData, type }]
      }),
      ...calls ?? []
    ],
    paymaster,
    paymasterContext,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    authorization,
    account
  });
}

// node_modules/permissionless/_esm/actions/erc7579/installModules.js
async function installModules(client, parameters) {
  const { account: account_ = client.account, maxFeePerGas, maxPriorityFeePerGas, nonce, modules, paymaster, paymasterContext, authorization, calls } = parameters;
  if (!account_) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  return getAction(client, sendUserOperation, "sendUserOperation")({
    calls: [
      ...encodeInstallModule({
        account,
        modules
      }),
      ...calls ?? []
    ],
    paymaster,
    paymasterContext,
    maxFeePerGas,
    maxPriorityFeePerGas,
    authorization,
    nonce,
    account
  });
}

// node_modules/permissionless/_esm/actions/erc7579/isModuleInstalled.js
async function isModuleInstalled6(client, parameters) {
  const { account: account_ = client.account, address, context, additionalContext } = parameters;
  if (!account_) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account.client;
  const abi16 = [
    {
      type: "function",
      name: "isModuleInstalled",
      inputs: [
        {
          name: "moduleType",
          type: "uint256",
          internalType: "uint256"
        },
        { name: "module", type: "address", internalType: "address" },
        {
          name: "additionalContext",
          type: "bytes",
          internalType: "bytes"
        }
      ],
      outputs: [{ name: "", type: "bool", internalType: "bool" }],
      stateMutability: "view"
    }
  ];
  try {
    return await getAction(publicClient, readContract, "readContract")({
      abi: abi16,
      functionName: "isModuleInstalled",
      args: [
        parseModuleTypeId(parameters.type),
        getAddress(address),
        context ?? additionalContext
      ],
      address: account.address
    });
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError) {
      const { factory, factoryData } = await account.getFactoryArgs();
      const result = await getAction(publicClient, call, "call")({
        factory,
        factoryData,
        to: account.address,
        data: encodeFunctionData({
          abi: abi16,
          functionName: "isModuleInstalled",
          args: [
            parseModuleTypeId(parameters.type),
            getAddress(address),
            context ?? additionalContext
          ]
        })
      });
      if (!result || !result.data) {
        throw new Error("accountId result is empty");
      }
      return decodeFunctionResult({
        abi: abi16,
        functionName: "isModuleInstalled",
        data: result.data
      });
    }
    throw error;
  }
}

// node_modules/permissionless/_esm/utils/encodeUninstallModule.js
function encodeUninstallModule(parameters) {
  const account = parameters.account;
  if (!account) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const modules = Array.isArray(parameters.modules) ? parameters.modules : [parameters.modules];
  return modules.map(({ type, address, context, deInitData }) => ({
    to: account.address,
    value: BigInt(0),
    data: encodeFunctionData({
      abi: [
        {
          type: "function",
          name: "uninstallModule",
          inputs: [
            {
              name: "moduleType",
              type: "uint256",
              internalType: "uint256"
            },
            {
              name: "module",
              type: "address",
              internalType: "address"
            },
            {
              name: "deInitData",
              type: "bytes",
              internalType: "bytes"
            }
          ],
          outputs: [],
          stateMutability: "nonpayable"
        }
      ],
      functionName: "uninstallModule",
      args: [
        parseModuleTypeId(type),
        getAddress(address),
        context ?? deInitData
      ]
    })
  }));
}

// node_modules/permissionless/_esm/actions/erc7579/uninstallModule.js
async function uninstallModule6(client, parameters) {
  const { account: account_ = client.account, maxFeePerGas, maxPriorityFeePerGas, nonce, address, context, deInitData, type, calls, paymaster, paymasterContext } = parameters;
  if (!account_) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  return getAction(client, sendUserOperation, "sendUserOperation")({
    calls: [
      ...encodeUninstallModule({
        account,
        modules: [{ type, address, context: context ?? deInitData }]
      }),
      ...calls ?? []
    ],
    paymaster,
    paymasterContext,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    account
  });
}

// node_modules/permissionless/_esm/actions/erc7579/uninstallModules.js
async function uninstallModules(client, parameters) {
  const { account: account_ = client.account, maxFeePerGas, maxPriorityFeePerGas, nonce, modules, calls, paymaster, paymasterContext } = parameters;
  if (!account_) {
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  return getAction(client, sendUserOperation, "sendUserOperation")({
    calls: [
      ...encodeUninstallModule({
        account,
        modules
      }),
      ...calls ?? []
    ],
    paymaster,
    paymasterContext,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    account
  });
}

// node_modules/permissionless/_esm/actions/erc7579.js
function erc7579Actions() {
  return (client) => ({
    accountId: (args) => accountId(client, args),
    installModule: (args) => installModule6(client, args),
    installModules: (args) => installModules(client, args),
    isModuleInstalled: (args) => isModuleInstalled6(client, args),
    supportsExecutionMode: (args) => supportsExecutionMode(client, args),
    supportsModule: (args) => supportsModule(client, args),
    uninstallModule: (args) => uninstallModule6(client, args),
    uninstallModules: (args) => uninstallModules(client, args)
  });
}

// node_modules/@graphprotocol/hypergraph/dist/connect/abis/MainVotingPlugin.json
var MainVotingPlugin_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "AlreadyAMember",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "AlreadyAnEditor",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "AlreadyNotAMember",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "AlreadyNotAnEditor",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "limit",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "actual",
        type: "uint64"
      }
    ],
    name: "DateOutOfBounds",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "limit",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "actual",
        type: "uint64"
      }
    ],
    name: "DurationOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "EmptyContent",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "InvalidAddresslistUpdate",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "InvalidInterface",
    type: "error"
  },
  {
    inputs: [],
    name: "NoEditorsLeft",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "NotAMember",
    type: "error"
  },
  {
    inputs: [],
    name: "NotAnEditor",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyCreatorCanCancel",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "OnlyOneEditorPerCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ProposalCreationForbidden",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecutionForbidden",
    type: "error"
  },
  {
    inputs: [],
    name: "ProposalIsNotOpen",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "limit",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "actual",
        type: "uint256"
      }
    ],
    name: "RatioOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "voteOption",
        type: "uint8"
      }
    ],
    name: "VoteCastForbidden",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "subspace",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "AcceptSubspaceProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "editor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "AddEditorProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "AdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beacon",
        type: "address"
      }
    ],
    name: "BeaconUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "editors",
        type: "address[]"
      }
    ],
    name: "EditorsAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "string",
        name: "contentUri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "PublishEditsProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "editor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveEditorProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "member",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveMemberProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "subspace",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveSubspaceProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "voter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum IMajorityVoting.VoteOption",
        name: "voteOption",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "votingPower",
        type: "uint256"
      }
    ],
    name: "VoteCast",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "enum MajorityVotingBase.VotingMode",
        name: "votingMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "supportThreshold",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "duration",
        type: "uint64"
      }
    ],
    name: "VotingSettingsUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "UPDATE_ADDRESSES_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPDATE_VOTING_SETTINGS_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_PLUGIN_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "addEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "addMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "addresslistLength",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "addresslistLengthAtBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "canExecute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      }
    ],
    name: "canVote",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "cancelProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "_actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "_allowFailureMap",
        type: "uint256"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "_tryEarlyExecution",
        type: "bool"
      }
    ],
    name: "createProposal",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "duration",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "getProposal",
    outputs: [
      {
        internalType: "bool",
        name: "open",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "executed",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "startDate",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endDate",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "snapshotBlock",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.ProposalParameters",
        name: "parameters",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "abstain",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "yes",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "no",
            type: "uint256"
          }
        ],
        internalType: "struct MajorityVotingBase.Tally",
        name: "tally",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      }
    ],
    name: "getVoteOption",
    outputs: [
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "duration",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.VotingSettings",
        name: "_votingSettings",
        type: "tuple"
      },
      {
        internalType: "address[]",
        name: "_initialEditors",
        type: "address[]"
      },
      {
        internalType: "contract MemberAccessPlugin",
        name: "_memberAccessPlugin",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isEditor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isListed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "isListedAtBlock",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isMinParticipationReached",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isSupportThresholdReached",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isSupportThresholdReachedEarly",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpaceAsEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "memberAccessPlugin",
    outputs: [
      {
        internalType: "contract MemberAccessPlugin",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeAcceptSubspace",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_proposedEditor",
        type: "address"
      }
    ],
    name: "proposeAddEditor",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_proposedMember",
        type: "address"
      }
    ],
    name: "proposeAddMember",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "string",
        name: "_editsContentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeEdits",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "proposeRemoveEditor",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "proposeRemoveMember",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeRemoveSubspace",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "removeEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "removeMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "supportThreshold",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "totalVotingPower",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "duration",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.VotingSettings",
        name: "_votingSettings",
        type: "tuple"
      }
    ],
    name: "updateVotingSettings",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "upgradeTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "_tryEarlyExecution",
        type: "bool"
      }
    ],
    name: "vote",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "votingMode",
    outputs: [
      {
        internalType: "enum MajorityVotingBase.VotingMode",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@graphprotocol/hypergraph/dist/connect/abis/PersonalSpaceAdminPlugin.json
var PersonalSpaceAdminPlugin_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "NotAMember",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "editors",
        type: "address[]"
      }
    ],
    name: "EditorsAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "_actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "_allowFailureMap",
        type: "uint256"
      }
    ],
    name: "executeProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialEditor",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isEditor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitAcceptSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_contentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitEdits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newEditor",
        type: "address"
      }
    ],
    name: "submitNewEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newMember",
        type: "address"
      }
    ],
    name: "submitNewMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "submitRemoveEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "submitRemoveMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitRemoveSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@graphprotocol/hypergraph/dist/connect/abis.js
var safeModuleManagerAbi = [{
  inputs: [{
    internalType: "address",
    name: "module",
    type: "address"
  }],
  name: "enableModule",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "module",
    type: "address"
  }],
  name: "disableModule",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var safeOwnerManagerAbi = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "uint256",
    name: "threshold",
    type: "uint256"
  }],
  name: "addOwnerWithThreshold",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "isOwner",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}];
var smartSessionsAbi = [{
  inputs: [{
    internalType: "PermissionId",
    name: "permissionId",
    type: "bytes32"
  }],
  name: "revokeEnableSignature",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];
var safe7579Abi = [{
  type: "function",
  name: "isModuleInstalled",
  inputs: [{
    name: "moduleType",
    type: "uint256",
    internalType: "uint256"
  }, {
    name: "module",
    type: "address",
    internalType: "address"
  }, {
    name: "additionalContext",
    type: "bytes",
    internalType: "bytes"
  }],
  outputs: [{
    name: "",
    type: "bool",
    internalType: "bool"
  }],
  stateMutability: "view"
}];
var daoFactoryAbi = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "trustedForwarder",
      type: "address"
    }, {
      internalType: "string",
      name: "daoURI",
      type: "string"
    }, {
      internalType: "string",
      name: "subdomain",
      type: "string"
    }, {
      internalType: "bytes",
      name: "metadata",
      type: "bytes"
    }],
    internalType: "struct DAOFactory.DAOSettings",
    name: "_daoSettings",
    type: "tuple"
  }, {
    components: [{
      components: [{
        components: [{
          internalType: "uint8",
          name: "release",
          type: "uint8"
        }, {
          internalType: "uint16",
          name: "build",
          type: "uint16"
        }],
        internalType: "struct PluginRepo.Tag",
        name: "versionTag",
        type: "tuple"
      }, {
        internalType: "contract PluginRepo",
        name: "pluginSetupRepo",
        type: "address"
      }],
      internalType: "struct PluginSetupRef",
      name: "pluginSetupRef",
      type: "tuple"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct DAOFactory.PluginSettings[]",
    name: "_pluginSettings",
    type: "tuple[]"
  }],
  name: "createDao",
  outputs: [{
    internalType: "contract DAO",
    name: "createdDao",
    type: "address"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];

// node_modules/@graphprotocol/hypergraph/dist/connect/smart-account.js
var DEFAULT_RPC_URL = "https://rpc-geo-genesis-h0q2s21xx8.t.conduit.xyz";
var TESTNET_RPC_URL = "https://rpc-geo-test-zc16z3tcvf.t.conduit.xyz";
var DEFAULT_API_KEY = "pim_KqHm63txxhbCYjdDaWaHqH";
var BUNDLER_TRANSPORT_URL_BASE = "https://api.pimlico.io/v2/";
var SAFE_7579_MODULE_ADDRESS = "0x7579EE8307284F293B1927136486880611F20002";
var SAFE_4337_MODULE_ADDRESS = "0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226";
var ERC7579_LAUNCHPAD_ADDRESS = "0x7579011aB74c46090561ea277Ba79D510c6C00ff";
var SPACE_FACTORY_ADDRESS = {
  "80451": MAINNET.DAO_FACTORY_ADDRESS,
  "19411": TESTNET.DAO_FACTORY_ADDRESS
};
var MODULE_TYPE_VALIDATOR = 1;
var PUBLIC_SPACE_FUNCTIONS = ["leaveSpace", "leaveSpaceAsEditor", "createProposal", "proposeEdits", "proposeAcceptSubspace", "proposeRemoveSubspace", "proposeAddMember", "proposeRemoveMember", "proposeAddEditor", "proposeRemoveEditor", "cancelProposal", "vote", "execute"];
var PERSONAL_SPACE_FUNCTIONS = ["executeProposal", "submitEdits", "submitAcceptSubspace", "submitRemoveSubspace", "submitNewMember", "submitRemoveMember", "leaveSpace", "submitNewEditor", "submitRemoveEditor"];
var GEOGENESIS = {
  id: Number("80451"),
  name: "Geo Genesis",
  nativeCurrency: {
    name: "Graph Token",
    symbol: "GRT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [DEFAULT_RPC_URL]
    },
    public: {
      http: [DEFAULT_RPC_URL]
    }
  }
};
var GEO_TESTNET = {
  id: Number("19411"),
  name: "Geo Testnet",
  nativeCurrency: {
    name: "Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [TESTNET_RPC_URL]
    },
    public: {
      http: [TESTNET_RPC_URL]
    }
  }
};
var getLegacySmartAccountWalletClient = async ({
  owner,
  address,
  chain = GEOGENESIS,
  rpcUrl = DEFAULT_RPC_URL,
  apiKey = DEFAULT_API_KEY
}) => {
  const transport = http(rpcUrl);
  const publicClient = createPublicClient({
    transport,
    chain
  });
  const safeAccountParams = {
    client: publicClient,
    owners: [owner],
    entryPoint: {
      address: entryPoint07Address,
      version: "0.7"
    },
    version: "1.4.1"
  };
  if (address) {
    safeAccountParams.address = address;
  }
  if (chain.id === GEO_TESTNET.id) {
    safeAccountParams.safeModuleSetupAddress = "0x2dd68b007B46fBe91B9A7c3EDa5A7a1063cB5b47";
    safeAccountParams.safe4337ModuleAddress = "0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226";
    safeAccountParams.safeProxyFactoryAddress = "0xd9d2Ba03a7754250FDD71333F444636471CACBC4";
    safeAccountParams.safeSingletonAddress = "0x639245e8476E03e789a244f279b5843b9633b2E7";
    safeAccountParams.multiSendAddress = "0x7B21BBDBdE8D01Df591fdc2dc0bE9956Dde1e16C";
    safeAccountParams.multiSendCallOnlyAddress = "0x32228dDEA8b9A2bd7f2d71A958fF241D79ca5eEC";
  }
  const safeAccount = await toSafeSmartAccount(safeAccountParams);
  const bundlerTransport = http(`${BUNDLER_TRANSPORT_URL_BASE}${chain.id}/rpc?apikey=${apiKey}`);
  const paymasterClient = createPimlicoClient({
    transport: bundlerTransport,
    chain,
    entryPoint: {
      address: entryPoint07Address,
      version: "0.7"
    }
  });
  const smartAccountClient = createSmartAccountClient({
    chain,
    account: safeAccount,
    paymaster: paymasterClient,
    bundlerTransport,
    userOperation: {
      estimateFeesPerGas: async () => {
        return (await paymasterClient.getUserOperationGasPrice()).fast;
      }
    }
  });
  return smartAccountClient;
};
var get7579SmartAccountWalletClient = async ({
  owner,
  address,
  chain = GEOGENESIS,
  rpcUrl = DEFAULT_RPC_URL,
  apiKey = DEFAULT_API_KEY
}) => {
  var _a;
  const transport = http(rpcUrl);
  const publicClient = createPublicClient({
    transport,
    chain
  });
  console.log("owner", owner);
  console.log("chain", chain);
  console.log("rpcUrl", rpcUrl);
  console.log("apiKey", apiKey);
  console.log("address", address);
  const ownerAddress = "account" in owner ? (_a = owner.account) == null ? void 0 : _a.address : owner.address;
  if (!ownerAddress) {
    throw new Error("Owner address not found");
  }
  const ownableValidator = getOwnableValidator({
    owners: [ownerAddress],
    threshold: 1
  });
  const smartSessionsValidator = getSmartSessionsValidator({});
  const safeAccountParams = {
    client: publicClient,
    owners: [owner],
    version: "1.4.1",
    entryPoint: {
      address: entryPoint07Address,
      version: "0.7"
    },
    safe4337ModuleAddress: SAFE_7579_MODULE_ADDRESS,
    erc7579LaunchpadAddress: ERC7579_LAUNCHPAD_ADDRESS,
    attesters: [
      RHINESTONE_ATTESTER_ADDRESS
      // Rhinestone Attester
    ],
    attestersThreshold: 1,
    validators: [{
      address: ownableValidator.address,
      context: ownableValidator.initData
    }, {
      address: smartSessionsValidator.address,
      context: smartSessionsValidator.initData
    }]
  };
  if (address) {
    safeAccountParams.address = address;
  }
  const safeAccount = await toSafeSmartAccount(safeAccountParams);
  const bundlerTransport = http(`${BUNDLER_TRANSPORT_URL_BASE}${chain.id}/rpc?apikey=${apiKey}`);
  const paymasterClient = createPimlicoClient({
    transport: bundlerTransport,
    chain,
    entryPoint: {
      address: entryPoint07Address,
      version: "0.7"
    }
  });
  const smartAccountClient = createSmartAccountClient({
    chain,
    account: safeAccount,
    paymaster: paymasterClient,
    bundlerTransport,
    userOperation: {
      estimateFeesPerGas: async () => {
        return (await paymasterClient.getUserOperationGasPrice()).fast;
      }
    }
  }).extend(erc7579Actions());
  return smartAccountClient;
};
var isSmartAccountDeployed = async (smartAccountClient) => {
  if (!smartAccountClient.account) {
    throw new Error("Invalid smart account");
  }
  return smartAccountClient.account.isDeployed();
};
var getSmartAccountWalletClient = async ({
  owner,
  address,
  chain = GEOGENESIS,
  rpcUrl = DEFAULT_RPC_URL,
  apiKey = DEFAULT_API_KEY
}) => {
  if (chain.id === GEO_TESTNET.id) {
    const params = {
      owner,
      chain,
      rpcUrl,
      apiKey
    };
    if (address) {
      params.address = address;
    }
    console.log("on testnet, getting legacy smart account wallet client");
    return getLegacySmartAccountWalletClient(params);
  }
  if (address) {
    return get7579SmartAccountWalletClient({
      owner,
      address,
      chain,
      rpcUrl,
      apiKey
    });
  }
  const legacyClient = await getLegacySmartAccountWalletClient({
    owner,
    chain,
    rpcUrl,
    apiKey
  });
  if (await isSmartAccountDeployed(legacyClient)) {
    return legacyClient;
  }
  return get7579SmartAccountWalletClient({
    owner,
    chain,
    rpcUrl,
    apiKey
  });
};
var legacySmartAccountUpdateStatus = async (smartAccountClient, chain, rpcUrl) => {
  if (!smartAccountClient.account) {
    throw new Error("Invalid smart account");
  }
  const transport = http(rpcUrl);
  const publicClient = createPublicClient({
    transport,
    chain
  });
  const smartSessionsValidator = getSmartSessionsValidator({});
  let isSmartSessionsValidatorInstalled = false;
  try {
    isSmartSessionsValidatorInstalled = await publicClient.readContract({
      abi: safe7579Abi,
      address: smartAccountClient.account.address,
      functionName: "isModuleInstalled",
      args: [MODULE_TYPE_VALIDATOR, smartSessionsValidator.address, "0x"]
    });
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError && error.details.includes("execution reverted")) {
      return {
        has7579Module: false,
        hasSmartSessionsValidator: false,
        hasOwnableValidator: false
      };
    }
    throw error;
  }
  const ownableValidator = getOwnableValidator({
    owners: [smartAccountClient.account.address],
    threshold: 1
  });
  const isOwnableValidatorInstalled = await publicClient.readContract({
    abi: safe7579Abi,
    address: smartAccountClient.account.address,
    functionName: "isModuleInstalled",
    args: [MODULE_TYPE_VALIDATOR, ownableValidator.address, "0x"]
  });
  return {
    has7579Module: true,
    hasSmartSessionsValidator: isSmartSessionsValidatorInstalled,
    hasOwnableValidator: isOwnableValidatorInstalled
  };
};
var smartAccountNeedsUpdate = async (smartAccountClient, chain, rpcUrl) => {
  if (chain.id === GEO_TESTNET.id) {
    return false;
  }
  if (!await isSmartAccountDeployed(smartAccountClient)) {
    return false;
  }
  const updateStatus = await legacySmartAccountUpdateStatus(smartAccountClient, chain, rpcUrl);
  return !updateStatus.has7579Module || !updateStatus.hasSmartSessionsValidator || !updateStatus.hasOwnableValidator;
};
var updateLegacySmartAccount = async (smartAccountClient, chain, rpcUrl) => {
  var _a;
  if (!((_a = smartAccountClient.account) == null ? void 0 : _a.address)) {
    throw new Error("Invalid smart account");
  }
  if (chain.id === GEO_TESTNET.id) {
    console.log("on testnet, skipping updateLegacySmartAccount");
    return;
  }
  const ownableValidator = getOwnableValidator({
    owners: [smartAccountClient.account.address],
    threshold: 1
  });
  const smartSessionsValidator = getSmartSessionsValidator({});
  const installValidatorsTx = encodeInstallModule({
    account: smartAccountClient.account,
    modules: [{
      type: ownableValidator.type,
      address: ownableValidator.address,
      context: ownableValidator.initData
    }, {
      type: smartSessionsValidator.type,
      address: smartSessionsValidator.address,
      context: smartSessionsValidator.initData
    }]
  });
  const updateStatus = await legacySmartAccountUpdateStatus(smartAccountClient, chain, rpcUrl);
  const calls = [];
  if (!updateStatus.has7579Module) {
    calls.push({
      to: smartAccountClient.account.address,
      data: encodeFunctionData({
        abi: safeModuleManagerAbi,
        functionName: "enableModule",
        args: [SAFE_7579_MODULE_ADDRESS]
      }),
      value: BigInt(0)
    });
    calls.push({
      to: smartAccountClient.account.address,
      data: encodeFunctionData({
        abi: safeModuleManagerAbi,
        functionName: "setFallbackHandler",
        args: [SAFE_7579_MODULE_ADDRESS]
      }),
      value: BigInt(0)
    });
    calls.push({
      to: smartAccountClient.account.address,
      data: encodeFunctionData({
        abi: safeModuleManagerAbi,
        functionName: "disableModule",
        args: [SAFE_4337_MODULE_ADDRESS]
      }),
      value: BigInt(0)
    });
  }
  if (!updateStatus.hasOwnableValidator) {
    calls.push({
      to: installValidatorsTx[0].to,
      data: installValidatorsTx[0].data,
      value: installValidatorsTx[0].value
    });
  }
  if (!updateStatus.hasSmartSessionsValidator) {
    calls.push({
      to: installValidatorsTx[1].to,
      data: installValidatorsTx[1].data,
      value: installValidatorsTx[1].value
    });
  }
  if (calls.length === 0) {
    return;
  }
  const tx = await smartAccountClient.sendUserOperation({
    calls
  });
  const receipt = await smartAccountClient.waitForUserOperationReceipt({
    hash: tx
  });
  if (!receipt.success) {
    throw new Error("Transaction to update legacy smart account failed");
  }
  return receipt;
};
var getSpaceActions = (space) => {
  const actions = [];
  if (space.type === "public") {
    for (const functionName of PUBLIC_SPACE_FUNCTIONS) {
      actions.push({
        actionTarget: space.address,
        actionTargetSelector: toFunctionSelector(getAbiItem({
          abi: MainVotingPlugin_default,
          name: functionName
        })),
        actionPolicies: [getSudoPolicy()]
      });
    }
  } else {
    for (const functionName of PERSONAL_SPACE_FUNCTIONS) {
      actions.push({
        actionTarget: space.address,
        actionTargetSelector: toFunctionSelector(getAbiItem({
          abi: PersonalSpaceAdminPlugin_default,
          name: functionName
        })),
        actionPolicies: [getSudoPolicy()]
      });
    }
  }
  return actions;
};
var addSmartAccountOwner = async (smartAccountClient, newOwner, chain, rpcUrl) => {
  if (!smartAccountClient.account) {
    throw new Error("Invalid smart account");
  }
  const publicClient = createPublicClient({
    transport: http(rpcUrl),
    chain
  });
  if (await isSmartAccountDeployed(smartAccountClient)) {
    const isOwner = await publicClient.readContract({
      abi: safeOwnerManagerAbi,
      address: smartAccountClient.account.address,
      functionName: "isOwner",
      args: [newOwner]
    });
    if (isOwner) {
      return;
    }
  }
  const tx = await smartAccountClient.sendUserOperation({
    calls: [{
      to: smartAccountClient.account.address,
      data: encodeFunctionData({
        abi: safeOwnerManagerAbi,
        functionName: "addOwnerWithThreshold",
        args: [newOwner, BigInt(1)]
      }),
      value: BigInt(0)
    }],
    account: smartAccountClient.account
  });
  const receipt = await smartAccountClient.waitForUserOperationReceipt({
    hash: tx
  });
  if (!receipt.success) {
    throw new Error("Transaction to add smart account owner failed");
  }
  return receipt;
};
var createSmartSession = async (owner, accountAddress, sessionPrivateKey, chain, rpcUrl, {
  allowCreateSpace = false,
  spaces = [],
  additionalActions = []
} = {}) => {
  var _a;
  const smartAccountClient = await getSmartAccountWalletClient({
    owner,
    address: accountAddress,
    chain,
    rpcUrl
  });
  if (!smartAccountClient.account) {
    throw new Error("Invalid wallet client");
  }
  if (!smartAccountClient.account.isDeployed()) {
    throw new Error("Smart account must be deployed");
  }
  if (await smartAccountNeedsUpdate(smartAccountClient, chain, rpcUrl)) {
    throw new Error("Smart account needs to be updated");
  }
  if (!smartAccountClient.chain) {
    throw new Error("Invalid smart account chain");
  }
  const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey);
  const transport = http(rpcUrl);
  const publicClient = createPublicClient({
    transport,
    chain
  });
  if (chain.id === GEO_TESTNET.id) {
    console.log("on testnet, faking a smart session by adding an account owner");
    const tx = await smartAccountClient.sendUserOperation({
      calls: [{
        to: smartAccountClient.account.address,
        data: encodeFunctionData({
          abi: safeOwnerManagerAbi,
          functionName: "addOwnerWithThreshold",
          args: [sessionKeyAccount.address, BigInt(1)]
        }),
        value: BigInt(0)
      }],
      account: smartAccountClient.account
    });
    const receipt2 = await smartAccountClient.waitForUserOperationReceipt({
      hash: tx
    });
    if (!receipt2.success) {
      throw new Error("Transaction to add account owner failed");
    }
    console.log("account owner added");
    return bytesToHex4(randomBytes(32));
  }
  console.log("creating noOpActionPolicy");
  const noOpActionPolicy = getUniversalActionPolicy({
    paramRules: {
      length: BigInt(1),
      // @ts-expect-error - The Rhinestone SDK doesn't export the types we need here
      rules: new Array(16).fill({
        condition: BigInt(0),
        // ParamCondition.EQUAL
        isLimited: false,
        offset: BigInt(0),
        ref: toHex(toBytes3("0x", {
          size: 32
        })),
        usage: {
          limit: BigInt(0),
          used: BigInt(0)
        }
      })
    },
    valueLimitPerUse: BigInt(0)
  });
  console.log("noOpActionPolicy created");
  const actions = [{
    actionTarget: sessionKeyAccount.address,
    actionTargetSelector: toFunctionSelector(getAbiItem({
      abi: smartSessionsAbi,
      name: "revokeEnableSignature"
    })),
    actionPolicies: [noOpActionPolicy]
  }];
  console.log("getting space actions");
  for (const space of spaces) {
    actions.push(...getSpaceActions(space));
  }
  console.log("space actions created");
  if (allowCreateSpace) {
    const spaceFactoryAddress = SPACE_FACTORY_ADDRESS[chain.id.toString()];
    actions.push({
      actionTarget: spaceFactoryAddress,
      actionTargetSelector: toFunctionSelector(getAbiItem({
        abi: daoFactoryAbi,
        name: "createDao"
      })),
      actionPolicies: [getSudoPolicy()]
    });
  }
  if (additionalActions) {
    actions.push(...additionalActions);
  }
  console.log("actions created");
  const session = {
    sessionValidator: OWNABLE_VALIDATOR_ADDRESS2,
    sessionValidatorInitData: encodeValidationData({
      threshold: 1,
      owners: [sessionKeyAccount.address]
    }),
    salt: bytesToHex4(randomBytes(32)),
    userOpPolicies: [getSudoPolicy()],
    erc7739Policies: {
      allowedERC7739Content: [],
      erc1271Policies: []
    },
    actions,
    chainId: BigInt(smartAccountClient.chain.id),
    permitERC4337Paymaster: true
  };
  const account = getAccount({
    address: smartAccountClient.account.address,
    type: "safe"
  });
  console.log("session object");
  const sessionDetails = await getEnableSessionDetails({
    // enableMode: SmartSessionMode.ENABLE,
    sessions: [session],
    account,
    clients: [publicClient]
    // ignoreSecurityAttestations: true,
  });
  console.log("signing session details");
  sessionDetails.enableSessionData.enableSession.permissionEnableSig = await owner.signMessage({
    message: {
      raw: sessionDetails.permissionEnableHash
    },
    account: ((_a = owner.account) == null ? void 0 : _a.address) ?? owner.address
  });
  console.log("session details signed");
  const smartSessions = getSmartSessionsValidator({});
  const nonce = await getAccountNonce(publicClient, {
    address: smartAccountClient.account.address,
    entryPointAddress: entryPoint07Address,
    key: encodeValidatorNonce5({
      account,
      validator: smartSessions
    })
  });
  console.log("nonce");
  sessionDetails.signature = getOwnableValidatorMockSignature({
    threshold: 1
  });
  console.log("prep user op");
  const userOperation = await smartAccountClient.prepareUserOperation({
    account: smartAccountClient.account,
    calls: [{
      // We use the revokeEnableSignature with permissionId 0 function to create a noop action
      to: sessionKeyAccount.address,
      value: BigInt(0),
      data: encodeFunctionData({
        abi: smartSessionsAbi,
        functionName: "revokeEnableSignature",
        args: [toHex(toBytes3("0x", {
          size: 32
        }))]
      })
    }],
    nonce,
    signature: encodeSmartSessionSignature(sessionDetails)
  });
  console.log("user operation prepared");
  const userOpHashToSign = getUserOperationHash({
    chainId: chain.id,
    entryPointAddress: entryPoint07Address,
    entryPointVersion: "0.7",
    userOperation
  });
  console.log("user op hash to sign");
  sessionDetails.signature = await sessionKeyAccount.signMessage({
    message: {
      raw: userOpHashToSign
    }
  });
  console.log("user op hash to sign signed");
  userOperation.signature = encodeSmartSessionSignature(sessionDetails);
  console.log("user op hash to sign encoded");
  const userOpHash = await smartAccountClient.sendUserOperation(userOperation);
  console.log("user op hash");
  const receipt = await smartAccountClient.waitForUserOperationReceipt({
    hash: userOpHash
  });
  if (!receipt.success) {
    throw new Error("Transaction to create smart session failed");
  }
  return getPermissionId({
    session
  });
};
var getSmartSessionClient = async ({
  accountAddress,
  chain = GEOGENESIS,
  rpcUrl = DEFAULT_RPC_URL,
  apiKey = DEFAULT_API_KEY,
  sessionPrivateKey,
  permissionId
}) => {
  const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey);
  const smartAccountClient = await getSmartAccountWalletClient({
    owner: sessionKeyAccount,
    // Won't really be used (except in testnet), but we need to pass in an account
    address: accountAddress,
    chain,
    rpcUrl,
    apiKey
  });
  if (!smartAccountClient.account) {
    throw new Error("Invalid smart account");
  }
  const smartSessions = getSmartSessionsValidator({});
  const publicClient = createPublicClient({
    transport: http(rpcUrl),
    chain
  });
  return {
    account: smartAccountClient.account,
    chain,
    sendUserOperation: async ({
      calls
    }) => {
      if (!smartAccountClient.account) {
        throw new Error("Invalid smart account");
      }
      if (chain.id === GEO_TESTNET.id) {
        return smartAccountClient.sendUserOperation({
          calls,
          account: smartAccountClient.account
        });
      }
      const account = getAccount({
        address: smartAccountClient.account.address,
        type: "safe"
      });
      const sessionDetails = {
        mode: SmartSessionMode.USE,
        permissionId,
        signature: getOwnableValidatorMockSignature({
          threshold: 1
        })
      };
      const nonce = await getAccountNonce(publicClient, {
        address: smartAccountClient.account.address,
        entryPointAddress: entryPoint07Address,
        key: encodeValidatorNonce5({
          account,
          validator: smartSessions
        })
      });
      const userOperation = await smartAccountClient.prepareUserOperation({
        account: smartAccountClient.account,
        calls,
        nonce,
        signature: encodeSmartSessionSignature(sessionDetails)
      });
      const userOpHashToSign = getUserOperationHash({
        chainId: chain.id,
        entryPointAddress: entryPoint07Address,
        entryPointVersion: "0.7",
        userOperation
      });
      sessionDetails.signature = await sessionKeyAccount.signMessage({
        message: {
          raw: userOpHashToSign
        }
      });
      userOperation.signature = encodeSmartSessionSignature(sessionDetails);
      return smartAccountClient.sendUserOperation(userOperation);
    },
    signMessage: async ({
      message
    }) => {
      return sessionKeyAccount.signMessage({
        message
      });
    },
    waitForUserOperationReceipt: async ({
      hash
    }) => {
      return smartAccountClient.waitForUserOperationReceipt({
        hash
      });
    }
  };
};

// node_modules/@graphprotocol/hypergraph/dist/connect/login.js
async function identityExists(accountAddress, syncServerUri) {
  const res = await fetch(new URL(`/identity?accountAddress=${accountAddress}`, syncServerUri), {
    method: "GET"
  });
  return res.status === 200;
}
async function signup(signer, walletClient, smartAccountClient, accountAddress, syncServerUri, addressStorage, keysStorage, identityToken, chain, rpcUrl) {
  const keys = createIdentityKeys();
  const {
    ciphertext,
    nonce
  } = await encryptIdentity(signer, keys);
  const localAccount = privateKeyToAccount(keys.signaturePrivateKey);
  await addSmartAccountOwner(smartAccountClient, localAccount.address, chain, rpcUrl);
  const localSmartAccountClient = await getSmartAccountWalletClient({
    owner: localAccount,
    address: accountAddress,
    rpcUrl,
    chain
  });
  const {
    accountProof,
    keyProof
  } = await proveIdentityOwnership(localSmartAccountClient, accountAddress, keys);
  const req = {
    keyBox: {
      signer: await signer.getAddress(),
      accountAddress,
      ciphertext,
      nonce
    },
    accountProof,
    keyProof,
    signaturePublicKey: keys.signaturePublicKey,
    encryptionPublicKey: keys.encryptionPublicKey
  };
  const res = await fetch(new URL("/connect/identity", syncServerUri), {
    method: "POST",
    headers: {
      "privy-id-token": identityToken,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(req)
  });
  if (res.status !== 200) {
    throw new Error(`Error creating identity: ${res.status}`);
  }
  const decoded = decodeUnknownSync(ResponseConnectCreateIdentity)(await res.json());
  if (!decoded.success) {
    throw new Error("Error creating identity");
  }
  storeKeys(keysStorage, accountAddress, keys);
  storeAccountAddress(addressStorage, accountAddress);
  return {
    accountAddress,
    keys
  };
}
async function restoreKeys(signer, accountAddress, syncServerUri, addressStorage, keysStorage, identityToken) {
  const res = await fetch(new URL("/connect/identity/encrypted", syncServerUri), {
    method: "GET",
    headers: {
      "privy-id-token": identityToken,
      "account-address": accountAddress,
      "Content-Type": "application/json"
    }
  });
  if (res.status === 200) {
    const decoded = decodeUnknownSync(ResponseIdentityEncrypted)(await res.json());
    const {
      keyBox
    } = decoded;
    const {
      ciphertext,
      nonce
    } = keyBox;
    const keys = await decryptIdentity(signer, ciphertext, nonce);
    storeKeys(keysStorage, accountAddress, keys);
    storeAccountAddress(addressStorage, accountAddress);
    return {
      accountAddress,
      keys
    };
  }
  throw new Error(`Error fetching identity ${res.status}`);
}
var getAndUpdateSmartAccount = async (walletClient, rpcUrl, chain, addressStorage) => {
  const accountAddressFromStorage = loadAccountAddress(addressStorage);
  const smartAccountParams = {
    owner: walletClient,
    rpcUrl,
    chain
  };
  if (accountAddressFromStorage) {
    smartAccountParams.address = accountAddressFromStorage;
  }
  const smartAccountWalletClient = await getSmartAccountWalletClient(smartAccountParams);
  if (!smartAccountWalletClient.account) {
    throw new Error("Smart account wallet client not found");
  }
  console.log("smartAccountWalletClient", smartAccountWalletClient);
  console.log("address", smartAccountWalletClient.account.address);
  console.log("is deployed", await isSmartAccountDeployed(smartAccountWalletClient));
  if (await smartAccountNeedsUpdate(smartAccountWalletClient, chain, rpcUrl)) {
    console.log("updating smart account");
    await updateLegacySmartAccount(smartAccountWalletClient, chain, rpcUrl);
    smartAccountParams.address = smartAccountWalletClient.account.address;
    return getSmartAccountWalletClient(smartAccountParams);
  }
  return smartAccountWalletClient;
};
async function login({
  walletClient,
  signer,
  syncServerUri,
  addressStorage,
  keysStorage,
  identityToken,
  rpcUrl,
  chain
}) {
  const smartAccountWalletClient = await getAndUpdateSmartAccount(walletClient, rpcUrl, chain, addressStorage);
  if (!smartAccountWalletClient.account) {
    throw new Error("Smart account wallet client account not found");
  }
  const accountAddress = smartAccountWalletClient.account.address;
  let authData;
  const exists = await identityExists(accountAddress, syncServerUri);
  if (!exists) {
    authData = await signup(signer, walletClient, smartAccountWalletClient, accountAddress, syncServerUri, addressStorage, keysStorage, identityToken, chain, rpcUrl);
  } else {
    authData = await restoreKeys(signer, accountAddress, syncServerUri, addressStorage, keysStorage, identityToken);
  }
  store.send({
    type: "reset"
  });
  store.send({
    ...authData,
    sessionToken: "dummy",
    // not needed in the connect app
    type: "setAuth"
  });
}

// node_modules/@graphprotocol/hypergraph/dist/connect/parse-auth-params.js
var decodePayload = decodeEither(ConnectAuthPayload);
var parseAuthParams = (params) => {
  const {
    data,
    redirect,
    nonce
  } = params;
  if (!data || !redirect || !nonce) {
    return fail(new FailedToParseConnectAuthUrl({
      message: "Missing data or redirect in callback URL"
    }));
  }
  if (nonce.length !== 64) {
    return fail(new FailedToParseConnectAuthUrl({
      message: "Invalid nonce"
    }));
  }
  try {
    const result = decodePayload(data);
    if (isLeft(result)) {
      return fail(new FailedToParseConnectAuthUrl({
        message: "Failed to parse connect auth payload"
      }));
    }
    return succeed({
      payload: result.right,
      redirect,
      nonce
    });
  } catch (error) {
    return fail(new FailedToParseConnectAuthUrl({
      message: "Failed to parse connect auth payload"
    }));
  }
};

// node_modules/@graphprotocol/hypergraph/dist/connect/parse-callback-params.js
var decodeDecryptedResult = decodeEither(ConnectCallbackDecryptedData);
var parseCallbackParams = ({
  ciphertext,
  nonce,
  storedNonce,
  storedExpiry,
  storedSecretKey,
  storedPublicKey
}) => {
  if (nonce !== storedNonce) {
    return fail(new FailedToParseAuthCallbackUrl({
      message: "Invalid nonce"
    }));
  }
  try {
    const publicKey = hexToBytes2(storedPublicKey);
    const decryptionResult = cryptoBoxSealOpen({
      ciphertext: hexToBytes2(ciphertext),
      privateKey: hexToBytes2(storedSecretKey),
      publicKey
    });
    const decoded = decodeDecryptedResult(JSON.parse(bytesToUtf8(decryptionResult)));
    if (isLeft(decoded)) {
      return fail(new FailedToParseAuthCallbackUrl({
        message: "Failed to parse connect auth callback payload"
      }));
    }
    const data = decoded.right;
    if (data.expiry !== storedExpiry) {
      return fail(new FailedToParseAuthCallbackUrl({
        message: "Incorrect expiry"
      }));
    }
    if (data.expiry < Date.now()) {
      return fail(new FailedToParseAuthCallbackUrl({
        message: "Expired nonce"
      }));
    }
    return succeed({
      appIdentityAddress: data.appIdentityAddress,
      appIdentityAddressPrivateKey: data.appIdentityAddressPrivateKey,
      accountAddress: data.accountAddress,
      permissionId: data.permissionId,
      signaturePublicKey: data.signaturePublicKey,
      signaturePrivateKey: data.signaturePrivateKey,
      encryptionPublicKey: data.encryptionPublicKey,
      encryptionPrivateKey: data.encryptionPrivateKey,
      sessionToken: data.sessionToken,
      sessionTokenExpires: new Date(data.sessionTokenExpires),
      privateSpaces: data.privateSpaces,
      publicSpaces: data.publicSpaces
    });
  } catch (error) {
    console.error(error);
    return fail(new FailedToParseAuthCallbackUrl({
      message: "Failed to parse connect auth callback payload"
    }));
  }
};

// node_modules/@graphprotocol/hypergraph/dist/entity/index.js
var entity_exports = {};
__export(entity_exports, {
  Class: () => Class2,
  EntityNotFoundError: () => EntityNotFoundError,
  Field: () => Field3,
  create: () => create,
  delete: () => delete$,
  findMany: () => findMany,
  findOne: () => findOne,
  markAsDeleted: () => markAsDeleted,
  removeRelation: () => removeRelation,
  subscribeToFindMany: () => subscribeToFindMany,
  update: () => update
});

// node_modules/@graphprotocol/hypergraph/dist/entity/hasValidTypesProperty.js
var hasValidTypesProperty = (value) => {
  return value !== null && typeof value === "object" && "@@types@@" in value && Array.isArray(value["@@types@@"]);
};

// node_modules/@graphprotocol/hypergraph/dist/entity/getEntityRelations.js
var getEntityRelations = (entityId, type, doc, include) => {
  var _a;
  const relations = {};
  for (const [fieldName, field] of Object.entries(type.fields)) {
    if (!isRelationField(field)) continue;
    if (!(include == null ? void 0 : include[fieldName])) {
      relations[fieldName] = [];
      continue;
    }
    const relationEntities = [];
    for (const [relationId, relation] of Object.entries(doc.relations ?? {})) {
      const typeName = type.name;
      if (relation.fromTypeName !== typeName || relation.fromPropertyName !== fieldName || relation.from !== entityId) continue;
      if (relation.__deleted) continue;
      const relationEntity = (_a = doc.entities) == null ? void 0 : _a[relation.to];
      if (!hasValidTypesProperty(relationEntity)) continue;
      relationEntities.push({
        ...relationEntity,
        id: relation.to,
        _relation: {
          id: relationId
        }
      });
    }
    relations[fieldName] = relationEntities;
  }
  return relations;
};

// node_modules/@graphprotocol/hypergraph/dist/entity/findOne.js
var findOne = (handle, type, include = {}) => {
  const decode = decodeUnknownSync(type);
  const typeName = type.name;
  return (id) => {
    var _a;
    const doc = handle.doc();
    const entity = (_a = doc == null ? void 0 : doc.entities) == null ? void 0 : _a[id];
    const relations = doc ? getEntityRelations(id, type, doc, include) : {};
    if (hasValidTypesProperty(entity) && entity["@@types@@"].includes(typeName)) {
      const decoded = {
        ...decode({
          ...entity,
          id,
          ...relations
        }),
        type: typeName
      };
      decoded.__schema = type;
      return decoded;
    }
    return void 0;
  };
};

// node_modules/@graphprotocol/hypergraph/dist/entity/create.js
var create = (handle, type) => {
  const typeName = type.name;
  const encode = encodeSync(type.insert);
  return (data) => {
    const entityId = generateId();
    const encoded = encode(data);
    const relations = {};
    for (const [propertyName, field] of Object.entries(type.fields)) {
      if (isRelationField(field) && encoded[propertyName]) {
        for (const toEntityId of encoded[propertyName]) {
          const relationId = generateId();
          relations[relationId] = {
            from: entityId,
            to: toEntityId,
            fromTypeName: typeName,
            fromPropertyName: propertyName,
            __deleted: false
          };
        }
        delete encoded[propertyName];
      }
    }
    handle.change((doc) => {
      doc.entities ?? (doc.entities = {});
      doc.entities[entityId] = {
        ...encoded,
        "@@types@@": [typeName],
        __deleted: false,
        __version: ""
      };
      doc.relations ?? (doc.relations = {});
      for (const [relationId, relation] of Object.entries(relations)) {
        doc.relations[relationId] = relation;
      }
    });
    return findOne(handle, type)(entityId);
  };
};

// node_modules/@graphprotocol/hypergraph/dist/entity/delete.js
var delete$ = (handle) => {
  return (id) => {
    let result = false;
    handle.change((doc) => {
      var _a, _b2;
      if (((_a = doc.entities) == null ? void 0 : _a[id]) !== void 0) {
        delete doc.entities[id];
        result = true;
      }
      for (const [key, relation] of Object.entries(doc.relations ?? {})) {
        if (((_b2 = doc.relations) == null ? void 0 : _b2[key]) && relation.from === id) {
          delete doc.relations[key];
        }
      }
    });
    return result;
  };
};
var markAsDeleted = (handle) => {
  return (id) => {
    let result = false;
    handle.change((doc) => {
      var _a, _b2;
      if (((_a = doc.entities) == null ? void 0 : _a[id]) !== void 0) {
        doc.entities[id].__deleted = true;
        result = true;
      }
      for (const [key, relation] of Object.entries(doc.relations ?? {})) {
        if (((_b2 = doc.relations) == null ? void 0 : _b2[key]) && relation.from === id) {
          doc.relations[key].__deleted = true;
        }
      }
    });
    return result;
  };
};

// node_modules/@graphprotocol/hypergraph/dist/entity/variant-schema.js
var TypeId = Symbol.for("@effect/experimental/VariantSchema");
var cacheSymbol = Symbol.for("@effect/experimental/VariantSchema/cache");
var isStruct = (u) => hasProperty(u, TypeId);
var FieldTypeId = Symbol.for("@effect/experimental/VariantSchema/Field");
var isField = (u) => hasProperty(u, FieldTypeId);
var extract2 = dual((args) => isStruct(args[0]), (self, variant, options) => {
  const cache = self[cacheSymbol] ?? (self[cacheSymbol] = {});
  const cacheKey = (options == null ? void 0 : options.isDefault) === true ? "__default" : variant;
  if (cache[cacheKey] !== void 0) {
    return cache[cacheKey];
  }
  const fields = {};
  for (const key of Object.keys(self[TypeId])) {
    const value = self[TypeId][key];
    if (TypeId in value) {
      if ((options == null ? void 0 : options.isDefault) === true && isSchema(value)) {
        fields[key] = value;
      } else {
        fields[key] = extract2(value, variant);
      }
    } else if (FieldTypeId in value) {
      if (variant in value.schemas) {
        fields[key] = value.schemas[variant];
      }
    } else {
      fields[key] = value;
    }
  }
  return cache[cacheKey] = Struct(fields);
});
var make = (options) => {
  function Class3(identifier) {
    return (fields, annotations) => {
      var _a, _b2;
      const idField = Field2({
        select: String$
      });
      const deletedField = Field2({
        select: Boolean$
      });
      const versionField = Field2({
        select: String$
      });
      const relationField = Field2({
        select: optional(Struct({
          id: String$
        }))
      });
      const extractFields = {
        ...fields,
        id: idField,
        __deleted: deletedField,
        __version: versionField,
        _relation: relationField
      };
      const variantStruct = Struct2(extractFields);
      const schema = extract2(variantStruct, options.defaultVariant, {
        isDefault: true
      });
      class Base extends (_b2 = Class(identifier)(schema.fields, annotations), _a = TypeId, _b2) {
      }
      __publicField(Base, _a, extractFields);
      for (const variant of options.variants) {
        Object.defineProperty(Base, variant, {
          value: extract2(variantStruct, variant).annotations({
            identifier: `${identifier}.${variant}`,
            title: `${identifier}.${variant}`
          })
        });
      }
      return Base;
    };
  }
  function FieldOnly(...keys) {
    return (schema) => {
      const obj = {};
      for (const key of keys) {
        obj[key] = schema;
      }
      return Field2(obj);
    };
  }
  function FieldExcept(...keys) {
    return (schema) => {
      const obj = {};
      for (const variant of options.variants) {
        if (!keys.includes(variant)) {
          obj[variant] = schema;
        }
      }
      return Field2(obj);
    };
  }
  function UnionVariants(...members) {
    return Union2(members, options.variants);
  }
  const fieldEvolve = dual(2, (self, f) => {
    const field = isField(self) ? self : Field2(Object.fromEntries(options.variants.map((variant) => [variant, self])));
    return Field2(evolve(field.schemas, f));
  });
  const fieldFromKey = dual(2, (self, mapping) => {
    const obj = {};
    if (isField(self)) {
      for (const [key, schema] of Object.entries(self.schemas)) {
        obj[key] = mapping[key] !== void 0 ? renameFieldValue(schema, mapping[key]) : schema;
      }
    } else {
      for (const key of options.variants) {
        obj[key] = mapping[key] !== void 0 ? renameFieldValue(self, mapping[key]) : self;
      }
    }
    return Field2(obj);
  });
  const extractVariants = dual(2, (self, variant) => extract2(self, variant, {
    isDefault: variant === options.defaultVariant
  }));
  return {
    Struct: Struct2,
    Field: Field2,
    FieldOnly,
    FieldExcept,
    Class: Class3,
    Union: UnionVariants,
    fieldEvolve,
    fieldFromKey,
    extract: extractVariants
  };
};
var StructProto = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Struct2 = (fields) => {
  const self = Object.create(StructProto);
  self[TypeId] = fields;
  return self;
};
var FieldProto = {
  [FieldTypeId]: FieldTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Field2 = (schemas) => {
  const self = Object.create(FieldProto);
  self.schemas = schemas;
  return self;
};
var Union2 = (members, variants) => {
  class VariantUnion extends Union(...members.filter((member) => isSchema(member))) {
  }
  for (const variant of variants) {
    Object.defineProperty(VariantUnion, variant, {
      value: Union(...members.map((member) => extract2(member, variant)))
    });
  }
  return VariantUnion;
};
var renameFieldValue = (self, key) => isPropertySignature(self) ? fromKey(self, key) : fromKey(propertySignature(self), key);

// node_modules/@graphprotocol/hypergraph/dist/entity/entity.js
var {
  Class: Class2,
  Field: Field3
  // FieldExcept,
  // FieldOnly,
  // Struct,
  // Union,
  // extract,
  // fieldEvolve,
  // fieldFromKey
} = make({
  variants: ["select", "insert", "update"],
  defaultVariant: "select"
});
var EntityNotFoundError = class extends TaggedError("EntityNotFoundError") {
};

// node_modules/@graphprotocol/hypergraph/dist/utils/internal/deep-merge.js
var isPlainObject = (obj) => typeof obj === "object" && obj !== null && !Array.isArray(obj);
var deepMerge = (target, source) => {
  const result = {
    ...target
  };
  for (const key of Object.keys(source)) {
    const srcVal = source[key];
    const tgtVal = target[key];
    if (isPlainObject(srcVal) && isPlainObject(tgtVal)) {
      result[key] = deepMerge(tgtVal, srcVal);
    } else if (isPlainObject(srcVal)) {
      result[key] = deepMerge({}, srcVal);
    } else {
      result[key] = srcVal;
    }
  }
  return result;
};

// node_modules/@graphprotocol/hypergraph/dist/entity/decodedEntitiesCache.js
var decodedEntitiesCache = /* @__PURE__ */ new Map();

// node_modules/@graphprotocol/hypergraph/dist/entity/entityRelationParentsMap.js
var entityRelationParentsMap = /* @__PURE__ */ new Map();

// node_modules/@graphprotocol/hypergraph/dist/entity/findMany.js
var documentChangeListener = {
  subscribedQueriesCount: 0,
  unsubscribe: void 0
};
var subscribeToDocumentChanges = (handle) => {
  const onChange = ({
    patches,
    doc
  }) => {
    var _a;
    const changedRelations = /* @__PURE__ */ new Set();
    const deletedRelations = /* @__PURE__ */ new Set();
    const changedEntities = /* @__PURE__ */ new Set();
    const deletedEntities = /* @__PURE__ */ new Set();
    for (const patch of patches) {
      switch (patch.action) {
        case "put":
        case "insert":
        case "splice": {
          if (patch.path.length > 2 && patch.path[0] === "entities" && typeof patch.path[1] === "string") {
            changedEntities.add(patch.path[1]);
          }
          if (patch.path.length > 2 && patch.path[0] === "relations" && typeof patch.path[1] === "string") {
            changedRelations.add(patch.path[1]);
          }
          break;
        }
        case "del": {
          if (patch.path.length === 2 && patch.path[0] === "entities" && typeof patch.path[1] === "string") {
            deletedEntities.add(patch.path[1]);
          }
          if (patch.path.length === 2 && patch.path[0] === "relations" && typeof patch.path[1] === "string") {
            deletedRelations.add(patch.path[1]);
          }
          break;
        }
      }
    }
    const entityTypes = /* @__PURE__ */ new Set();
    const touchedQueries = /* @__PURE__ */ new Set();
    const touchedRelationParents = /* @__PURE__ */ new Set();
    for (const entityId of changedEntities) {
      const entity = (_a = doc.entities) == null ? void 0 : _a[entityId];
      if (!hasValidTypesProperty(entity)) continue;
      for (const typeName of entity["@@types@@"]) {
        if (typeof typeName !== "string") continue;
        const cacheEntry = decodedEntitiesCache.get(typeName);
        if (!cacheEntry) continue;
        let includeFromAllQueries = {};
        for (const [, query2] of cacheEntry.queries) {
          includeFromAllQueries = deepMerge(includeFromAllQueries, query2.include);
        }
        const oldDecodedEntry = cacheEntry.entities.get(entityId);
        const relations = getEntityRelations(entityId, cacheEntry.type, doc, includeFromAllQueries);
        let decoded;
        try {
          decoded = cacheEntry.decoder({
            ...entity,
            ...relations,
            id: entityId
          });
          cacheEntry.entities.set(entityId, decoded);
        } catch (error) {
          console.error("error", error);
        }
        if (oldDecodedEntry) {
          const deletedRelationIds = /* @__PURE__ */ new Set();
          for (const [, value] of Object.entries(oldDecodedEntry)) {
            if (Array.isArray(value)) {
              for (const relationEntity of value) {
                deletedRelationIds.add(relationEntity.id);
              }
            }
          }
          for (const deletedRelationId of deletedRelationIds) {
            const deletedRelationEntry = entityRelationParentsMap.get(deletedRelationId);
            if (deletedRelationEntry) {
              deletedRelationEntry.set(cacheEntry, (deletedRelationEntry.get(cacheEntry) ?? 0) - 1);
              if (deletedRelationEntry.get(cacheEntry) === 0) {
                deletedRelationEntry.delete(cacheEntry);
              }
              if (deletedRelationEntry.size === 0) {
                entityRelationParentsMap.delete(deletedRelationId);
              }
            }
          }
        }
        if (decoded) {
          for (const [, value] of Object.entries(decoded)) {
            if (Array.isArray(value)) {
              for (const relationEntity of value) {
                let relationParentEntry = entityRelationParentsMap.get(relationEntity.id);
                if (relationParentEntry) {
                  relationParentEntry.set(cacheEntry, (relationParentEntry.get(cacheEntry) ?? 0) + 1);
                } else {
                  relationParentEntry = /* @__PURE__ */ new Map();
                  entityRelationParentsMap.set(relationEntity.id, relationParentEntry);
                  relationParentEntry.set(cacheEntry, 1);
                }
              }
            }
          }
        }
        for (const [queryKey, query2] of cacheEntry.queries) {
          touchedQueries.add([typeName, queryKey]);
          query2.isInvalidated = true;
        }
        entityTypes.add(typeName);
        if (entityRelationParentsMap.has(entityId)) {
          const decodedEntitiesCacheEntries = entityRelationParentsMap.get(entityId);
          if (!decodedEntitiesCacheEntries) return;
          for (const [entry] of decodedEntitiesCacheEntries) {
            touchedRelationParents.add(entry);
          }
        }
      }
    }
    for (const entityId of deletedEntities) {
      for (const [affectedTypeName, cacheEntry] of decodedEntitiesCache) {
        if (cacheEntry.entities.has(entityId)) {
          entityTypes.add(affectedTypeName);
          cacheEntry.entities.delete(entityId);
          for (const [queryKey, query2] of cacheEntry.queries) {
            const index = query2.data.findIndex((entity) => entity.id === entityId);
            if (index !== -1) {
              query2.data.splice(index, 1);
              touchedQueries.add([affectedTypeName, queryKey]);
            }
          }
        }
      }
      if (entityRelationParentsMap.has(entityId)) {
        const decodedEntitiesCacheEntries = entityRelationParentsMap.get(entityId);
        if (!decodedEntitiesCacheEntries) return;
        for (const [entry] of decodedEntitiesCacheEntries) {
          touchedRelationParents.add(entry);
        }
        entityRelationParentsMap.delete(entityId);
      }
    }
    for (const [typeName, queryKey] of touchedQueries) {
      const cacheEntry = decodedEntitiesCache.get(typeName);
      if (!cacheEntry) continue;
      const query2 = cacheEntry.queries.get(queryKey);
      if (!query2) continue;
      query2.data = [...query2.data];
    }
    for (const typeName of entityTypes) {
      const cacheEntry = decodedEntitiesCache.get(typeName);
      if (!cacheEntry) continue;
      for (const query2 of cacheEntry.queries.values()) {
        for (const listener of query2.listeners) {
          listener();
        }
      }
    }
    for (const decodedEntitiesCacheEntry of touchedRelationParents) {
      decodedEntitiesCacheEntry.isInvalidated = true;
      for (const query2 of decodedEntitiesCacheEntry.queries.values()) {
        query2.isInvalidated = true;
        for (const listener of query2.listeners) {
          listener();
        }
      }
    }
  };
  handle.on("change", onChange);
  return () => {
    handle.off("change", onChange);
    decodedEntitiesCache.clear();
  };
};
function findMany(handle, type, filter, include) {
  const decode = decodeUnknownSync(type);
  const typeName = type.name;
  const doc = handle.doc();
  if (!doc) {
    return {
      entities: [],
      corruptEntityIds: []
    };
  }
  const entities = doc.entities ?? {};
  const corruptEntityIds = [];
  const filtered = [];
  const evaluateFilter = (fieldFilter, fieldValue) => {
    if ("not" in fieldFilter && fieldFilter.not) {
      return !evaluateFilter(fieldFilter.not, fieldValue);
    }
    if ("or" in fieldFilter) {
      const orFilters = fieldFilter.or;
      if (Array.isArray(orFilters)) {
        return orFilters.some((orFilter) => evaluateFilter(orFilter, fieldValue));
      }
    }
    if ("is" in fieldFilter) {
      if (typeof fieldValue === "boolean") {
        return fieldValue === fieldFilter.is;
      }
      if (typeof fieldValue === "number") {
        return fieldValue === fieldFilter.is;
      }
      if (typeof fieldValue === "string") {
        return fieldValue === fieldFilter.is;
      }
    }
    if (typeof fieldValue === "number") {
      if ("greaterThan" in fieldFilter) {
        const numberFilter = fieldFilter;
        if (numberFilter.greaterThan !== void 0 && fieldValue <= numberFilter.greaterThan) {
          return false;
        }
      }
      if ("lessThan" in fieldFilter) {
        const numberFilter = fieldFilter;
        if (numberFilter.lessThan !== void 0 && fieldValue >= numberFilter.lessThan) {
          return false;
        }
      }
    }
    if (typeof fieldValue === "string") {
      if ("startsWith" in fieldFilter) {
        const textFilter = fieldFilter;
        if (textFilter.startsWith !== void 0 && !fieldValue.startsWith(textFilter.startsWith)) {
          return false;
        }
      }
      if ("endsWith" in fieldFilter) {
        const textFilter = fieldFilter;
        if (textFilter.endsWith !== void 0 && !fieldValue.endsWith(textFilter.endsWith)) {
          return false;
        }
      }
      if ("contains" in fieldFilter) {
        const textFilter = fieldFilter;
        if (textFilter.contains !== void 0 && !fieldValue.includes(textFilter.contains)) {
          return false;
        }
      }
    }
    return true;
  };
  const evaluateCrossFieldFilter = (crossFieldFilter, entity) => {
    for (const fieldName in crossFieldFilter) {
      const fieldFilter = crossFieldFilter[fieldName];
      const fieldValue = entity[fieldName];
      if (fieldFilter && !evaluateFilter(fieldFilter, fieldValue)) {
        return false;
      }
    }
    return true;
  };
  const evaluateEntityFilter = (entityFilter, entity) => {
    if ("not" in entityFilter && entityFilter.not) {
      return !evaluateCrossFieldFilter(entityFilter.not, entity);
    }
    if ("or" in entityFilter && Array.isArray(entityFilter.or)) {
      return entityFilter.or.some((orFilter) => evaluateCrossFieldFilter(orFilter, entity));
    }
    return evaluateCrossFieldFilter(entityFilter, entity);
  };
  for (const id in entities) {
    const entity = entities[id];
    if (hasValidTypesProperty(entity) && entity["@@types@@"].includes(typeName)) {
      const relations = getEntityRelations(id, type, doc, include);
      try {
        const decoded = {
          ...decode({
            ...entity,
            ...relations,
            id
          }),
          type: typeName
        };
        if (filter) {
          if (evaluateEntityFilter(filter, decoded)) {
            decoded.__schema = type;
            filtered.push(decoded);
          }
        } else {
          decoded.__schema = type;
          filtered.push(decoded);
        }
      } catch (error) {
        corruptEntityIds.push(id);
      }
    }
  }
  return {
    entities: filtered,
    corruptEntityIds: []
  };
}
var stableEmptyArray = [];
function subscribeToFindMany(handle, type, filter, include) {
  const queryKey = filter ? canonicalize(filter) : "all";
  const decode = decodeUnknownSync(type);
  const typeName = type.name;
  const getEntities = () => {
    const cacheEntry = decodedEntitiesCache.get(typeName);
    if (!cacheEntry) return stableEmptyArray;
    const query2 = cacheEntry.queries.get(queryKey);
    if (!query2) return stableEmptyArray;
    if (!cacheEntry.isInvalidated && !query2.isInvalidated) {
      return query2.data;
    }
    const {
      entities
    } = findMany(handle, type, filter, include);
    for (const entity of entities) {
      cacheEntry == null ? void 0 : cacheEntry.entities.set(entity.id, entity);
    }
    query2.data = [...entities];
    cacheEntry.isInvalidated = false;
    query2.isInvalidated = false;
    return query2.data;
  };
  const allTypes = /* @__PURE__ */ new Set();
  for (const [_key, field] of Object.entries(type.fields)) {
    if (isRelationField(field)) {
      allTypes.add(field);
    }
  }
  const subscribe = (callback) => {
    let cacheEntry = decodedEntitiesCache.get(typeName);
    if (!cacheEntry) {
      const entitiesMap = /* @__PURE__ */ new Map();
      const queries = /* @__PURE__ */ new Map();
      queries.set(queryKey, {
        data: [],
        listeners: [],
        isInvalidated: true,
        include: include ?? {}
      });
      cacheEntry = {
        decoder: decode,
        type,
        entities: entitiesMap,
        queries,
        isInvalidated: true
      };
      decodedEntitiesCache.set(typeName, cacheEntry);
    }
    let query2 = cacheEntry.queries.get(queryKey);
    if (!query2) {
      query2 = {
        data: [],
        listeners: [],
        isInvalidated: true,
        include: include ?? {}
      };
      cacheEntry.queries.set(queryKey, query2);
    }
    if (query2 == null ? void 0 : query2.listeners) {
      query2.listeners.push(callback);
    }
    return () => {
      var _a, _b2;
      const cacheEntry2 = decodedEntitiesCache.get(typeName);
      if (cacheEntry2) {
        const query3 = cacheEntry2.queries.get(queryKey);
        if (query3) {
          query3.listeners = (_a = query3 == null ? void 0 : query3.listeners) == null ? void 0 : _a.filter((cachedListener) => cachedListener !== callback);
          if (query3.listeners.length === 0) {
            cacheEntry2.queries.delete(queryKey);
          }
        }
        if (cacheEntry2.queries.size === 0) {
          entityRelationParentsMap.forEach((relationCacheEntries, key) => {
            for (const [relationCacheEntry, counter] of relationCacheEntries) {
              if (relationCacheEntry === cacheEntry2 && counter === 0) {
                relationCacheEntries.delete(cacheEntry2);
              }
            }
            if (relationCacheEntries.size === 0) {
              entityRelationParentsMap.delete(key);
            }
          });
          decodedEntitiesCache.delete(typeName);
        }
      }
      documentChangeListener.subscribedQueriesCount--;
      if (documentChangeListener.subscribedQueriesCount === 0) {
        (_b2 = documentChangeListener.unsubscribe) == null ? void 0 : _b2.call(documentChangeListener);
        documentChangeListener.unsubscribe = void 0;
      }
    };
  };
  if (documentChangeListener.subscribedQueriesCount === 0) {
    documentChangeListener.unsubscribe = subscribeToDocumentChanges(handle);
  }
  documentChangeListener.subscribedQueriesCount++;
  return {
    subscribe,
    getEntities
  };
}

// node_modules/@graphprotocol/hypergraph/dist/entity/removeRelation.js
var removeRelation = (handle) => {
  return (relationId) => {
    let result = false;
    handle.change((doc) => {
      var _a;
      if (((_a = doc.relations) == null ? void 0 : _a[relationId]) !== void 0) {
        doc.relations[relationId].__deleted = true;
        result = true;
      }
    });
    return result;
  };
};

// node_modules/@graphprotocol/hypergraph/dist/entity/update.js
var update = (handle, type) => {
  const validate = validateSync(partial(type.update));
  const encode = encodeSync(type.update);
  const decode = decodeUnknownSync(type.update);
  const typeName = type.name;
  return (id, data) => {
    validate(data);
    let updated = void 0;
    handle.change((doc) => {
      if (doc.entities === void 0) {
        return;
      }
      const entity = doc.entities[id] ?? void 0;
      if (entity === void 0 || typeof entity !== "object") {
        return;
      }
      updated = {
        ...decode(entity),
        ...data
      };
      const encoded = {
        ...encode(updated),
        "@@types@@": [typeName],
        __deleted: entity.__deleted ?? false,
        __version: entity.__version ?? ""
      };
      for (const key in updated) {
        if (updated[key] === void 0) {
          delete encoded[key];
        }
      }
      doc.entities[id] = encoded;
    });
    if (updated === void 0) {
      throw new EntityNotFoundError({
        id,
        type
      });
    }
    return {
      id,
      type: typeName,
      ...updated,
      // injecting the schema to the entity to be able to access it in the preparePublish function
      __schema: type
    };
  };
};

// node_modules/@graphprotocol/hypergraph/dist/identity/index.js
var identity_exports = {};
__export(identity_exports, {
  InvalidIdentityError: () => InvalidIdentityError2,
  KeysSchema: () => KeysSchema2,
  accountProofDomain: () => accountProofDomain,
  decryptIdentity: () => decryptIdentity2,
  encryptIdentity: () => encryptIdentity2,
  getAccountProofMessage: () => getAccountProofMessage,
  getKeyProofMessage: () => getKeyProofMessage,
  getVerifiedIdentity: () => getVerifiedIdentity,
  loadIdentity: () => loadIdentity,
  logout: () => logout,
  proveIdentityOwnership: () => proveIdentityOwnership,
  storeIdentity: () => storeIdentity,
  verifyIdentityOwnership: () => verifyIdentityOwnership,
  wipeIdentity: () => wipeIdentity
});

// node_modules/@graphprotocol/hypergraph/dist/identity/auth-storage.js
var storeIdentity = (storage, identity) => {
  storage.setItem("hypergraph:app-identity-address", identity.address);
  storage.setItem("hypergraph:app-identity-address-private-key", identity.addressPrivateKey);
  storage.setItem("hypergraph:app-identity-account-address", identity.accountAddress);
  storage.setItem("hypergraph:signature-public-key", identity.signaturePublicKey);
  storage.setItem("hypergraph:signature-private-key", identity.signaturePrivateKey);
  storage.setItem("hypergraph:encryption-public-key", identity.encryptionPublicKey);
  storage.setItem("hypergraph:encryption-private-key", identity.encryptionPrivateKey);
  storage.setItem("hypergraph:session-token", identity.sessionToken);
  storage.setItem("hypergraph:session-token-expires", identity.sessionTokenExpires.toISOString());
  storage.setItem("hypergraph:permission-id", identity.permissionId);
};
var loadIdentity = (storage) => {
  const address = storage.getItem("hypergraph:app-identity-address");
  const addressPrivateKey = storage.getItem("hypergraph:app-identity-address-private-key");
  const accountAddress = storage.getItem("hypergraph:app-identity-account-address");
  const signaturePublicKey = storage.getItem("hypergraph:signature-public-key");
  const signaturePrivateKey = storage.getItem("hypergraph:signature-private-key");
  const encryptionPublicKey = storage.getItem("hypergraph:encryption-public-key");
  const encryptionPrivateKey = storage.getItem("hypergraph:encryption-private-key");
  const sessionToken = storage.getItem("hypergraph:session-token");
  const sessionTokenExpires = storage.getItem("hypergraph:session-token-expires");
  const permissionId = storage.getItem("hypergraph:permission-id");
  if (!address || !addressPrivateKey || !accountAddress || !signaturePublicKey || !signaturePrivateKey || !encryptionPublicKey || !encryptionPrivateKey || !sessionToken || !sessionTokenExpires || !permissionId) {
    return null;
  }
  return {
    address,
    addressPrivateKey,
    accountAddress,
    signaturePublicKey,
    signaturePrivateKey,
    encryptionPublicKey,
    encryptionPrivateKey,
    sessionToken,
    sessionTokenExpires: new Date(sessionTokenExpires),
    permissionId
  };
};
var wipeIdentity = (storage) => {
  storage.removeItem("hypergraph:app-identity-address");
  storage.removeItem("hypergraph:app-identity-address-private-key");
  storage.removeItem("hypergraph:app-identity-account-address");
  storage.removeItem("hypergraph:signature-public-key");
  storage.removeItem("hypergraph:signature-private-key");
  storage.removeItem("hypergraph:encryption-public-key");
  storage.removeItem("hypergraph:encryption-private-key");
  storage.removeItem("hypergraph:session-token");
  storage.removeItem("hypergraph:session-token-expires");
  storage.removeItem("hypergraph:permission-id");
};

// node_modules/@graphprotocol/hypergraph/dist/store.js
var initialStoreContext2 = {
  spaces: [],
  spacesLoadingIsPending: true,
  updatesInFlight: [],
  invitations: [],
  repo: null,
  identities: {},
  authenticated: false,
  identity: null,
  lastUpdateClock: {},
  accountInboxes: [],
  mapping: {}
};
var store2 = createStore({
  context: initialStoreContext2,
  on: {
    setInvitations: (context, event) => {
      return {
        ...context,
        invitations: event.invitations
      };
    },
    setMapping: (context, event) => {
      return {
        ...context,
        mapping: event.mapping
      };
    },
    reset: (context) => {
      return {
        ...initialStoreContext2,
        repo: context.repo,
        mapping: context.mapping
      };
    },
    addUpdateInFlight: (context, event) => {
      return {
        ...context,
        updatesInFlight: [...context.updatesInFlight, event.updateId]
      };
    },
    removeUpdateInFlight: (context, event) => {
      return {
        ...context,
        updatesInFlight: context.updatesInFlight.filter((id) => id !== event.updateId)
      };
    },
    setSpacesList: (context, event) => {
      if (!context.repo) {
        return context;
      }
      let storeContext = {
        ...context,
        spacesLoadingIsPending: false
      };
      for (const space of event.spaces) {
        const existingSpace = context.spaces.find((s) => s.id === space.id);
        const lastUpdateClock = context.lastUpdateClock[space.id] ?? -1;
        const result = context.repo.findWithProgress(idToAutomergeId(space.id));
        result.handle.doneLoading();
        if (existingSpace) {
          storeContext = {
            ...storeContext,
            spaces: storeContext.spaces.map((existingSpace2) => {
              if (existingSpace2.id === space.id) {
                const newSpace = {
                  id: existingSpace2.id,
                  name: existingSpace2.name,
                  events: existingSpace2.events ?? [],
                  state: existingSpace2.state,
                  keys: existingSpace2.keys ?? [],
                  automergeDocHandle: result.handle,
                  inboxes: existingSpace2.inboxes ?? []
                };
                return newSpace;
              }
              return existingSpace2;
            }),
            lastUpdateClock: {
              ...storeContext.lastUpdateClock,
              [space.id]: lastUpdateClock
            }
          };
        } else {
          storeContext = {
            ...storeContext,
            spaces: [...storeContext.spaces, {
              id: space.id,
              name: space.name,
              events: [],
              state: void 0,
              keys: [],
              inboxes: [],
              automergeDocHandle: result.handle
            }],
            lastUpdateClock: {
              ...storeContext.lastUpdateClock,
              [space.id]: -1
            }
          };
        }
      }
      return storeContext;
    },
    applyEvent: (context, event) => {
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            return {
              ...space,
              events: [...space.events, event.event],
              state: event.state
            };
          }
          return space;
        })
      };
    },
    updateConfirmed: (context, event) => {
      return {
        ...context,
        lastUpdateClock: {
          ...context.lastUpdateClock,
          [event.spaceId]: event.clock
        }
      };
    },
    applyUpdate: (context, event) => {
      const lastUpdateClock = context.lastUpdateClock[event.spaceId] ?? -1;
      if (event.firstUpdateClock === lastUpdateClock + 1) {
        return {
          ...context,
          lastUpdateClock: {
            ...context.lastUpdateClock,
            [event.spaceId]: event.lastUpdateClock
          }
        };
      }
      return context;
    },
    addVerifiedIdentity: (context, event) => {
      return {
        ...context,
        identities: {
          ...context.identities,
          [event.accountAddress]: {
            encryptionPublicKey: event.encryptionPublicKey,
            signaturePublicKey: event.signaturePublicKey,
            accountProof: event.accountProof,
            keyProof: event.keyProof
          }
        }
      };
    },
    setSpaceInbox: (context, event) => {
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            const existingInbox = space.inboxes.find((inbox) => inbox.inboxId === event.inbox.inboxId);
            if (existingInbox) {
              return {
                ...space,
                inboxes: space.inboxes.map((inbox) => {
                  if (inbox.inboxId === event.inbox.inboxId) {
                    const {
                      messages,
                      seenMessageIds
                    } = mergeMessages(existingInbox.messages, existingInbox.seenMessageIds, event.inbox.messages);
                    return {
                      ...event.inbox,
                      messages,
                      seenMessageIds
                    };
                  }
                  return inbox;
                })
              };
            }
            return {
              ...space,
              inboxes: [...space.inboxes, event.inbox]
            };
          }
          return space;
        })
      };
    },
    setSpaceInboxMessages: (context, event) => {
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            return {
              ...space,
              inboxes: space.inboxes.map((inbox) => {
                if (inbox.inboxId === event.inboxId) {
                  const {
                    messages,
                    seenMessageIds
                  } = mergeMessages(inbox.messages, inbox.seenMessageIds, event.messages);
                  return {
                    ...inbox,
                    messages,
                    seenMessageIds,
                    lastMessageClock: new Date(Math.max(new Date(inbox.lastMessageClock).getTime(), new Date(event.lastMessageClock).getTime())).toISOString()
                  };
                }
                return inbox;
              })
            };
          }
          return space;
        })
      };
    },
    setAccountInbox: (context, event) => {
      const existingInbox = context.accountInboxes.find((inbox) => inbox.inboxId === event.inbox.inboxId);
      if (existingInbox) {
        return {
          ...context,
          accountInboxes: context.accountInboxes.map((inbox) => {
            if (inbox.inboxId === event.inbox.inboxId) {
              const {
                messages,
                seenMessageIds
              } = mergeMessages(existingInbox.messages, existingInbox.seenMessageIds, event.inbox.messages);
              return {
                ...event.inbox,
                messages,
                seenMessageIds
              };
            }
            return inbox;
          })
        };
      }
      return {
        ...context,
        accountInboxes: [...context.accountInboxes, event.inbox]
      };
    },
    setAccountInboxMessages: (context, event) => {
      return {
        ...context,
        accountInboxes: context.accountInboxes.map((inbox) => {
          if (inbox.inboxId === event.inboxId) {
            const {
              messages,
              seenMessageIds
            } = mergeMessages(inbox.messages, inbox.seenMessageIds, event.messages);
            return {
              ...inbox,
              messages,
              seenMessageIds,
              lastMessageClock: new Date(Math.max(new Date(inbox.lastMessageClock).getTime(), new Date(event.lastMessageClock).getTime())).toISOString()
            };
          }
          return inbox;
        })
      };
    },
    setSpace: (context, event) => {
      var _a;
      const existingSpace = context.spaces.find((s) => s.id === event.spaceId);
      if (!existingSpace && context.repo) {
        const result = context.repo.findWithProgress(idToAutomergeId(event.spaceId));
        result.handle.doneLoading();
        const newSpace = {
          name: event.name,
          id: event.spaceId,
          events: event.events,
          state: event.spaceState,
          keys: event.keys,
          automergeDocHandle: result.handle,
          inboxes: event.inboxes ?? []
        };
        return {
          ...context,
          spaces: [...context.spaces, newSpace],
          lastUpdateClock: {
            ...context.lastUpdateClock,
            [event.spaceId]: -1
          }
        };
      }
      let lastUpdateClock = context.lastUpdateClock[event.spaceId] ?? -1;
      if (((_a = event.updates) == null ? void 0 : _a.firstUpdateClock) === lastUpdateClock + 1) {
        lastUpdateClock = event.updates.lastUpdateClock;
      } else {
      }
      return {
        ...context,
        spaces: context.spaces.map((space) => {
          if (space.id === event.spaceId) {
            const mergedInboxes = [...space.inboxes];
            for (const newInbox of event.inboxes ?? []) {
              const existingInboxIndex = mergedInboxes.findIndex((inbox) => inbox.inboxId === newInbox.inboxId);
              if (existingInboxIndex === -1) {
                mergedInboxes.push(newInbox);
              }
            }
            return {
              ...space,
              events: event.events,
              state: event.spaceState,
              keys: event.keys,
              inboxes: mergedInboxes
            };
          }
          return space;
        }),
        lastUpdateClock: {
          ...context.lastUpdateClock,
          [event.spaceId]: lastUpdateClock
        }
      };
    },
    setAuth: (context, event) => {
      return {
        ...context,
        authenticated: true,
        // TODO: remove hard-coded account address and use the one from the identity
        identity: {
          ...event.identity
        }
      };
    },
    resetAuth: (context) => {
      return {
        ...context,
        identity: null,
        authenticated: false
      };
    },
    setRepo: (context, event) => {
      return {
        ...context,
        repo: event.repo
      };
    }
  }
});

// node_modules/@graphprotocol/hypergraph/dist/identity/get-verified-identity.js
var getVerifiedIdentity = async (accountAddress, syncServerUri, chain, rpcUrl) => {
  const storeState = store2.getSnapshot();
  const identity = storeState.context.identities[accountAddress];
  if (identity) {
    return {
      accountAddress,
      encryptionPublicKey: identity.encryptionPublicKey,
      signaturePublicKey: identity.signaturePublicKey
    };
  }
  const res = await fetch(`${syncServerUri}/identity?accountAddress=${accountAddress}`);
  if (res.status !== 200) {
    throw new Error("Failed to fetch identity");
  }
  const resDecoded = decodeUnknownSync(ResponseIdentity)(await res.json());
  if (!await verifyIdentityOwnership(resDecoded.accountAddress, resDecoded.signaturePublicKey, resDecoded.accountProof, resDecoded.keyProof, chain, rpcUrl)) {
    throw new Error("Invalid identity in getVerifiedIdentity");
  }
  store2.send({
    type: "addVerifiedIdentity",
    accountAddress: resDecoded.accountAddress,
    encryptionPublicKey: resDecoded.encryptionPublicKey,
    signaturePublicKey: resDecoded.signaturePublicKey,
    accountProof: resDecoded.accountProof,
    keyProof: resDecoded.keyProof
  });
  return {
    accountAddress: resDecoded.accountAddress,
    encryptionPublicKey: resDecoded.encryptionPublicKey,
    signaturePublicKey: resDecoded.signaturePublicKey
  };
};

// node_modules/@graphprotocol/hypergraph/dist/identity/identity-encryption.js
var hkdfDeriveKey2 = (secret, salt) => {
  return hkdf(sha256, secret, salt, "", 32);
};
var encrypt2 = (msg, secret) => {
  const hkdfSalt = randomBytes2(32);
  const gcmNonce = randomBytes2(12);
  const derivedKey = hkdfDeriveKey2(secret, hkdfSalt);
  const aes = gcm(derivedKey, gcmNonce);
  const ciphertext = aes.encrypt(msg);
  const ciphertextJson = canonicalize({
    aes256GcmHkdfSha256: {
      payload: bytesToHex4(ciphertext),
      hkdfSalt: bytesToHex4(hkdfSalt),
      gcmNonce: bytesToHex4(gcmNonce)
    }
  });
  return bytesToHex4(new TextEncoder().encode(ciphertextJson));
};
var decrypt2 = (ciphertext, secret) => {
  const ciphertextJson = new TextDecoder().decode(hexToBytes4(ciphertext));
  const {
    aes256GcmHkdfSha256
  } = JSON.parse(ciphertextJson);
  const hkdfSalt = hexToBytes4(aes256GcmHkdfSha256.hkdfSalt);
  const gcmNonce = hexToBytes4(aes256GcmHkdfSha256.gcmNonce);
  const derivedKey = hkdfDeriveKey2(secret, hkdfSalt);
  const aes = gcm(derivedKey, gcmNonce);
  return aes.decrypt(hexToBytes4(aes256GcmHkdfSha256.payload));
};
var signatureMessage2 = (nonce) => {
  return `The Graph: sign to encrypt/decrypt identity keys.
Nonce: ${bytesToHex4(nonce)}
`;
};
var encryptIdentity2 = async (signer, accountAddress, keys) => {
  const nonce = randomBytes2(32);
  const message = signatureMessage2(nonce);
  const signature = await signer.signMessage(message);
  const valid = await verifyMessage({
    address: accountAddress,
    message,
    signature
  });
  if (!valid) {
    throw new Error("Invalid signature");
  }
  const secretKey = hexToBytes4(signature);
  const keysTxt = [keys.encryptionPublicKey, keys.encryptionPrivateKey, keys.signaturePublicKey, keys.signaturePrivateKey].join("\n");
  const keysMsg = new TextEncoder().encode(keysTxt);
  const ciphertext = encrypt2(keysMsg, secretKey);
  return {
    ciphertext,
    nonce: bytesToHex4(nonce)
  };
};
var decryptIdentity2 = async (signer, accountAddress, ciphertext, nonce) => {
  const message = signatureMessage2(hexToBytes4(nonce));
  const signature = await signer.signMessage(message);
  const valid = await verifyMessage({
    address: accountAddress,
    message,
    signature
  });
  if (!valid) {
    throw new Error("Invalid signature");
  }
  const secretKey = hexToBytes4(signature);
  let keysMsg;
  try {
    keysMsg = await decrypt2(ciphertext, secretKey);
  } catch (e) {
    if (secretKey.length !== 65) {
      throw new Error("Expected 65 bytes before trying a different recovery byte");
    }
    const lastByte = secretKey[secretKey.length - 1];
    let newSecret = secretKey.slice(0, secretKey.length - 1);
    if (lastByte < 27) {
      newSecret = new Uint8Array([...newSecret, lastByte + 27]);
    } else {
      newSecret = new Uint8Array([...newSecret, lastByte - 27]);
    }
    keysMsg = await decrypt2(ciphertext, newSecret);
  }
  const keysTxt = new TextDecoder().decode(keysMsg);
  const [encryptionPublicKey, encryptionPrivateKey, signaturePublicKey, signaturePrivateKey] = keysTxt.split("\n");
  return {
    encryptionPublicKey,
    encryptionPrivateKey,
    signaturePublicKey,
    signaturePrivateKey
  };
};

// node_modules/@graphprotocol/hypergraph/dist/identity/logout.js
function logout(storage) {
  wipeIdentity(storage);
  store2.send({
    type: "resetAuth"
  });
}

// node_modules/@graphprotocol/hypergraph/dist/identity/types.js
var KeysSchema2 = Schema_exports.Struct({
  encryptionPublicKey: Schema_exports.String,
  encryptionPrivateKey: Schema_exports.String,
  signaturePublicKey: Schema_exports.String,
  signaturePrivateKey: Schema_exports.String
});
var InvalidIdentityError2 = class {
  constructor() {
    __publicField(this, "_tag", "InvalidIdentityError");
  }
};

// node_modules/@graphprotocol/hypergraph/dist/inboxes/index.js
var inboxes_exports = {};
__export(inboxes_exports, {
  InboxSenderAuthPolicy: () => InboxSenderAuthPolicy,
  createAccountInboxCreationMessage: () => createAccountInboxCreationMessage,
  createSpaceInboxCreationMessage: () => createSpaceInboxCreationMessage,
  decryptInboxMessage: () => decryptInboxMessage,
  encryptInboxMessage: () => encryptInboxMessage,
  getAccountInbox: () => getAccountInbox,
  getSpaceInbox: () => getSpaceInbox,
  listPublicAccountInboxes: () => listPublicAccountInboxes,
  listPublicSpaceInboxes: () => listPublicSpaceInboxes,
  mergeMessages: () => mergeMessages,
  prepareAccountInboxMessage: () => prepareAccountInboxMessage,
  prepareSpaceInboxMessage: () => prepareSpaceInboxMessage,
  recoverAccountInboxCreatorKey: () => recoverAccountInboxCreatorKey,
  recoverAccountInboxMessageSigner: () => recoverAccountInboxMessageSigner,
  recoverSpaceInboxCreatorKey: () => recoverSpaceInboxCreatorKey,
  recoverSpaceInboxMessageSigner: () => recoverSpaceInboxMessageSigner,
  sendAccountInboxMessage: () => sendAccountInboxMessage,
  sendSpaceInboxMessage: () => sendSpaceInboxMessage,
  validateAccountInboxMessage: () => validateAccountInboxMessage,
  validateSpaceInboxMessage: () => validateSpaceInboxMessage
});

// node_modules/@graphprotocol/hypergraph/dist/inboxes/create-inbox.js
function createAccountInboxCreationMessage({
  accountAddress,
  isPublic,
  authPolicy,
  encryptionPublicKey,
  signaturePrivateKey
}) {
  const inboxId = bytesToHex4(randomBytes(32));
  const messageToSign = stringToUint8Array(canonicalize({
    accountAddress,
    inboxId,
    encryptionPublicKey
  }));
  const signature = secp256k1.sign(messageToSign, hexToBytes4(signaturePrivateKey), {
    prehash: true
  });
  return {
    type: "create-account-inbox",
    inboxId,
    accountAddress,
    isPublic,
    authPolicy,
    encryptionPublicKey,
    signature: {
      hex: signature.toCompactHex(),
      recovery: signature.recovery
    }
  };
}
async function createSpaceInboxCreationMessage({
  author,
  spaceId,
  isPublic,
  authPolicy,
  spaceSecretKey,
  previousEventHash
}) {
  const inboxId = bytesToHex4(randomBytes(32));
  const {
    publicKey,
    privateKey
  } = cryptoBoxKeyPair();
  const encryptedInboxSecretKey = encryptMessage({
    message: privateKey,
    secretKey: hexToBytes4(spaceSecretKey)
  });
  const spaceEvent = await Effect_exports.runPromise(createInbox({
    spaceId,
    inboxId,
    encryptionPublicKey: bytesToHex4(publicKey),
    secretKey: bytesToHex4(encryptedInboxSecretKey),
    isPublic,
    authPolicy,
    author,
    previousEventHash
  }));
  return {
    type: "create-space-inbox-event",
    spaceId,
    event: spaceEvent
  };
}

// node_modules/@graphprotocol/hypergraph/dist/inboxes/get-list-inboxes.js
var listPublicSpaceInboxes = async ({
  spaceId,
  syncServerUri
}) => {
  const res = await fetch(new URL(`/spaces/${spaceId}/inboxes`, syncServerUri), {
    method: "GET"
  });
  const decoded = Schema_exports.decodeUnknownSync(ResponseListSpaceInboxesPublic)(await res.json());
  return decoded.inboxes;
};
var listPublicAccountInboxes = async ({
  accountAddress,
  syncServerUri
}) => {
  const res = await fetch(new URL(`/accounts/${accountAddress}/inboxes`, syncServerUri), {
    method: "GET"
  });
  const decoded = Schema_exports.decodeUnknownSync(ResponseListAccountInboxesPublic)(await res.json());
  return decoded.inboxes;
};
var getSpaceInbox = async ({
  spaceId,
  inboxId,
  syncServerUri
}) => {
  const res = await fetch(new URL(`/spaces/${spaceId}/inboxes/${inboxId}`, syncServerUri), {
    method: "GET"
  });
  const decoded = Schema_exports.decodeUnknownSync(ResponseSpaceInboxPublic)(await res.json());
  return decoded.inbox;
};
var getAccountInbox = async ({
  accountAddress,
  inboxId,
  syncServerUri
}) => {
  const res = await fetch(new URL(`/accounts/${accountAddress}/inboxes/${inboxId}`, syncServerUri), {
    method: "GET"
  });
  const decoded = Schema_exports.decodeUnknownSync(ResponseAccountInboxPublic)(await res.json());
  return decoded.inbox;
};

// node_modules/@graphprotocol/hypergraph/dist/inboxes/message-encryption.js
function encryptInboxMessage({
  message,
  encryptionPublicKey
}) {
  const ciphertext = cryptoBoxSeal({
    message: stringToUint8Array(message),
    publicKey: hexToBytes4(encryptionPublicKey)
  });
  return {
    ciphertext: bytesToHex4(ciphertext)
  };
}
function decryptInboxMessage({
  ciphertext,
  encryptionPrivateKey,
  encryptionPublicKey
}) {
  const publicKey = hexToBytes4(encryptionPublicKey);
  const privateKey = hexToBytes4(encryptionPrivateKey);
  const message = cryptoBoxSealOpen({
    ciphertext: hexToBytes4(ciphertext),
    privateKey,
    publicKey
  });
  return uint8ArrayToString(message);
}

// node_modules/@graphprotocol/hypergraph/dist/inboxes/recover-inbox-message-signer.js
var recoverSpaceInboxMessageSigner = (message, spaceId, inboxId) => {
  if (!message.signature) {
    throw new Error("Signature is required");
  }
  let signatureInstance = secp256k1.Signature.fromCompact(message.signature.hex);
  signatureInstance = signatureInstance.addRecoveryBit(message.signature.recovery);
  const signedMessage = {
    spaceId,
    inboxId,
    ciphertext: message.ciphertext,
    authorAccountAddress: message.authorAccountAddress
  };
  return `0x${signatureInstance.recoverPublicKey(sha256(stringToUint8Array(canonicalize(signedMessage)))).toHex()}`;
};
var recoverAccountInboxMessageSigner = (message, accountAddress, inboxId) => {
  if (!message.signature) {
    throw new Error("Signature is required");
  }
  let signatureInstance = secp256k1.Signature.fromCompact(message.signature.hex);
  signatureInstance = signatureInstance.addRecoveryBit(message.signature.recovery);
  const signedMessage = {
    accountAddress,
    inboxId,
    ciphertext: message.ciphertext,
    authorAccountAddress: message.authorAccountAddress
  };
  return `0x${signatureInstance.recoverPublicKey(sha256(stringToUint8Array(canonicalize(signedMessage)))).toHex()}`;
};

// node_modules/@graphprotocol/hypergraph/dist/inboxes/message-validation.js
var validateSpaceInboxMessage = async (message, inbox, spaceId, syncServerUri, chain, rpcUrl) => {
  if (message.signature) {
    if (inbox.authPolicy === "anonymous") {
      console.error("Signed message in anonymous inbox");
      return false;
    }
    if (!message.authorAccountAddress) {
      console.error("Signed message without authorAccountAddress");
      return false;
    }
    const signer = recoverSpaceInboxMessageSigner(message, spaceId, inbox.inboxId);
    const verifiedIdentity = await getVerifiedIdentity(message.authorAccountAddress, syncServerUri, chain, rpcUrl);
    const isValid2 = signer === verifiedIdentity.signaturePublicKey;
    if (!isValid2) {
      console.error("Invalid signature", signer, verifiedIdentity.signaturePublicKey);
    }
    return isValid2;
  }
  const isValid = inbox.authPolicy !== "requires_auth";
  if (!isValid) {
    console.error("Unsigned message in required auth inbox");
  }
  return isValid;
};
var validateAccountInboxMessage = async (message, inbox, accountAddress, syncServerUri, chain, rpcUrl) => {
  if (message.signature) {
    if (inbox.authPolicy === "anonymous") {
      console.error("Signed message in anonymous inbox");
      return false;
    }
    if (!message.authorAccountAddress) {
      console.error("Signed message without authorAccountAddress");
      return false;
    }
    const signer = recoverAccountInboxMessageSigner(message, accountAddress, inbox.inboxId);
    const verifiedIdentity = await getVerifiedIdentity(message.authorAccountAddress, syncServerUri, chain, rpcUrl);
    const isValid2 = signer === verifiedIdentity.signaturePublicKey;
    if (!isValid2) {
      console.error("Invalid signature", signer, verifiedIdentity.signaturePublicKey);
    }
    return isValid2;
  }
  const isValid = inbox.authPolicy !== "requires_auth";
  if (!isValid) {
    console.error("Unsigned message in required auth inbox");
  }
  return isValid;
};

// node_modules/@graphprotocol/hypergraph/dist/inboxes/prepare-message.js
async function prepareSpaceInboxMessage({
  message,
  spaceId,
  inboxId,
  encryptionPublicKey,
  signaturePrivateKey,
  authorAccountAddress
}) {
  const {
    ciphertext
  } = encryptInboxMessage({
    message,
    encryptionPublicKey
  });
  let signature;
  if (signaturePrivateKey && authorAccountAddress) {
    const messageToSign = stringToUint8Array(canonicalize({
      spaceId,
      inboxId,
      ciphertext,
      authorAccountAddress
    }));
    const signatureInstance = secp256k1.sign(messageToSign, hexToBytes4(signaturePrivateKey), {
      prehash: true
    });
    signature = {
      hex: signatureInstance.toCompactHex(),
      recovery: signatureInstance.recovery
    };
  }
  const messageToSend = {
    ciphertext,
    signature,
    authorAccountAddress: authorAccountAddress ?? void 0
  };
  return messageToSend;
}
async function prepareAccountInboxMessage({
  message,
  accountAddress,
  inboxId,
  encryptionPublicKey,
  signaturePrivateKey,
  authorAccountAddress
}) {
  const {
    ciphertext
  } = encryptInboxMessage({
    message,
    encryptionPublicKey
  });
  let signature;
  if (signaturePrivateKey && authorAccountAddress) {
    const messageToSign = stringToUint8Array(canonicalize({
      accountAddress,
      inboxId,
      ciphertext,
      authorAccountAddress
    }));
    const signatureInstance = secp256k1.sign(messageToSign, hexToBytes4(signaturePrivateKey), {
      prehash: true
    });
    signature = {
      hex: signatureInstance.toCompactHex(),
      recovery: signatureInstance.recovery
    };
  }
  const messageToSend = {
    ciphertext,
    signature,
    authorAccountAddress: authorAccountAddress ?? void 0
  };
  return messageToSend;
}

// node_modules/@graphprotocol/hypergraph/dist/inboxes/recover-inbox-creator.js
var recoverAccountInboxCreatorKey = (inbox) => {
  const messageToVerify = stringToUint8Array(canonicalize({
    accountAddress: inbox.accountAddress,
    inboxId: inbox.inboxId,
    encryptionPublicKey: inbox.encryptionPublicKey
  }));
  const signature = inbox.signature;
  let signatureInstance = secp256k1.Signature.fromCompact(signature.hex);
  signatureInstance = signatureInstance.addRecoveryBit(signature.recovery);
  const authorPublicKey = `0x${signatureInstance.recoverPublicKey(sha256(messageToVerify)).toHex()}`;
  return authorPublicKey;
};
var recoverSpaceInboxCreatorKey = (event) => {
  const messageToVerify = stringToUint8Array(canonicalize(event.transaction));
  const signature = event.author.signature;
  let signatureInstance = secp256k1.Signature.fromCompact(signature.hex);
  signatureInstance = signatureInstance.addRecoveryBit(signature.recovery);
  const authorPublicKey = `0x${signatureInstance.recoverPublicKey(sha256(messageToVerify)).toHex()}`;
  return authorPublicKey;
};

// node_modules/@graphprotocol/hypergraph/dist/inboxes/send-message.js
async function sendSpaceInboxMessage({
  message,
  spaceId,
  inboxId,
  encryptionPublicKey,
  signaturePrivateKey,
  authorAccountAddress,
  syncServerUri
}) {
  const messageToSend = await prepareSpaceInboxMessage({
    message,
    spaceId,
    inboxId,
    encryptionPublicKey,
    signaturePrivateKey,
    authorAccountAddress
  });
  const res = await fetch(new URL(`/spaces/${spaceId}/inboxes/${inboxId}/messages`, syncServerUri), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(messageToSend)
  });
  if (!res.ok) {
    throw new Error("Failed to send message");
  }
}
async function sendAccountInboxMessage({
  message,
  accountAddress,
  inboxId,
  encryptionPublicKey,
  signaturePrivateKey,
  authorAccountAddress,
  syncServerUri
}) {
  const messageToSend = await prepareAccountInboxMessage({
    message,
    accountAddress,
    inboxId,
    encryptionPublicKey,
    signaturePrivateKey,
    authorAccountAddress
  });
  const res = await fetch(new URL(`/accounts/${accountAddress}/inboxes/${inboxId}/messages`, syncServerUri), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(messageToSend)
  });
  if (!res.ok) {
    throw new Error("Failed to send message");
  }
}

// node_modules/@graphprotocol/hypergraph/dist/space-info/index.js
var space_info_exports = {};
__export(space_info_exports, {
  SpaceInfoContent: () => SpaceInfoContent,
  decryptSpaceInfo: () => decryptSpaceInfo,
  encryptAndSignSpaceInfo: () => encryptAndSignSpaceInfo
});

// node_modules/@graphprotocol/hypergraph/dist/space-info/types.js
var SpaceInfoContent = Struct({
  name: String$
});

// node_modules/@graphprotocol/hypergraph/dist/space-info/decrypt-space-info.js
var decodeSpaceInfoContent = decodeSync(SpaceInfoContent);
var decryptSpaceInfo = ({
  spaceInfo,
  secretKey
}) => {
  const decrypted = decryptMessage({
    nonceAndCiphertext: spaceInfo,
    secretKey: hexToBytes4(secretKey)
  });
  const spaceInfoContent = decodeSpaceInfoContent(JSON.parse(bytesToUtf8(decrypted)));
  return spaceInfoContent;
};

// node_modules/@graphprotocol/hypergraph/dist/space-info/encrypt-and-sign-space-info.js
var encodeSpaceInfoContent = encodeSync(SpaceInfoContent);
var encryptAndSignSpaceInfo = ({
  accountAddress,
  name,
  secretKey,
  signaturePrivateKey,
  spaceId
}) => {
  const infoContent = encryptMessage({
    message: utf8ToBytes(JSON.stringify(encodeSpaceInfoContent({
      name
    }))),
    secretKey: hexToBytes4(secretKey)
  });
  const messageToSign = stringToUint8Array(canonicalize({
    accountAddress,
    infoContent,
    spaceId
  }));
  const recoverySignature = secp256k1.sign(messageToSign, hexToBytes4(signaturePrivateKey), {
    prehash: true
  });
  const signature = {
    hex: recoverySignature.toCompactHex(),
    recovery: recoverySignature.recovery
  };
  return {
    infoContent,
    accountAddress,
    signature
  };
};

// node_modules/@graphprotocol/hypergraph/dist/type/type.js
var type_exports = {};
__export(type_exports, {
  Checkbox: () => Checkbox,
  Date: () => Date2,
  Number: () => Number2,
  Point: () => Point2,
  Relation: () => Relation,
  Text: () => Text,
  Url: () => Url
});
var Text = String$;
var Number2 = Number$;
var Checkbox = Boolean$;
var Date2 = Date$;
var Url = URL$;
var Point2 = transform(String$, Array$(Number2), {
  strict: true,
  decode: (str) => {
    return str.split(",").map((n) => globalThis.Number(n));
  },
  encode: (points) => points.join(",")
});
var Relation = (schema) => {
  const relationSchema = Field3({
    select: Array$(schema),
    insert: optional(Array$(String$)),
    update: Undefined
  });
  return relationSchema;
};

export {
  utils_exports,
  SignatureWithRecovery,
  ConnectAuthPayload,
  ConnectCallbackResult,
  ConnectCallbackDecryptedData,
  FailedToParseConnectAuthUrl,
  FailedToParseAuthCallbackUrl,
  space_events_exports,
  messages_exports,
  key_exports,
  store_connect_exports,
  connect_exports,
  entity_exports,
  store2 as store,
  identity_exports,
  inboxes_exports,
  space_info_exports,
  type_exports
};
/*! Bundled license information:

@noble/secp256k1/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-L7QERQOG.js.map
